from nornir import InitNornir
from nornir_napalm.plugins.tasks import napalm_get
from nornir_netmiko.tasks import netmiko_send_command
import logging

# Setup logging
logging.basicConfig(filename="vlan_path_check.log", level=logging.DEBUG, format="%(asctime)s [%(levelname)s] %(message)s")

nr = InitNornir(config_file="config.yaml")


def resolve_neighbor_name(neighbor_info):
    return neighbor_info.get("hostname")  # Adjust if FQDN/IP used


def verify_vlan_tagged(device, interface, vlan_id):
    """Check if VLAN is tagged on a trunk port"""
    result = device.run(task=netmiko_send_command, command_string=f"show interfaces {interface} switchport")
    output = list(result.values())[0].result

    if "Administrative Mode: trunk" not in output:
        return False
    
    # Try to find VLAN ID in allowed VLANs
    for line in output.splitlines():
        if "Trunking VLANs Enabled:" in line or "Access Mode VLAN:" in line:
            if str(vlan_id) in line:
                return True
    return False


def get_device_data(hostname):
    device = nr.filter(name=hostname)
    result = device.run(task=napalm_get, getters=["interfaces", "lldp_neighbors", "get_vlans"])
    return result[hostname].result


def walk_vlan_path(current_device, incoming_interface, vlan_id, target_router, visited=None):
    if visited is None:
        visited = set()

    if current_device in visited:
        logging.warning(f"Loop detected at {current_device}")
        return False, f"Loop detected at {current_device}"
    visited.add(current_device)

    logging.info(f"Checking device {current_device}...")

    device_data = get_device_data(current_device)
    vlan_db = device_data.get("get_vlans", {})
    interfaces = device_data.get("interfaces", {})
    neighbors = device_data.get("lldp_neighbors", {})

    if str(vlan_id) not in vlan_db:
        return False, f"VLAN {vlan_id} missing in VLAN DB on {current_device}"

    if incoming_interface:
        if not verify_vlan_tagged(nr.filter(name=current_device), incoming_interface, vlan_id):
            return False, f"VLAN {vlan_id} not tagged on trunk {incoming_interface} on {current_device}"
from nornir import InitNornir
from nornir_netmiko import netmiko_send_command
from nornir.core.task import Task, Result
from typing import Dict, List, Tuple, Optional, Set
import networkx as nx
import matplotlib.pyplot as plt
import re
import logging
from dataclasses import dataclass
from enum import Enum

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class VerificationStatus(Enum):
    PASS = "pass"
    FAIL = "fail"
    UNKNOWN = "unknown"

@dataclass
class DeviceResult:
    device_ip: str
    vlan_status: str
    port_status: Optional[str] = None
    trunk_status: Optional[str] = None
    role: Optional[str] = None
    overall_status: VerificationStatus = VerificationStatus.UNKNOWN

class NetworkVerifier:
    def __init__(self, config_file: str = "config.yaml"):
        self.nr = InitNornir(config_file=config_file)
        self.max_hops = 15
        
    def get_lldp_neighbors(self, task: Task) -> List[Dict]:
        """Collect LLDP neighbor information in a vendor-neutral way"""
        platform = task.host.platform
        
        # Enhanced command mapping for different platforms
        command_map = {
            "aruba_cx": "show lldp neighbors detail",
            "cisco_ios": "show lldp neighbors detail",
            "cisco_xe": "show lldp neighbors detail",
            "hp_comware": "display lldp neighbor-information",
            "juniper": "show lldp neighbors detail"
        }
        
        command = command_map.get(platform, "show lldp neighbors detail")
        
        logger.debug(f"Running on {task.host}: {command}")
        
        try:
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            # Handle different result types
            if isinstance(result.result, str):
                logger.warning(f"TextFSM parsing failed for {task.host}, attempting manual parsing")
                return self._parse_lldp_manually(result.result, platform)
            elif isinstance(result.result, dict):
                return [result.result]
            elif isinstance(result.result, list):
                return result.result
            else:
                logger.warning(f"No LLDP neighbors found on {task.host}")
                return []
                
        except Exception as e:
            logger.error(f"Error getting LLDP neighbors on {task.host}: {str(e)}")
            return []

    def _parse_lldp_manually(self, output: str, platform: str) -> List[Dict]:
        """Manual parsing fallback for when TextFSM fails"""
        neighbors = []
        
        try:
            # Basic regex patterns for common LLDP output formats
            if platform == "cisco_ios":
                # Cisco IOS LLDP format
                pattern = r'Device ID: (\S+).*?Local Intf: (\S+).*?Port id: (\S+)'
                matches = re.findall(pattern, output, re.DOTALL)
                
                for match in matches:
                    neighbors.append({
                        'neighbor': match[0],
                        'local_interface': match[1],
                        'neighbor_port': match[2]
                    })
            
            # Add more platform-specific parsing as needed
            
        except Exception as e:
            logger.error(f"Manual LLDP parsing failed: {str(e)}")
            
        return neighbors

    def find_uplink_port(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find the local interface connected to a neighbor with improved error handling"""
        platform = task.host.platform
        
        try:
            # Try LLDP first (most reliable)
            lldp_result = self._find_port_via_lldp(task, neighbor_ip, platform)
            if lldp_result:
                return lldp_result
            
            # Fall back to CDP for Cisco devices
            if platform.startswith("cisco"):
                cdp_result = self._find_port_via_cdp(task, neighbor_ip)
                if cdp_result:
                    return cdp_result
                    
            # Last resort: MAC address table lookup
            mac_result = self._find_port_via_mac(task, neighbor_ip)
            if mac_result:
                return mac_result
                
        except Exception as e:
            logger.error(f"Error finding uplink port on {task.host}: {str(e)}")
        
        return None

    def _find_port_via_lldp(self, task: Task, neighbor_ip: str, platform: str) -> Optional[str]:
        """Find port using LLDP"""
        try:
            neighbors = self.get_lldp_neighbors(task)
            
            for neighbor in neighbors:
                # Check multiple possible neighbor identifier fields
                neighbor_id = (neighbor.get('neighbor') or 
                             neighbor.get('mgmt_address') or 
                             neighbor.get('system_name'))
                
                if neighbor_id and (neighbor_id == neighbor_ip or 
                                  neighbor_id.startswith(neighbor_ip.split('.')[0])):
                    return neighbor.get('local_interface')
                    
        except Exception as e:
            logger.debug(f"LLDP port lookup failed: {str(e)}")
            
        return None

    def _find_port_via_cdp(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find port using CDP (Cisco devices)"""
        try:
            command = "show cdp neighbors detail"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if result.result:
                for neighbor in (result.result if isinstance(result.result, list) else [result.result]):
                    if neighbor.get('mgmt_address') == neighbor_ip:
                        return neighbor.get('local_port')
                        
        except Exception as e:
            logger.debug(f"CDP port lookup failed: {str(e)}")
            
        return None

    def _find_port_via_mac(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find port using MAC address table (least reliable)"""
        try:
            # This would require ARP table lookup first, then MAC table
            # Implementation depends on specific requirements
            pass
        except Exception as e:
            logger.debug(f"MAC table port lookup failed: {str(e)}")
            
        return None

    def verify_vlan_exists(self, task: Task, vlan_id: str) -> bool:
        """Check if VLAN exists with enhanced platform support"""
        platform = task.host.platform
        
        command_map = {
            "aruba_cx": f"show vlan {vlan_id}",
            "cisco_ios": f"show vlan id {vlan_id}",
            "cisco_xe": f"show vlan id {vlan_id}",
            "hp_comware": f"display vlan {vlan_id}",
            "juniper": f"show vlans {vlan_id}"
        }
        
        command = command_map.get(platform, f"show vlan id {vlan_id}")
        
        try:
            logger.debug(f"Running on {task.host}: {command}")
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if isinstance(result.result, str):
                # Check for common error messages
                error_indicators = ["invalid", "not found", "does not exist", "error"]
                return not any(indicator in result.result.lower() for indicator in error_indicators)
            
            return bool(result.result)
            
        except Exception as e:
            logger.error(f"Error checking VLAN on {task.host}: {str(e)}")
            return False

    def verify_access_vlan(self, task: Task, interface: str, vlan_id: str) -> bool:
        """Verify access port VLAN configuration with better error handling"""
        platform = task.host.platform
        
        try:
            # Method 1: Check VLAN membership
            if self._check_vlan_membership(task, interface, vlan_id, platform):
                return True
            
            # Method 2: Check interface configuration
            if self._check_interface_config(task, interface, vlan_id, platform):
                return True
            
            logger.debug(f"Access VLAN {vlan_id} not found on {interface}")
            return False
            
        except Exception as e:
            logger.error(f"Error checking access port on {task.host}: {str(e)}")
            return False

    def _check_vlan_membership(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check VLAN membership tables"""
        try:
            command_map = {
                "aruba_cx": f"show vlan {vlan_id}",
                "cisco_ios": f"show vlan id {vlan_id}",
                "cisco_xe": f"show vlan id {vlan_id}",
            }
            
            command = command_map.get(platform, f"show vlan id {vlan_id}")
            
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if result.result:
                for vlan in (result.result if isinstance(result.result, list) else [result.result]):
                    interfaces = vlan.get('interfaces', [])
                    if isinstance(interfaces, str):
                        interfaces = [interfaces]
                    
                    # Normalize interface names for comparison
                    normalized_interfaces = [self._normalize_interface_name(intf) for intf in interfaces]
                    normalized_target = self._normalize_interface_name(interface)
                    
                    if normalized_target in normalized_interfaces:
                        return True
                        
        except Exception as e:
            logger.debug(f"VLAN membership check failed: {str(e)}")
            
        return False

    def _check_interface_config(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check interface running configuration"""
        try:
            command = f"show running-config interface {interface}"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=False,
                enable=True
            )
            
            config = result.result.lower()
            
            # Platform-specific config patterns
            patterns = {
                "aruba_cx": [f"vlan access {vlan_id}"],
                "cisco_ios": [f"switchport access vlan {vlan_id}"],
                "cisco_xe": [f"switchport access vlan {vlan_id}"],
            }
            
            check_patterns = patterns.get(platform, [f"switchport access vlan {vlan_id}"])
            
            return any(pattern in config for pattern in check_patterns)
            
        except Exception as e:
            logger.debug(f"Interface config check failed: {str(e)}")
            
        return False

    def _normalize_interface_name(self, interface: str) -> str:
        """Normalize interface names for comparison"""
        # Handle common abbreviations
        interface = interface.replace("GigabitEthernet", "Gi")
        interface = interface.replace("FastEthernet", "Fa")
        interface = interface.replace("TenGigabitEthernet", "Te")
        
        # Remove spaces and convert to lowercase
        return interface.replace(" ", "").lower()

    def verify_trunk_vlan(self, task: Task, interface: str, vlan_id: str) -> bool:
        """Verify trunk allows the VLAN with comprehensive checking"""
        platform = task.host.platform
        
        try:
            # Method 1: Check switchport status
            if self._check_switchport_trunk(task, interface, vlan_id, platform):
                return True
            
            # Method 2: Check running configuration
            if self._check_trunk_config(task, interface, vlan_id, platform):
                return True
            
            return False
            
        except Exception as e:
            logger.error(f"Error checking trunk on {task.host}: {str(e)}")
            return False

    def _check_switchport_trunk(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check switchport trunk status"""
        try:
            command = f"show interfaces {interface} switchport"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if isinstance(result.result, str):
                # Parse raw output
                return self._parse_trunk_raw_output(result.result, vlan_id)
            
            if result.result and isinstance(result.result, list):
                sw_data = result.result[0]
                
                # Check if port is in trunk mode
                if sw_data.get('mode', '').lower() != 'trunk':
                    return False
                
                # Check allowed VLANs
                return self._check_allowed_vlans(sw_data, vlan_id)
                
        except Exception as e:
            logger.debug(f"Switchport trunk check failed: {str(e)}")
            
        return False

    def _parse_trunk_raw_output(self, output: str, vlan_id: str) -> bool:
        """Parse raw switchport output"""
        output_lower = output.lower()
        
        if "trunking" in output_lower:
            if "vlans allowed: all" in output_lower:
                return True
            if f"vlans allowed: {vlan_id}" in output_lower:
                return True
        
        return False

    def _check_allowed_vlans(self, switchport_data: Dict, vlan_id: str) -> bool:
        """Check if VLAN is in allowed VLAN list"""
        for field in ['trunking_vlans', 'vlans_allowed', 'allowed_vlans']:
            vlans = switchport_data.get(field, '')
            
            if vlans:
                if vlans.upper() == 'ALL':
                    return True
                if self._is_vlan_in_list(vlans, vlan_id):
                    return True
        
        return False

    def _check_trunk_config(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check trunk configuration in running config"""
        try:
            command = f"show running-config interface {interface}"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                enable=True
            )
            
            config = result.result.lower()
            
            # If trunk mode is configured but no allowed VLAN restrictions, assume all VLANs allowed
            if "switchport mode trunk" in config and "switchport trunk allowed vlan" not in config:
                return True
            
            # Check specific VLAN allowances
            if f"switchport trunk allowed vlan add {vlan_id}" in config:
                return True
            
            return False
            
        except Exception as e:
            logger.debug(f"Trunk config check failed: {str(e)}")
            
        return False

    def _is_vlan_in_list(self, vlan_str: str, target_vlan: str) -> bool:
        """Helper to safely parse VLAN lists (1,5,10-20,30)"""
        try:
            if not vlan_str:
                return False
                
            target_int = int(target_vlan)
            
            for part in str(vlan_str).split(','):
                part = part.strip()
                
                if '-' in part:
                    # Handle range (e.g., "10-20")
                    start, end = map(int, part.split('-'))
                    if start <= target_int <= end:
                        return True
                elif part.isdigit() and int(part) == target_int:
                    return True
                    
            return False
            
        except (ValueError, AttributeError) as e:
            logger.error(f"VLAN list parsing failed: {str(e)}")
            return False

    def trace_path_to_router(self, start_device: str) -> List[str]:
        """Trace path from edge switch to router using LLDP with improved logic"""
        logger.info("Starting path trace to router...")
        
        path = []
        current_device = start_device
        visited: Set[str] = set()
        
        # Get target router
        try:
            target_router = self.nr.inventory.hosts[start_device].data.get('router')
            if not target_router:
                logger.error(f"No router defined for {start_device}")
                return []
        except KeyError:
            logger.error(f"Device {start_device} not found in inventory")
            return []

        logger.info(f"Target router: {target_router}")

        while current_device and current_device not in visited and len(path) < self.max_hops:
            visited.add(current_device)
            path.append(current_device)
            
            logger.debug(f"Current device: {current_device}")
            logger.debug(f"Current path: {' -> '.join(path)}")
            
            # Check if we've reached the target router
            if current_device == target_router:
                logger.info(f"Reached target router: {current_device}")
                break
            
            # Get neighbors and find next hop
            next_hop = self._find_next_hop(current_device, target_router, visited)
            if not next_hop:
                logger.warning(f"No valid next hop found from {current_device}")
                break
                
            current_device = next_hop

        # Ensure router is in path
        if path and path[-1] != target_router:
            path.append(target_router)
            logger.debug(f"Added router {target_router} to path")

        logger.info(f"Final path: {' -> '.join(path)}")
        return path

    def _find_next_hop(self, current_device: str, target_router: str, visited: Set[str]) -> Optional[str]:
        """Find the next hop in the path"""
        try:
            neighbors_result = self.nr.filter(name=current_device).run(task=self.get_lldp_neighbors)
            neighbors = neighbors_result[current_device].result
            
            if not neighbors:
                logger.debug(f"No neighbors found for {current_device}")
                return None
            
            # Find unvisited neighbors
            possible_hops = []
            for neighbor in (neighbors if isinstance(neighbors, list) else [neighbors]):
                if isinstance(neighbor, dict):
                    neighbor_ip = self._extract_neighbor_ip(neighbor)
                    
                    if neighbor_ip and neighbor_ip not in visited:
                        # Try to resolve to inventory hostname
                        resolved_ip = self._resolve_neighbor_ip(neighbor_ip)
                        if resolved_ip:
                            possible_hops.append(resolved_ip)
            
            if not possible_hops:
                return None
            
            # Prioritize direct connection to router
            if target_router in possible_hops:
                return target_router
            
            # Prioritize devices that have the target router configured
            for hop in possible_hops:
                try:
                    if self.nr.inventory.hosts[hop].data.get('router') == target_router:
                        return hop
                except KeyError:
                    continue
            
            # Return first available hop
            return possible_hops[0]
            
        except Exception as e:
            logger.error(f"Error finding next hop from {current_device}: {str(e)}")
            return None

    def _extract_neighbor_ip(self, neighbor: Dict) -> Optional[str]:
        """Extract neighbor IP from LLDP data"""
        neighbor_ip = (neighbor.get('mgmt_address') or 
                      neighbor.get('neighbor') or 
                      neighbor.get('neighbor_name') or
                      neighbor.get('system_name'))
        
        if neighbor_ip and '.' not in neighbor_ip:
            # Handle hostname format
            neighbor_ip = neighbor_ip.split('.')[0]
        
        return neighbor_ip

    def _resolve_neighbor_ip(self, neighbor_ip: str) -> Optional[str]:
        """Resolve neighbor IP to inventory hostname"""
        # Direct match
        if neighbor_ip in self.nr.inventory.hosts:
            return neighbor_ip
        
        # Hostname match
        for hostname, host in self.nr.inventory.hosts.items():
            if (host.get('hostname', '') == neighbor_ip or 
                hostname.startswith(neighbor_ip)):
                return hostname
        
        return None

    def verify_vlan_path(self, initial_switch: str, target_port: str, vlan_id: str) -> Tuple[bool, str, List[str], Dict[str, DeviceResult]]:
        """Comprehensive VLAN path verification"""
        logger.info("Starting VLAN path verification")
        
        # Trace path
        path = self.trace_path_to_router(initial_switch)
        if not path:
            return False, "No path found to router", [], {}

        # Verify each device in path
        results = {}
        overall_success = True
        failure_reasons = []
        
        for i, device_ip in enumerate(path):
            logger.info(f"Verifying device {i+1}/{len(path)}: {device_ip}")
            
            result = DeviceResult(device_ip=device_ip, vlan_status="Unknown")
            
            # Check VLAN exists
            vlan_exists = self.nr.filter(name=device_ip).run(
                task=self.verify_vlan_exists,
                vlan_id=vlan_id
            )[device_ip].result
            
            if vlan_exists:
                result.vlan_status = "VLAN exists"
                logger.debug(f"VLAN {vlan_id} exists on {device_ip}")
            else:
                result.vlan_status = "VLAN missing"
                result.overall_status = VerificationStatus.FAIL
                overall_success = False
                failure_reasons.append(f"VLAN {vlan_id} missing on {device_ip}")
                logger.warning(f"VLAN {vlan_id} missing on {device_ip}")
            
            # First device: check access port
            if i == 0:
                access_ok = self.nr.filter(name=device_ip).run(
                    task=self.verify_access_vlan,
                    interface=target_port,
                    vlan_id=vlan_id
                )[device_ip].result
                
                if access_ok:
                    result.port_status = "Access port configured"
                    logger.debug(f"Access port {target_port} configured on {device_ip}")
                else:
                    result.port_status = f"Port {target_port} not in VLAN {vlan_id}"
                    result.overall_status = VerificationStatus.FAIL
                    overall_success = False
                    failure_reasons.append(f"Port {target_port} not in VLAN {vlan_id}")
                    logger.warning(f"Port {target_port} not in VLAN {vlan_id}")
            
            # Intermediate devices: check trunk ports
            elif i < len(path) - 1:
                next_device = path[i + 1]
                uplink_port = self.nr.filter(name=device_ip).run(
                    task=self.find_uplink_port,
                    neighbor_ip=next_device
                )[device_ip].result
                
                if uplink_port:
                    trunk_ok = self.nr.filter(name=device_ip).run(
                        task=self.verify_trunk_vlan,
                        interface=uplink_port,
                        vlan_id=vlan_id
                    )[device_ip].result
                    
                    if trunk_ok:
                        result.trunk_status = f"Trunk {uplink_port} allows VLAN"
                        logger.debug(f"Trunk {uplink_port} allows VLAN {vlan_id}")
                    else:
                        result.trunk_status = f"VLAN {vlan_id} blocked on {uplink_port}"
                        result.overall_status = VerificationStatus.FAIL
                        overall_success = False
                        failure_reasons.append(f"VLAN {vlan_id} blocked on {uplink_port}")
                        logger.warning(f"VLAN {vlan_id} blocked on {uplink_port}")
                else:
                    result.trunk_status = f"No uplink found to {next_device}"
                    result.overall_status = VerificationStatus.FAIL
                    overall_success = False
                    failure_reasons.append(f"No uplink found to {next_device}")
                    logger.warning(f"No uplink found to {next_device}")
            
            # Router endpoint
            else:
                result.role = "Router endpoint"
                logger.debug(f"Router endpoint: {device_ip}")
            
            # Set overall status if not already failed
            if result.overall_status == VerificationStatus.UNKNOWN:
                result.overall_status = VerificationStatus.PASS
            
            results[device_ip] = result

        # Generate summary message
        if overall_success:
            message = f"VLAN {vlan_id} path fully verified"
        else:
            message = f"VLAN path verification failed: {'; '.join(failure_reasons[:3])}"
        
        logger.info(f"Verification complete: {message}")
        return overall_success, message, path, results

    def visualize_path(self, path: List[str], verification_results: Dict[str, DeviceResult]):
        """Create enhanced visualization of the network path"""
        plt.ioff()
        fig, ax = plt.subplots(figsize=(18, 12))
        
        # Create graph
        G = nx.path_graph(path)
        
        # Position nodes
        pos = {node: (i * 3, 0) for i, node in enumerate(G.nodes())}
        
        # Prepare node colors and labels
        node_colors = []
        node_labels = {}
        status_labels = {}
        
        for node in G.nodes():
            result = verification_results.get(node)
            if not result:
                node_colors.append("gray")
                status_labels[node] = "No data"
                continue
            
            # Determine color based on status
            if result.overall_status == VerificationStatus.PASS:
                node_colors.append("lightgreen")
                status = "✓ PASS"
            elif result.overall_status == VerificationStatus.FAIL:
                node_colors.append("red")
                status = "✗ FAIL"
            else:
                node_colors.append("gray")
                status = "? UNKNOWN"
            
            # Create node label
            node_labels[node] = node
            
            # Create status label
            status_lines = [f"Status: {status}"]
            
            if result.vlan_status:
                status_lines.append(f"VLAN: {result.vlan_status}")
            
            if result.port_status:
                status_lines.append(f"Port: {result.port_status}")
            
            if result.trunk_status:
                status_lines.append(f"Trunk: {result.trunk_status}")
            
            if result.role:
                status_lines.append(f"Role: {result.role}")
            
            status_labels[node] = "\n".join(status_lines[:4])  # Limit to 4 lines
        
        # Draw network graph
        nx.draw_networkx_nodes(G, pos, node_color=node_colors, node_size=5000, 
                              edgecolors='black', linewidths=2)
        nx.draw_networkx_edges(G, pos, width=3, edge_color='steelblue', 
                              arrows=True, arrowstyle='-|>', arrowsize=30)
        
        # Add device labels (above nodes)
        name_pos = {k: (v[0], v[1] + 0.8) for k, v in pos.items()}
        nx.draw_networkx_labels(G, name_pos, labels=node_labels, font_size=10, 
                               font_weight="bold")
        
        # Add status labels (below nodes)
        status_pos = {k: (v[0], v[1] - 1.2) for k, v in pos.items()}
        nx.draw_networkx_labels(G, status_pos, labels=status_labels, font_size=8,
                               bbox=dict(facecolor='white', edgecolor='black',
                                       boxstyle='round,pad=0.5', alpha=0.9))
        
        # Add legend
        legend_elements = [
            plt.Line2D([0], [0], marker='o', color='w', label='Pass', 
                      markerfacecolor='lightgreen', markersize=15),
            plt.Line2D([0], [0], marker='o', color='w', label='Fail', 
                      markerfacecolor='red', markersize=15),
            plt.Line2D([0], [0], marker='o', color='w', label='Unknown', 
                      markerfacecolor='gray', markersize=15)
        ]
        
        plt.legend(handles=legend_elements, loc='upper right', fontsize=12, 
                  title="Verification Status", title_fontsize=14)
        
        plt.title("Network VLAN Path Verification Results", pad=40, fontsize=18, 
                 fontweight='bold')
        plt.axis('off')
        plt.tight_layout()
        plt.show(block=True)
        plt.ion()


def main():
    """Main function to run VLAN path verification"""
    # Configuration
    initial_switch = "172.17.57.243"
    target_port = "GigabitEthernet1/0/10"
    vlan_id = "5"
    
    # Create verifier instance
    verifier = NetworkVerifier(config_file="config.yaml")
    
    try:
        # Run verification
        success, message, path, results = verifier.verify_vlan_path(
            initial_switch, target_port, vlan_id
        )
        
        # Print results
        print("\n" + "="*60)
        print(f"VLAN PATH VERIFICATION {'SUCCEEDED' if success else 'FAILED'}")
        print("="*60)
        print(f"Initial Switch: {initial_switch}")
        print(f"Target Port: {target_port}")
        print(f"VLAN ID: {vlan_id}")
        print(f"Path: {' → '.join(path)}")
        print(f"Status: {message}")
        print("="*60)
        
        # Detailed results
        print("\nDETAILED RESULTS:")
        print("-" * 40)
        for device_ip, result in results.items():
            print(f"\nDevice: {device_ip}")
            print(f"  Overall Status: {result.overall_status.value.upper()}")
            print(f"  VLAN Status: {result.vlan_status}")
            if result.port_status:
                print(f"  Port Status: {result.port_status}")
            if result.trunk_status:
                print(f"  Trunk Status: {result.trunk_status}")
            if result.role:
                print(f"  Role: {result.role}")
        
        # Show visualization
        if path and results:
            print("\nGenerating network visualization...")
            verifier.visualize_path(path, results)
        
        return success
        
    except Exception as e:
        logger.error(f"Verification failed with error: {str(e)}")
        print(f"\nERROR: Verification failed - {str(e)}")
        return False
    
    finally:
        # Cleanup
        if hasattr(verifier, 'nr') and verifier.nr:
            verifier.nr.close_connections()


if __name__ == "__main__":
    import sys
    
    # Allow command line arguments
    if len(sys.argv) >= 4:
        initial_switch = sys.argv[1]
        target_port = sys.argv[2]
        vlan_id = sys.argv[3]
        
        verifier = NetworkVerifier()
        success, message, path, results = verifier.verify_vlan_path(
            initial_switch, target_port, vlan_id
        )
        
        if success:
            print(f"✓ VLAN {vlan_id} path verification successful")
            sys.exit(0)
        else:
            print(f"✗ VLAN {vlan_id} path verification failed: {message}")
            sys.exit(1)
    else:
        # Use default configuration
        success = main()
        sys.exit(0 if success else 1)
from nornir import InitNornir
from nornir_netmiko import netmiko_send_command
from nornir.core.task import Task, Result
from typing import Dict, List, Tuple, Optional, Set
import networkx as nx
import matplotlib.pyplot as plt
import re
import logging
from dataclasses import dataclass
from enum import Enum

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class VerificationStatus(Enum):
    PASS = "pass"
    FAIL = "fail"
    UNKNOWN = "unknown"

@dataclass
class DeviceResult:
    device_ip: str
    vlan_status: str
    port_status: Optional[str] = None
    trunk_status: Optional[str] = None
    role: Optional[str] = None
    overall_status: VerificationStatus = VerificationStatus.UNKNOWN

class NetworkVerifier:
    def __init__(self, config_file: str = "config.yaml"):
        self.nr = InitNornir(config_file=config_file)
        self.max_hops = 15
        
    def get_lldp_neighbors(self, task: Task) -> List[Dict]:
        """Collect LLDP neighbor information in a vendor-neutral way"""
        platform = task.host.platform
        
        # Enhanced command mapping for different platforms
        command_map = {
            "aruba_cx": "show lldp neighbors detail",
            "cisco_ios": "show lldp neighbors detail",
            "cisco_xe": "show lldp neighbors detail",
            "hp_comware": "display lldp neighbor-information",
            "juniper": "show lldp neighbors detail"
        }
        
        command = command_map.get(platform, "show lldp neighbors detail")
        
        logger.debug(f"Running on {task.host}: {command}")
        
        try:
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            # Handle different result types
            if isinstance(result.result, str):
                logger.warning(f"TextFSM parsing failed for {task.host}, attempting manual parsing")
                return self._parse_lldp_manually(result.result, platform)
            elif isinstance(result.result, dict):
                return [result.result]
            elif isinstance(result.result, list):
                return result.result
            else:
                logger.warning(f"No LLDP neighbors found on {task.host}")
                return []
                
        except Exception as e:
            logger.error(f"Error getting LLDP neighbors on {task.host}: {str(e)}")
            return []

    def _parse_lldp_manually(self, output: str, platform: str) -> List[Dict]:
        """Manual parsing fallback for when TextFSM fails"""
        neighbors = []
        
        try:
            # Basic regex patterns for common LLDP output formats
            if platform == "cisco_ios":
                # Cisco IOS LLDP format
                pattern = r'Device ID: (\S+).*?Local Intf: (\S+).*?Port id: (\S+)'
                matches = re.findall(pattern, output, re.DOTALL)
                
                for match in matches:
                    neighbors.append({
                        'neighbor': match[0],
                        'local_interface': match[1],
                        'neighbor_port': match[2]
                    })
            
            # Add more platform-specific parsing as needed
            
        except Exception as e:
            logger.error(f"Manual LLDP parsing failed: {str(e)}")
            
        return neighbors

    def find_uplink_port(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find the local interface connected to a neighbor with improved error handling"""
        platform = task.host.platform
        
        try:
            # Try LLDP first (most reliable)
            lldp_result = self._find_port_via_lldp(task, neighbor_ip, platform)
            if lldp_result:
                return lldp_result
            
            # Fall back to CDP for Cisco devices
            if platform.startswith("cisco"):
                cdp_result = self._find_port_via_cdp(task, neighbor_ip)
                if cdp_result:
                    return cdp_result
                    
            # Last resort: MAC address table lookup
            mac_result = self._find_port_via_mac(task, neighbor_ip)
            if mac_result:
                return mac_result
                
        except Exception as e:
            logger.error(f"Error finding uplink port on {task.host}: {str(e)}")
        
        return None

    def _find_port_via_lldp(self, task: Task, neighbor_ip: str, platform: str) -> Optional[str]:
        """Find port using LLDP"""
        try:
            neighbors = self.get_lldp_neighbors(task)
            
            for neighbor in neighbors:
                # Check multiple possible neighbor identifier fields
                neighbor_id = (neighbor.get('neighbor') or 
                             neighbor.get('mgmt_address') or 
                             neighbor.get('system_name'))
                
                if neighbor_id and (neighbor_id == neighbor_ip or 
                                  neighbor_id.startswith(neighbor_ip.split('.')[0])):
                    return neighbor.get('local_interface')
                    
        except Exception as e:
            logger.debug(f"LLDP port lookup failed: {str(e)}")
            
        return None

    def _find_port_via_cdp(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find port using CDP (Cisco devices)"""
        try:
            command = "show cdp neighbors detail"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if result.result:
                for neighbor in (result.result if isinstance(result.result, list) else [result.result]):
                    if neighbor.get('mgmt_address') == neighbor_ip:
                        return neighbor.get('local_port')
                        
        except Exception as e:
            logger.debug(f"CDP port lookup failed: {str(e)}")
            
        return None

    def _find_port_via_mac(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find port using MAC address table (least reliable)"""
        try:
            # This would require ARP table lookup first, then MAC table
            # Implementation depends on specific requirements
            pass
        except Exception as e:
            logger.debug(f"MAC table port lookup failed: {str(e)}")
            
        return None

    def verify_vlan_exists(self, task: Task, vlan_id: str) -> bool:
        """Check if VLAN exists with enhanced platform support"""
        platform = task.host.platform
        
        command_map = {
            "aruba_cx": f"show vlan {vlan_id}",
            "cisco_ios": f"show vlan id {vlan_id}",
            "cisco_xe": f"show vlan id {vlan_id}",
            "hp_comware": f"display vlan {vlan_id}",
            "juniper": f"show vlans {vlan_id}"
        }
        
        command = command_map.get(platform, f"show vlan id {vlan_id}")
        
        try:
            logger.debug(f"Running on {task.host}: {command}")
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if isinstance(result.result, str):
                # Check for common error messages
                error_indicators = ["invalid", "not found", "does not exist", "error"]
                return not any(indicator in result.result.lower() for indicator in error_indicators)
            
            return bool(result.result)
            
        except Exception as e:
            logger.error(f"Error checking VLAN on {task.host}: {str(e)}")
            return False

    def verify_access_vlan(self, task: Task, interface: str, vlan_id: str) -> bool:
        """Verify access port VLAN configuration with better error handling"""
        platform = task.host.platform
        
        try:
            # Method 1: Check VLAN membership
            if self._check_vlan_membership(task, interface, vlan_id, platform):
                return True
            
            # Method 2: Check interface configuration
            if self._check_interface_config(task, interface, vlan_id, platform):
                return True
            
            logger.debug(f"Access VLAN {vlan_id} not found on {interface}")
            return False
            
        except Exception as e:
            logger.error(f"Error checking access port on {task.host}: {str(e)}")
            return False

    def _check_vlan_membership(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check VLAN membership tables"""
        try:
            command_map = {
                "aruba_cx": f"show vlan {vlan_id}",
                "cisco_ios": f"show vlan id {vlan_id}",
                "cisco_xe": f"show vlan id {vlan_id}",
            }
            
            command = command_map.get(platform, f"show vlan id {vlan_id}")
            
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if result.result:
                for vlan in (result.result if isinstance(result.result, list) else [result.result]):
                    interfaces = vlan.get('interfaces', [])
                    if isinstance(interfaces, str):
                        interfaces = [interfaces]
                    
                    # Normalize interface names for comparison
                    normalized_interfaces = [self._normalize_interface_name(intf) for intf in interfaces]
                    normalized_target = self._normalize_interface_name(interface)
                    
                    if normalized_target in normalized_interfaces:
                        return True
                        
        except Exception as e:
            logger.debug(f"VLAN membership check failed: {str(e)}")
            
        return False

    def _check_interface_config(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check interface running configuration"""
        try:
            command = f"show running-config interface {interface}"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=False,
                enable=True
            )
            
            config = result.result.lower()
            
            # Platform-specific config patterns
            patterns = {
                "aruba_cx": [f"vlan access {vlan_id}"],
                "cisco_ios": [f"switchport access vlan {vlan_id}"],
                "cisco_xe": [f"switchport access vlan {vlan_id}"],
            }
            
            check_patterns = patterns.get(platform, [f"switchport access vlan {vlan_id}"])
            
            return any(pattern in config for pattern in check_patterns)
            
        except Exception as e:
            logger.debug(f"Interface config check failed: {str(e)}")
            
        return False

    def _normalize_interface_name(self, interface: str) -> str:
        """Normalize interface names for comparison"""
        # Handle common abbreviations
        interface = interface.replace("GigabitEthernet", "Gi")
        interface = interface.replace("FastEthernet", "Fa")
        interface = interface.replace("TenGigabitEthernet", "Te")
        
        # Remove spaces and convert to lowercase
        return interface.replace(" ", "").lower()

    def verify_trunk_vlan(self, task: Task, interface: str, vlan_id: str) -> bool:
        """Verify trunk allows the VLAN with comprehensive checking"""
        platform = task.host.platform
        
        try:
            # Method 1: Check switchport status
            if self._check_switchport_trunk(task, interface, vlan_id, platform):
                return True
            
            # Method 2: Check running configuration
            if self._check_trunk_config(task, interface, vlan_id, platform):
                return True
            
            return False
            
        except Exception as e:
            logger.error(f"Error checking trunk on {task.host}: {str(e)}")
            return False

    def _check_switchport_trunk(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check switchport trunk status"""
        try:
            command = f"show interfaces {interface} switchport"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if isinstance(result.result, str):
                # Parse raw output
                return self._parse_trunk_raw_output(result.result, vlan_id)
            
            if result.result and isinstance(result.result, list):
                sw_data = result.result[0]
                
                # Check if port is in trunk mode
                if sw_data.get('mode', '').lower() != 'trunk':
                    return False
                
                # Check allowed VLANs
                return self._check_allowed_vlans(sw_data, vlan_id)
                
        except Exception as e:
            logger.debug(f"Switchport trunk check failed: {str(e)}")
            
        return False

    def _parse_trunk_raw_output(self, output: str, vlan_id: str) -> bool:
        """Parse raw switchport output"""
        output_lower = output.lower()
        
        if "trunking" in output_lower:
            if "vlans allowed: all" in output_lower:
                return True
            if f"vlans allowed: {vlan_id}" in output_lower:
                return True
        
        return False

    def _check_allowed_vlans(self, switchport_data: Dict, vlan_id: str) -> bool:
        """Check if VLAN is in allowed VLAN list"""
        for field in ['trunking_vlans', 'vlans_allowed', 'allowed_vlans']:
            vlans = switchport_data.get(field, '')
            
            if vlans:
                if vlans.upper() == 'ALL':
                    return True
                if self._is_vlan_in_list(vlans, vlan_id):
                    return True
        
        return False

    def _check_trunk_config(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check trunk configuration in running config"""
        try:
            command = f"show running-config interface {interface}"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                enable=True
            )
            
            config = result.result.lower()
            
            # If trunk mode is configured but no allowed VLAN restrictions, assume all VLANs allowed
            if "switchport mode trunk" in config and "switchport trunk allowed vlan" not in config:
                return True
            
            # Check specific VLAN allowances
            if f"switchport trunk allowed vlan add {vlan_id}" in config:
                return True
            
            return False
            
        except Exception as e:
            logger.debug(f"Trunk config check failed: {str(e)}")
            
        return False

    def _is_vlan_in_list(self, vlan_str: str, target_vlan: str) -> bool:
        """Helper to safely parse VLAN lists (1,5,10-20,30)"""
        try:
            if not vlan_str:
                return False
                
            target_int = int(target_vlan)
            
            for part in str(vlan_str).split(','):
                part = part.strip()
                
                if '-' in part:
                    # Handle range (e.g., "10-20")
                    start, end = map(int, part.split('-'))
                    if start <= target_int <= end:
                        return True
                elif part.isdigit() and int(part) == target_int:
                    return True
                    
            return False
            
        except (ValueError, AttributeError) as e:
            logger.error(f"VLAN list parsing failed: {str(e)}")
            return False

    def trace_path_to_router(self, start_device: str) -> List[str]:
        """Trace path from edge switch to router using LLDP with improved logic"""
        logger.info("Starting path trace to router...")
        
        path = []
        current_device = start_device
        visited: Set[str] = set()
        
        # Get target router
        try:
            target_router = self.nr.inventory.hosts[start_device].data.get('router')
            if not target_router:
                logger.error(f"No router defined for {start_device}")
                return []
        except KeyError:
            logger.error(f"Device {start_device} not found in inventory")
            return []

        logger.info(f"Target router: {target_router}")

        while current_device and current_device not in visited and len(path) < self.max_hops:
            visited.add(current_device)
            path.append(current_device)
            
            logger.debug(f"Current device: {current_device}")
            logger.debug(f"Current path: {' -> '.join(path)}")
            
            # Check if we've reached the target router
            if current_device == target_router:
                logger.info(f"Reached target router: {current_device}")
                break
            
            # Get neighbors and find next hop
            next_hop = self._find_next_hop(current_device, target_router, visited)
            if not next_hop:
                logger.warning(f"No valid next hop found from {current_device}")
                break
                
            current_device = next_hop

        # Ensure router is in path
        if path and path[-1] != target_router:
            path.append(target_router)
            logger.debug(f"Added router {target_router} to path")

        logger.info(f"Final path: {' -> '.join(path)}")
        return path

    def _find_next_hop(self, current_device: str, target_router: str, visited: Set[str]) -> Optional[str]:
        """Find the next hop in the path"""
        try:
            neighbors_result = self.nr.filter(name=current_device).run(task=self.get_lldp_neighbors)
            neighbors = neighbors_result[current_device].result
            
            if not neighbors:
                logger.debug(f"No neighbors found for {current_device}")
                return None
            
            # Find unvisited neighbors
            possible_hops = []
            for neighbor in (neighbors if isinstance(neighbors, list) else [neighbors]):
                if isinstance(neighbor, dict):
                    neighbor_ip = self._extract_neighbor_ip(neighbor)
                    
                    if neighbor_ip and neighbor_ip not in visited:
                        # Try to resolve to inventory hostname
                        resolved_ip = self._resolve_neighbor_ip(neighbor_ip)
                        if resolved_ip:
                            possible_hops.append(resolved_ip)
            
            if not possible_hops:
                return None
            
            # Prioritize direct connection to router
            if target_router in possible_hops:
                return target_router
            
            # Prioritize devices that have the target router configured
            for hop in possible_hops:
                try:
                    if self.nr.inventory.hosts[hop].data.get('router') == target_router:
                        return hop
                except KeyError:
                    continue
            
            # Return first available hop
            return possible_hops[0]
            
        except Exception as e:
            logger.error(f"Error finding next hop from {current_device}: {str(e)}")
            return None

    def _extract_neighbor_ip(self, neighbor: Dict) -> Optional[str]:
        """Extract neighbor IP from LLDP data"""
        neighbor_ip = (neighbor.get('mgmt_address') or 
                      neighbor.get('neighbor') or 
                      neighbor.get('neighbor_name') or
                      neighbor.get('system_name'))
        
        if neighbor_ip and '.' not in neighbor_ip:
            # Handle hostname format
            neighbor_ip = neighbor_ip.split('.')[0]
        
        return neighbor_ip

    def _resolve_neighbor_ip(self, neighbor_ip: str) -> Optional[str]:
        """Resolve neighbor IP to inventory hostname"""
        # Direct match
        if neighbor_ip in self.nr.inventory.hosts:
            return neighbor_ip
        
        # Hostname match
        for hostname, host in self.nr.inventory.hosts.items():
            if (host.get('hostname', '') == neighbor_ip or 
                hostname.startswith(neighbor_ip)):
                return hostname
        
        return None

    def verify_vlan_path(self, initial_switch: str, target_port: str, vlan_id: str) -> Tuple[bool, str, List[str], Dict[str, DeviceResult]]:
        """Comprehensive VLAN path verification"""
        logger.info("Starting VLAN path verification")
        
        # Trace path
        path = self.trace_path_to_router(initial_switch)
        if not path:
            return False, "No path found to router", [], {}

        # Verify each device in path
        results = {}
        overall_success = True
        failure_reasons = []
        
        for i, device_ip in enumerate(path):
            logger.info(f"Verifying device {i+1}/{len(path)}: {device_ip}")
            
            result = DeviceResult(device_ip=device_ip, vlan_status="Unknown")
            
            # Check VLAN exists
            vlan_exists = self.nr.filter(name=device_ip).run(
                task=self.verify_vlan_exists,
                vlan_id=vlan_id
            )[device_ip].result
            
            if vlan_exists:
                result.vlan_status = "VLAN exists"
                logger.debug(f"VLAN {vlan_id} exists on {device_ip}")
            else:
                result.vlan_status = "VLAN missing"
                result.overall_status = VerificationStatus.FAIL
                overall_success = False
                failure_reasons.append(f"VLAN {vlan_id} missing on {device_ip}")
                logger.warning(f"VLAN {vlan_id} missing on {device_ip}")
            
            # First device: check access port
            if i == 0:
                access_ok = self.nr.filter(name=device_ip).run(
                    task=self.verify_access_vlan,
                    interface=target_port,
                    vlan_id=vlan_id
                )[device_ip].result
                
                if access_ok:
                    result.port_status = "Access port configured"
                    logger.debug(f"Access port {target_port} configured on {device_ip}")
                else:
                    result.port_status = f"Port {target_port} not in VLAN {vlan_id}"
                    result.overall_status = VerificationStatus.FAIL
                    overall_success = False
                    failure_reasons.append(f"Port {target_port} not in VLAN {vlan_id}")
                    logger.warning(f"Port {target_port} not in VLAN {vlan_id}")
            
            # Intermediate devices: check trunk ports
            elif i < len(path) - 1:
                next_device = path[i + 1]
                uplink_port = self.nr.filter(name=device_ip).run(
                    task=self.find_uplink_port,
                    neighbor_ip=next_device
                )[device_ip].result
                
                if uplink_port:
                    trunk_ok = self.nr.filter(name=device_ip).run(
                        task=self.verify_trunk_vlan,
                        interface=uplink_port,
                        vlan_id=vlan_id
                    )[device_ip].result
                    
                    if trunk_ok:
                        result.trunk_status = f"Trunk {uplink_port} allows VLAN"
                        logger.debug(f"Trunk {uplink_port} allows VLAN {vlan_id}")
                    else:
                        result.trunk_status = f"VLAN {vlan_id} blocked on {uplink_port}"
                        result.overall_status = VerificationStatus.FAIL
                        overall_success = False
                        failure_reasons.append(f"VLAN {vlan_id} blocked on {uplink_port}")
                        logger.warning(f"VLAN {vlan_id} blocked on {uplink_port}")
                else:
                    result.trunk_status = f"No uplink found to {next_device}"
                    result.overall_status = VerificationStatus.FAIL
                    overall_success = False
                    failure_reasons.append(f"No uplink found to {next_device}")
                    logger.warning(f"No uplink found to {next_device}")
            
            # Router endpoint
            else:
                result.role = "Router endpoint"
                logger.debug(f"Router endpoint: {device_ip}")
            
            # Set overall status if not already failed
            if result.overall_status == VerificationStatus.UNKNOWN:
                result.overall_status = VerificationStatus.PASS
            
            results[device_ip] = result

        # Generate summary message
        if overall_success:
            message = f"VLAN {vlan_id} path fully verified"
        else:
            message = f"VLAN path verification failed: {'; '.join(failure_reasons[:3])}"
        
        logger.info(f"Verification complete: {message}")
        return overall_success, message, path, results

    def visualize_path(self, path: List[str], verification_results: Dict[str, DeviceResult]):
        """Create enhanced visualization of the network path"""
        plt.ioff()
        fig, ax = plt.subplots(figsize=(18, 12))
        
        # Create graph
        G = nx.path_graph(path)
        
        # Position nodes
        pos = {node: (i * 3, 0) for i, node in enumerate(G.nodes())}
        
        # Prepare node colors and labels
        node_colors = []
        node_labels = {}
        status_labels = {}
        
        for node in G.nodes():
            result = verification_results.get(node)
            if not result:
                node_colors.append("gray")
                status_labels[node] = "No data"
                continue
            
            # Determine color based on status
            if result.overall_status == VerificationStatus.PASS:
                node_colors.append("lightgreen")
                status = "✓ PASS"
            elif result.overall_status == VerificationStatus.FAIL:
                node_colors.append("red")
                status = "✗ FAIL"
            else:
                node_colors.append("gray")
                status = "? UNKNOWN"
            
            # Create node label
            node_labels[node] = node
            
            # Create status label
            status_lines = [f"Status: {status}"]
            
            if result.vlan_status:
                status_lines.append(f"VLAN: {result.vlan_status}")
            
            if result.port_status:
                status_lines.append(f"Port: {result.port_status}")
            
            if result.trunk_status:
                status_lines.append(f"Trunk: {result.trunk_status}")
            
            if result.role:
                status_lines.append(f"Role: {result.role}")
            
            status_labels[node] = "\n".join(status_lines[:4])  # Limit to 4 lines
        
        # Draw network graph
        nx.draw_networkx_nodes(G, pos, node_color=node_colors, node_size=5000, 
                              edgecolors='black', linewidths=2)
        nx.draw_networkx_edges(G, pos, width=3, edge_color='steelblue', 
                              arrows=True, arrowstyle='-|>', arrowsize=30)
        
        # Add device labels (above nodes)
        name_pos = {k: (v[0], v[1] + 0.8) for k, v in pos.items()}
        nx.draw_networkx_labels(G, name_pos, labels=node_labels, font_size=10, 
                               font_weight="bold")
        
        # Add status labels (below nodes)
        status_pos = {k: (v[0], v[1] - 1.2) for k, v in pos.items()}
        nx.draw_networkx_labels(G, status_pos, labels=status_labels, font_size=8,
                               bbox=dict(facecolor='white', edgecolor='black',
                                       boxstyle='round,pad=0.5', alpha=0.9))
        
        # Add legend
        legend_elements = [
            plt.Line2D([0], [0], marker='o', color='w', label='Pass', 
                      markerfacecolor='lightgreen', markersize=15),
            plt.Line2D([0], [0], marker='o', color='w', label='Fail', 
                      markerfacecolor='red', markersize=15),
            plt.Line2D([0], [0], marker='o', color='w', label='Unknown', 
                      markerfacecolor='gray', markersize=15)
        ]
        
        plt.legend(handles=legend_elements, loc='upper right', fontsize=12, 
                  title="Verification Status", title_fontsize=14)
        
        plt.title("Network VLAN Path Verification Results", pad=40, fontsize=18, 
                 fontweight='bold')
        plt.axis('off')
        plt.tight_layout()
        plt.show(block=True)
        plt.ion()


def main():
    """Main function to run VLAN path verification"""
    # Configuration
    initial_switch = "172.17.57.243"
    target_port = "GigabitEthernet1/0/10"
    vlan_id = "5"
    
    # Create verifier instance
    verifier = NetworkVerifier(config_file="config.yaml")
    
    try:
        # Run verification
        success, message, path, results = verifier.verify_vlan_path(
            initial_switch, target_port, vlan_id
        )
        
        # Print results
        print("\n" + "="*60)
        print(f"VLAN PATH VERIFICATION {'SUCCEEDED' if success else 'FAILED'}")
        print("="*60)
        print(f"Initial Switch: {initial_switch}")
        print(f"Target Port: {target_port}")
        print(f"VLAN ID: {vlan_id}")
        print(f"Path: {' → '.join(path)}")
        print(f"Status: {message}")
        print("="*60)
        
        # Detailed results
        print("\nDETAILED RESULTS:")
        print("-" * 40)
        for device_ip, result in results.items():
            print(f"\nDevice: {device_ip}")
            print(f"  Overall Status: {result.overall_status.value.upper()}")
            print(f"  VLAN Status: {result.vlan_status}")
            if result.port_status:
                print(f"  Port Status: {result.port_status}")
            if result.trunk_status:
                print(f"  Trunk Status: {result.trunk_status}")
            if result.role:
                print(f"  Role: {result.role}")
        
        # Show visualization
        if path and results:
            print("\nGenerating network visualization...")
            verifier.visualize_path(path, results)
        
        return success
        
    except Exception as e:
        logger.error(f"Verification failed with error: {str(e)}")
        print(f"\nERROR: Verification failed - {str(e)}")
        return False
    
    finally:
        # Cleanup
        if hasattr(verifier, 'nr') and verifier.nr:
            verifier.nr.close_connections()


if __name__ == "__main__":
    import sys
    
    # Allow command line arguments
    if len(sys.argv) >= 4:
        initial_switch = sys.argv[1]
        target_port = sys.argv[2]
        vlan_id = sys.argv[3]
        
        verifier = NetworkVerifier()
        success, message, path, results = verifier.verify_vlan_path(
            initial_switch, target_port, vlan_id
        )
        
        if success:
            print(f"✓ VLAN {vlan_id} path verification successful")
            sys.exit(0)
        else:
            print(f"✗ VLAN {vlan_id} path verification failed: {message}")
            sys.exit(1)
    else:
        # Use default configuration
        success = main()
        sys.exit(0 if success else 1)get router
from nornir import InitNornir
from nornir_netmiko import netmiko_send_command
from nornir.core.task import Task, Result
from typing import Dict, List, Tuple, Optional, Set
import networkx as nx
import matplotlib.pyplot as plt
import re
import logging
from dataclasses import dataclass
from enum import Enum

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class VerificationStatus(Enum):
    PASS = "pass"
    FAIL = "fail"
    UNKNOWN = "unknown"

@dataclass
class DeviceResult:
    device_ip: str
    vlan_status: str
    port_status: Optional[str] = None
    trunk_status: Optional[str] = None
    role: Optional[str] = None
    overall_status: VerificationStatus = VerificationStatus.UNKNOWN

class NetworkVerifier:
    def __init__(self, config_file: str = "config.yaml"):
        self.nr = InitNornir(config_file=config_file)
        self.max_hops = 15
        
    def get_lldp_neighbors(self, task: Task) -> List[Dict]:
        """Collect LLDP neighbor information in a vendor-neutral way"""
        platform = task.host.platform
        
        # Enhanced command mapping for different platforms
        command_map = {
            "aruba_cx": "show lldp neighbors detail",
            "cisco_ios": "show lldp neighbors detail",
            "cisco_xe": "show lldp neighbors detail",
            "hp_comware": "display lldp neighbor-information",
            "juniper": "show lldp neighbors detail"
        }
        
        command = command_map.get(platform, "show lldp neighbors detail")
        
        logger.debug(f"Running on {task.host}: {command}")
        
        try:
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            # Handle different result types
            if isinstance(result.result, str):
                logger.warning(f"TextFSM parsing failed for {task.host}, attempting manual parsing")
                return self._parse_lldp_manually(result.result, platform)
            elif isinstance(result.result, dict):
                return [result.result]
            elif isinstance(result.result, list):
                return result.result
            else:
                logger.warning(f"No LLDP neighbors found on {task.host}")
                return []
                
        except Exception as e:
            logger.error(f"Error getting LLDP neighbors on {task.host}: {str(e)}")
            return []

    def _parse_lldp_manually(self, output: str, platform: str) -> List[Dict]:
        """Manual parsing fallback for when TextFSM fails"""
        neighbors = []
        
        try:
            # Basic regex patterns for common LLDP output formats
            if platform == "cisco_ios":
                # Cisco IOS LLDP format
                pattern = r'Device ID: (\S+).*?Local Intf: (\S+).*?Port id: (\S+)'
                matches = re.findall(pattern, output, re.DOTALL)
                
                for match in matches:
                    neighbors.append({
                        'neighbor': match[0],
                        'local_interface': match[1],
                        'neighbor_port': match[2]
                    })
            
            # Add more platform-specific parsing as needed
            
        except Exception as e:
            logger.error(f"Manual LLDP parsing failed: {str(e)}")
            
        return neighbors

    def find_uplink_port(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find the local interface connected to a neighbor with improved error handling"""
        platform = task.host.platform
        
        try:
            # Try LLDP first (most reliable)
            lldp_result = self._find_port_via_lldp(task, neighbor_ip, platform)
            if lldp_result:
                return lldp_result
            
            # Fall back to CDP for Cisco devices
            if platform.startswith("cisco"):
                cdp_result = self._find_port_via_cdp(task, neighbor_ip)
                if cdp_result:
                    return cdp_result
                    
            # Last resort: MAC address table lookup
            mac_result = self._find_port_via_mac(task, neighbor_ip)
            if mac_result:
                return mac_result
                
        except Exception as e:
            logger.error(f"Error finding uplink port on {task.host}: {str(e)}")
        
        return None

    def _find_port_via_lldp(self, task: Task, neighbor_ip: str, platform: str) -> Optional[str]:
        """Find port using LLDP"""
        try:
            neighbors = self.get_lldp_neighbors(task)
            
            for neighbor in neighbors:
                # Check multiple possible neighbor identifier fields
                neighbor_id = (neighbor.get('neighbor') or 
                             neighbor.get('mgmt_address') or 
                             neighbor.get('system_name'))
                
                if neighbor_id and (neighbor_id == neighbor_ip or 
                                  neighbor_id.startswith(neighbor_ip.split('.')[0])):
                    return neighbor.get('local_interface')
                    
        except Exception as e:
            logger.debug(f"LLDP port lookup failed: {str(e)}")
            
        return None

    def _find_port_via_cdp(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find port using CDP (Cisco devices)"""
        try:
            command = "show cdp neighbors detail"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if result.result:
                for neighbor in (result.result if isinstance(result.result, list) else [result.result]):
                    if neighbor.get('mgmt_address') == neighbor_ip:
                        return neighbor.get('local_port')
                        
        except Exception as e:
            logger.debug(f"CDP port lookup failed: {str(e)}")
            
        return None

    def _find_port_via_mac(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find port using MAC address table (least reliable)"""
        try:
            # This would require ARP table lookup first, then MAC table
            # Implementation depends on specific requirements
            pass
        except Exception as e:
            logger.debug(f"MAC table port lookup failed: {str(e)}")
            
        return None

    def verify_vlan_exists(self, task: Task, vlan_id: str) -> bool:
        """Check if VLAN exists with enhanced platform support"""
        platform = task.host.platform
        
        command_map = {
            "aruba_cx": f"show vlan {vlan_id}",
            "cisco_ios": f"show vlan id {vlan_id}",
            "cisco_xe": f"show vlan id {vlan_id}",
            "hp_comware": f"display vlan {vlan_id}",
            "juniper": f"show vlans {vlan_id}"
        }
        
        command = command_map.get(platform, f"show vlan id {vlan_id}")
        
        try:
            logger.debug(f"Running on {task.host}: {command}")
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if isinstance(result.result, str):
                # Check for common error messages
                error_indicators = ["invalid", "not found", "does not exist", "error"]
                return not any(indicator in result.result.lower() for indicator in error_indicators)
            
            return bool(result.result)
            
        except Exception as e:
            logger.error(f"Error checking VLAN on {task.host}: {str(e)}")
            return False

    def verify_access_vlan(self, task: Task, interface: str, vlan_id: str) -> bool:
        """Verify access port VLAN configuration with better error handling"""
        platform = task.host.platform
        
        try:
            # Method 1: Check VLAN membership
            if self._check_vlan_membership(task, interface, vlan_id, platform):
                return True
            
            # Method 2: Check interface configuration
            if self._check_interface_config(task, interface, vlan_id, platform):
                return True
            
            logger.debug(f"Access VLAN {vlan_id} not found on {interface}")
            return False
            
        except Exception as e:
            logger.error(f"Error checking access port on {task.host}: {str(e)}")
            return False

    def _check_vlan_membership(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check VLAN membership tables"""
        try:
            command_map = {
                "aruba_cx": f"show vlan {vlan_id}",
                "cisco_ios": f"show vlan id {vlan_id}",
                "cisco_xe": f"show vlan id {vlan_id}",
            }
            
            command = command_map.get(platform, f"show vlan id {vlan_id}")
            
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if result.result:
                for vlan in (result.result if isinstance(result.result, list) else [result.result]):
                    interfaces = vlan.get('interfaces', [])
                    if isinstance(interfaces, str):
                        interfaces = [interfaces]
                    
                    # Normalize interface names for comparison
                    normalized_interfaces = [self._normalize_interface_name(intf) for intf in interfaces]
                    normalized_target = self._normalize_interface_name(interface)
                    
                    if normalized_target in normalized_interfaces:
                        return True
                        
        except Exception as e:
            logger.debug(f"VLAN membership check failed: {str(e)}")
            
        return False

    def _check_interface_config(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check interface running configuration"""
        try:
            command = f"show running-config interface {interface}"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=False,
                enable=True
            )
            
            config = result.result.lower()
            
            # Platform-specific config patterns
            patterns = {
                "aruba_cx": [f"vlan access {vlan_id}"],
                "cisco_ios": [f"switchport access vlan {vlan_id}"],
                "cisco_xe": [f"switchport access vlan {vlan_id}"],
            }
            
            check_patterns = patterns.get(platform, [f"switchport access vlan {vlan_id}"])
            
            return any(pattern in config for pattern in check_patterns)
            
        except Exception as e:
            logger.debug(f"Interface config check failed: {str(e)}")
            
        return False

    def _normalize_interface_name(self, interface: str) -> str:
        """Normalize interface names for comparison"""
        # Handle common abbreviations
        interface = interface.replace("GigabitEthernet", "Gi")
        interface = interface.replace("FastEthernet", "Fa")
        interface = interface.replace("TenGigabitEthernet", "Te")
        
        # Remove spaces and convert to lowercase
        return interface.replace(" ", "").lower()

    def verify_trunk_vlan(self, task: Task, interface: str, vlan_id: str) -> bool:
        """Verify trunk allows the VLAN with comprehensive checking"""
        platform = task.host.platform
        
        try:
            # Method 1: Check switchport status
            if self._check_switchport_trunk(task, interface, vlan_id, platform):
                return True
            
            # Method 2: Check running configuration
            if self._check_trunk_config(task, interface, vlan_id, platform):
                return True
            
            return False
            
        except Exception as e:
            logger.error(f"Error checking trunk on {task.host}: {str(e)}")
            return False

    def _check_switchport_trunk(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check switchport trunk status"""
        try:
            command = f"show interfaces {interface} switchport"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if isinstance(result.result, str):
                # Parse raw output
                return self._parse_trunk_raw_output(result.result, vlan_id)
            
            if result.result and isinstance(result.result, list):
                sw_data = result.result[0]
                
                # Check if port is in trunk mode
                if sw_data.get('mode', '').lower() != 'trunk':
                    return False
                
                # Check allowed VLANs
                return self._check_allowed_vlans(sw_data, vlan_id)
                
        except Exception as e:
            logger.debug(f"Switchport trunk check failed: {str(e)}")
            
        return False

    def _parse_trunk_raw_output(self, output: str, vlan_id: str) -> bool:
        """Parse raw switchport output"""
        output_lower = output.lower()
        
        if "trunking" in output_lower:
            if "vlans allowed: all" in output_lower:
                return True
            if f"vlans allowed: {vlan_id}" in output_lower:
                return True
        
        return False

    def _check_allowed_vlans(self, switchport_data: Dict, vlan_id: str) -> bool:
        """Check if VLAN is in allowed VLAN list"""
        for field in ['trunking_vlans', 'vlans_allowed', 'allowed_vlans']:
            vlans = switchport_data.get(field, '')
            
            if vlans:
                if vlans.upper() == 'ALL':
                    return True
                if self._is_vlan_in_list(vlans, vlan_id):
                    return True
        
        return False

    def _check_trunk_config(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check trunk configuration in running config"""
        try:
            command = f"show running-config interface {interface}"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                enable=True
            )
            
            config = result.result.lower()
            
            # If trunk mode is configured but no allowed VLAN restrictions, assume all VLANs allowed
            if "switchport mode trunk" in config and "switchport trunk allowed vlan" not in config:
                return True
            
            # Check specific VLAN allowances
            if f"switchport trunk allowed vlan add {vlan_id}" in config:
                return True
            
            return False
            
        except Exception as e:
            logger.debug(f"Trunk config check failed: {str(e)}")
            
        return False

    def _is_vlan_in_list(self, vlan_str: str, target_vlan: str) -> bool:
        """Helper to safely parse VLAN lists (1,5,10-20,30)"""
        try:
            if not vlan_str:
                return False
                
            target_int = int(target_vlan)
            
            for part in str(vlan_str).split(','):
                part = part.strip()
                
                if '-' in part:
                    # Handle range (e.g., "10-20")
                    start, end = map(int, part.split('-'))
                    if start <= target_int <= end:
                        return True
                elif part.isdigit() and int(part) == target_int:
                    return True
                    
            return False
            
        except (ValueError, AttributeError) as e:
            logger.error(f"VLAN list parsing failed: {str(e)}")
            return False

    def trace_path_to_router(self, start_device: str) -> List[str]:
        """Trace path from edge switch to router using LLDP with improved logic"""
        logger.info("Starting path trace to router...")
        
        path = []
        current_device = start_device
        visited: Set[str] = set()
        
        # Get target router
        try:
            target_router = self.nr.inventory.hosts[start_device].data.get('router')
            if not target_router:
                logger.error(f"No router defined for {start_device}")
                return []
        except KeyError:
            logger.error(f"Device {start_device} not found in inventory")
            return []

        logger.info(f"Target router: {target_router}")

        while current_device and current_device not in visited and len(path) < self.max_hops:
            visited.add(current_device)
            path.append(current_device)
            
            logger.debug(f"Current device: {current_device}")
            logger.debug(f"Current path: {' -> '.join(path)}")
            
            # Check if we've reached the target router
            if current_device == target_router:
                logger.info(f"Reached target router: {current_device}")
                break
            
            # Get neighbors and find next hop
            next_hop = self._find_next_hop(current_device, target_router, visited)
            if not next_hop:
                logger.warning(f"No valid next hop found from {current_device}")
                break
                
            current_device = next_hop

        # Ensure router is in path
        if path and path[-1] != target_router:
            path.append(target_router)
            logger.debug(f"Added router {target_router} to path")

        logger.info(f"Final path: {' -> '.join(path)}")
        return path

    def _find_next_hop(self, current_device: str, target_router: str, visited: Set[str]) -> Optional[str]:
        """Find the next hop in the path"""
        try:
            neighbors_result = self.nr.filter(name=current_device).run(task=self.get_lldp_neighbors)
            neighbors = neighbors_result[current_device].result
            
            if not neighbors:
                logger.debug(f"No neighbors found for {current_device}")
                return None
            
            # Find unvisited neighbors
            possible_hops = []
            for neighbor in (neighbors if isinstance(neighbors, list) else [neighbors]):
                if isinstance(neighbor, dict):
                    neighbor_ip = self._extract_neighbor_ip(neighbor)
                    
                    if neighbor_ip and neighbor_ip not in visited:
                        # Try to resolve to inventory hostname
                        resolved_ip = self._resolve_neighbor_ip(neighbor_ip)
                        if resolved_ip:
                            possible_hops.append(resolved_ip)
            
            if not possible_hops:
                return None
            
            # Prioritize direct connection to router
            if target_router in possible_hops:
                return target_router
            
            # Prioritize devices that have the target router configured
            for hop in possible_hops:
                try:
                    if self.nr.inventory.hosts[hop].data.get('router') == target_router:
                        return hop
                except KeyError:
                    continue
            
            # Return first available hop
            return possible_hops[0]
            
        except Exception as e:
            logger.error(f"Error finding next hop from {current_device}: {str(e)}")
            return None

    def _extract_neighbor_ip(self, neighbor: Dict) -> Optional[str]:
        """Extract neighbor IP from LLDP data"""
        neighbor_ip = (neighbor.get('mgmt_address') or 
                      neighbor.get('neighbor') or 
                      neighbor.get('neighbor_name') or
                      neighbor.get('system_name'))
        
        if neighbor_ip and '.' not in neighbor_ip:
            # Handle hostname format
            neighbor_ip = neighbor_ip.split('.')[0]
        
        return neighbor_ip

    def _resolve_neighbor_ip(self, neighbor_ip: str) -> Optional[str]:
        """Resolve neighbor IP to inventory hostname"""
        # Direct match
        if neighbor_ip in self.nr.inventory.hosts:
            return neighbor_ip
        
        # Hostname match
        for hostname, host in self.nr.inventory.hosts.items():
            if (host.get('hostname', '') == neighbor_ip or 
                hostname.startswith(neighbor_ip)):
                return hostname
        
        return None

    def verify_vlan_path(self, initial_switch: str, target_port: str, vlan_id: str) -> Tuple[bool, str, List[str], Dict[str, DeviceResult]]:
        """Comprehensive VLAN path verification"""
        logger.info("Starting VLAN path verification")
        
        # Trace path
        path = self.trace_path_to_router(initial_switch)
        if not path:
            return False, "No path found to router", [], {}

        # Verify each device in path
        results = {}
        overall_success = True
        failure_reasons = []
        
        for i, device_ip in enumerate(path):
            logger.info(f"Verifying device {i+1}/{len(path)}: {device_ip}")
            
            result = DeviceResult(device_ip=device_ip, vlan_status="Unknown")
            
            # Check VLAN exists
            vlan_exists = self.nr.filter(name=device_ip).run(
                task=self.verify_vlan_exists,
                vlan_id=vlan_id
            )[device_ip].result
            
            if vlan_exists:
                result.vlan_status = "VLAN exists"
                logger.debug(f"VLAN {vlan_id} exists on {device_ip}")
            else:
                result.vlan_status = "VLAN missing"
                result.overall_status = VerificationStatus.FAIL
                overall_success = False
                failure_reasons.append(f"VLAN {vlan_id} missing on {device_ip}")
                logger.warning(f"VLAN {vlan_id} missing on {device_ip}")
            
            # First device: check access port
            if i == 0:
                access_ok = self.nr.filter(name=device_ip).run(
                    task=self.verify_access_vlan,
                    interface=target_port,
                    vlan_id=vlan_id
                )[device_ip].result
                
                if access_ok:
                    result.port_status = "Access port configured"
                    logger.debug(f"Access port {target_port} configured on {device_ip}")
                else:
                    result.port_status = f"Port {target_port} not in VLAN {vlan_id}"
                    result.overall_status = VerificationStatus.FAIL
                    overall_success = False
                    failure_reasons.append(f"Port {target_port} not in VLAN {vlan_id}")
                    logger.warning(f"Port {target_port} not in VLAN {vlan_id}")
            
            # Intermediate devices: check trunk ports
            elif i < len(path) - 1:
                next_device = path[i + 1]
                uplink_port = self.nr.filter(name=device_ip).run(
                    task=self.find_uplink_port,
                    neighbor_ip=next_device
                )[device_ip].result
                
                if uplink_port:
                    trunk_ok = self.nr.filter(name=device_ip).run(
                        task=self.verify_trunk_vlan,
                        interface=uplink_port,
                        vlan_id=vlan_id
                    )[device_ip].result
                    
                    if trunk_ok:
                        result.trunk_status = f"Trunk {uplink_port} allows VLAN"
                        logger.debug(f"Trunk {uplink_port} allows VLAN {vlan_id}")
                    else:
                        result.trunk_status = f"VLAN {vlan_id} blocked on {uplink_port}"
                        result.overall_status = VerificationStatus.FAIL
                        overall_success = False
                        failure_reasons.append(f"VLAN {vlan_id} blocked on {uplink_port}")
                        logger.warning(f"VLAN {vlan_id} blocked on {uplink_port}")
                else:
                    result.trunk_status = f"No uplink found to {next_device}"
                    result.overall_status = VerificationStatus.FAIL
                    overall_success = False
                    failure_reasons.append(f"No uplink found to {next_device}")
                    logger.warning(f"No uplink found to {next_device}")
            
            # Router endpoint
            else:
                result.role = "Router endpoint"
                logger.debug(f"Router endpoint: {device_ip}")
            
            # Set overall status if not already failed
            if result.overall_status == VerificationStatus.UNKNOWN:
                result.overall_status = VerificationStatus.PASS
            
            results[device_ip] = result

        # Generate summary message
        if overall_success:
            message = f"VLAN {vlan_id} path fully verified"
        else:
            message = f"VLAN path verification failed: {'; '.join(failure_reasons[:3])}"
        
        logger.info(f"Verification complete: {message}")
        return overall_success, message, path, results

    def visualize_path(self, path: List[str], verification_results: Dict[str, DeviceResult]):
        """Create enhanced visualization of the network path"""
        plt.ioff()
        fig, ax = plt.subplots(figsize=(18, 12))
        
        # Create graph
        G = nx.path_graph(path)
        
        # Position nodes
        pos = {node: (i * 3, 0) for i, node in enumerate(G.nodes())}
        
        # Prepare node colors and labels
        node_colors = []
        node_labels = {}
        status_labels = {}
        
        for node in G.nodes():
            result = verification_results.get(node)
            if not result:
                node_colors.append("gray")
                status_labels[node] = "No data"
                continue
            
            # Determine color based on status
            if result.overall_status == VerificationStatus.PASS:
                node_colors.append("lightgreen")
                status = "✓ PASS"
            elif result.overall_status == VerificationStatus.FAIL:
                node_colors.append("red")
                status = "✗ FAIL"
            else:
                node_colors.append("gray")
                status = "? UNKNOWN"
            
            # Create node label
            node_labels[node] = node
            
            # Create status label
            status_lines = [f"Status: {status}"]
            
            if result.vlan_status:
                status_lines.append(f"VLAN: {result.vlan_status}")
            
            if result.port_status:
                status_lines.append(f"Port: {result.port_status}")
            
            if result.trunk_status:
                status_lines.append(f"Trunk: {result.trunk_status}")
            
            if result.role:
                status_lines.append(f"Role: {result.role}")
            
            status_labels[node] = "\n".join(status_lines[:4])  # Limit to 4 lines
        
        # Draw network graph
        nx.draw_networkx_nodes(G, pos, node_color=node_colors, node_size=5000, 
                              edgecolors='black', linewidths=2)
        nx.draw_networkx_edges(G, pos, width=3, edge_color='steelblue', 
                              arrows=True, arrowstyle='-|>', arrowsize=30)
        
        # Add device labels (above nodes)
        name_pos = {k: (v[0], v[1] + 0.8) for k, v in pos.items()}
        nx.draw_networkx_labels(G, name_pos, labels=node_labels, font_size=10, 
                               font_weight="bold")
        
        # Add status labels (below nodes)
        status_pos = {k: (v[0], v[1] - 1.2) for k, v in pos.items()}
        nx.draw_networkx_labels(G, status_pos, labels=status_labels, font_size=8,
                               bbox=dict(facecolor='white', edgecolor='black',
                                       boxstyle='round,pad=0.5', alpha=0.9))
        
        # Add legend
        legend_elements = [
            plt.Line2D([0], [0], marker='o', color='w', label='Pass', 
                      markerfacecolor='lightgreen', markersize=15),
            plt.Line2D([0], [0], marker='o', color='w', label='Fail', 
                      markerfacecolor='red', markersize=15),
            plt.Line2D([0], [0], marker='o', color='w', label='Unknown', 
                      markerfacecolor='gray', markersize=15)
        ]
        
        plt.legend(handles=legend_elements, loc='upper right', fontsize=12, 
                  title="Verification Status", title_fontsize=14)
        
        plt.title("Network VLAN Path Verification Results", pad=40, fontsize=18, 
                 fontweight='bold')
        plt.axis('off')
        plt.tight_layout()
        plt.show(block=True)
        plt.ion()


def main():
    """Main function to run VLAN path verification"""
    # Configuration
    initial_switch = "172.17.57.243"
    target_port = "GigabitEthernet1/0/10"
    vlan_id = "5"
    
    # Create verifier instance
    verifier = NetworkVerifier(config_file="config.yaml")
    
    try:
        # Run verification
        success, message, path, results = verifier.verify_vlan_path(
            initial_switch, target_port, vlan_id
        )
        
        # Print results
        print("\n" + "="*60)
        print(f"VLAN PATH VERIFICATION {'SUCCEEDED' if success else 'FAILED'}")
        print("="*60)
        print(f"Initial Switch: {initial_switch}")
        print(f"Target Port: {target_port}")
        print(f"VLAN ID: {vlan_id}")
        print(f"Path: {' → '.join(path)}")
        print(f"Status: {message}")
        print("="*60)
        
        # Detailed results
        print("\nDETAILED RESULTS:")
        print("-" * 40)
        for device_ip, result in results.items():
            print(f"\nDevice: {device_ip}")
            print(f"  Overall Status: {result.overall_status.value.upper()}")
            print(f"  VLAN Status: {result.vlan_status}")
            if result.port_status:
                print(f"  Port Status: {result.port_status}")
            if result.trunk_status:
                print(f"  Trunk Status: {result.trunk_status}")
            if result.role:
                print(f"  Role: {result.role}")
        
        # Show visualization
        if path and results:
            print("\nGenerating network visualization...")
            verifier.visualize_path(path, results)
        
        return success
        
    except Exception as e:
        logger.error(f"Verification failed with error: {str(e)}")
        print(f"\nERROR: Verification failed - {str(e)}")
        return False
    
    finally:
        # Cleanup
        if hasattr(verifier, 'nr') and verifier.nr:
            verifier.nr.close_connections()


if __name__ == "__main__":
    import sys
    
    # Allow command line arguments
    if len(sys.argv) >= 4:
        initial_switch = sys.argv[1]
        target_port = sys.argv[2]
        vlan_id = sys.argv[3]
        
        verifier = NetworkVerifier()
        success, message, path, results = verifier.verify_vlan_path(
            initial_switch, target_port, vlan_id
        )
        
        if success:
            print(f"✓ VLAN {vlan_id} path verification successful")
            sys.exit(0)
        else:
            print(f"✗ VLAN {vlan_id} path verification failed: {message}")
            sys.exit(1)
    else:
        # Use default configuration
        success = main()
        sys.exit(0 if success else 1)s[current_device].hostname == target_router:
from nornir import InitNornir
from nornir_netmiko import netmiko_send_command
from nornir.core.task import Task, Result
from typing import Dict, List, Tuple, Optional, Set
import networkx as nx
import matplotlib.pyplot as plt
import re
import logging
from dataclasses import dataclass
from enum import Enum

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class VerificationStatus(Enum):
    PASS = "pass"
    FAIL = "fail"
    UNKNOWN = "unknown"

@dataclass
class DeviceResult:
    device_ip: str
    vlan_status: str
    port_status: Optional[str] = None
    trunk_status: Optional[str] = None
    role: Optional[str] = None
    overall_status: VerificationStatus = VerificationStatus.UNKNOWN

class NetworkVerifier:
    def __init__(self, config_file: str = "config.yaml"):
        self.nr = InitNornir(config_file=config_file)
        self.max_hops = 15
        
    def get_lldp_neighbors(self, task: Task) -> List[Dict]:
        """Collect LLDP neighbor information in a vendor-neutral way"""
        platform = task.host.platform
        
        # Enhanced command mapping for different platforms
        command_map = {
            "aruba_cx": "show lldp neighbors detail",
            "cisco_ios": "show lldp neighbors detail",
            "cisco_xe": "show lldp neighbors detail",
            "hp_comware": "display lldp neighbor-information",
            "juniper": "show lldp neighbors detail"
        }
        
        command = command_map.get(platform, "show lldp neighbors detail")
        
        logger.debug(f"Running on {task.host}: {command}")
        
        try:
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            # Handle different result types
            if isinstance(result.result, str):
                logger.warning(f"TextFSM parsing failed for {task.host}, attempting manual parsing")
                return self._parse_lldp_manually(result.result, platform)
            elif isinstance(result.result, dict):
                return [result.result]
            elif isinstance(result.result, list):
                return result.result
            else:
                logger.warning(f"No LLDP neighbors found on {task.host}")
                return []
                
        except Exception as e:
            logger.error(f"Error getting LLDP neighbors on {task.host}: {str(e)}")
            return []

    def _parse_lldp_manually(self, output: str, platform: str) -> List[Dict]:
        """Manual parsing fallback for when TextFSM fails"""
        neighbors = []
        
        try:
            # Basic regex patterns for common LLDP output formats
            if platform == "cisco_ios":
                # Cisco IOS LLDP format
                pattern = r'Device ID: (\S+).*?Local Intf: (\S+).*?Port id: (\S+)'
                matches = re.findall(pattern, output, re.DOTALL)
                
                for match in matches:
                    neighbors.append({
                        'neighbor': match[0],
                        'local_interface': match[1],
                        'neighbor_port': match[2]
                    })
            
            # Add more platform-specific parsing as needed
            
        except Exception as e:
            logger.error(f"Manual LLDP parsing failed: {str(e)}")
            
        return neighbors

    def find_uplink_port(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find the local interface connected to a neighbor with improved error handling"""
        platform = task.host.platform
        
        try:
            # Try LLDP first (most reliable)
            lldp_result = self._find_port_via_lldp(task, neighbor_ip, platform)
            if lldp_result:
                return lldp_result
            
            # Fall back to CDP for Cisco devices
            if platform.startswith("cisco"):
                cdp_result = self._find_port_via_cdp(task, neighbor_ip)
                if cdp_result:
                    return cdp_result
                    
            # Last resort: MAC address table lookup
            mac_result = self._find_port_via_mac(task, neighbor_ip)
            if mac_result:
                return mac_result
                
        except Exception as e:
            logger.error(f"Error finding uplink port on {task.host}: {str(e)}")
        
        return None

    def _find_port_via_lldp(self, task: Task, neighbor_ip: str, platform: str) -> Optional[str]:
        """Find port using LLDP"""
        try:
            neighbors = self.get_lldp_neighbors(task)
            
            for neighbor in neighbors:
                # Check multiple possible neighbor identifier fields
                neighbor_id = (neighbor.get('neighbor') or 
                             neighbor.get('mgmt_address') or 
                             neighbor.get('system_name'))
                
                if neighbor_id and (neighbor_id == neighbor_ip or 
                                  neighbor_id.startswith(neighbor_ip.split('.')[0])):
                    return neighbor.get('local_interface')
                    
        except Exception as e:
            logger.debug(f"LLDP port lookup failed: {str(e)}")
            
        return None

    def _find_port_via_cdp(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find port using CDP (Cisco devices)"""
        try:
            command = "show cdp neighbors detail"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if result.result:
                for neighbor in (result.result if isinstance(result.result, list) else [result.result]):
                    if neighbor.get('mgmt_address') == neighbor_ip:
                        return neighbor.get('local_port')
                        
        except Exception as e:
            logger.debug(f"CDP port lookup failed: {str(e)}")
            
        return None

    def _find_port_via_mac(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find port using MAC address table (least reliable)"""
        try:
            # This would require ARP table lookup first, then MAC table
            # Implementation depends on specific requirements
            pass
        except Exception as e:
            logger.debug(f"MAC table port lookup failed: {str(e)}")
            
        return None

    def verify_vlan_exists(self, task: Task, vlan_id: str) -> bool:
        """Check if VLAN exists with enhanced platform support"""
        platform = task.host.platform
        
        command_map = {
            "aruba_cx": f"show vlan {vlan_id}",
            "cisco_ios": f"show vlan id {vlan_id}",
            "cisco_xe": f"show vlan id {vlan_id}",
            "hp_comware": f"display vlan {vlan_id}",
            "juniper": f"show vlans {vlan_id}"
        }
        
        command = command_map.get(platform, f"show vlan id {vlan_id}")
        
        try:
            logger.debug(f"Running on {task.host}: {command}")
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if isinstance(result.result, str):
                # Check for common error messages
                error_indicators = ["invalid", "not found", "does not exist", "error"]
                return not any(indicator in result.result.lower() for indicator in error_indicators)
            
            return bool(result.result)
            
        except Exception as e:
            logger.error(f"Error checking VLAN on {task.host}: {str(e)}")
            return False

    def verify_access_vlan(self, task: Task, interface: str, vlan_id: str) -> bool:
        """Verify access port VLAN configuration with better error handling"""
        platform = task.host.platform
        
        try:
            # Method 1: Check VLAN membership
            if self._check_vlan_membership(task, interface, vlan_id, platform):
                return True
            
            # Method 2: Check interface configuration
            if self._check_interface_config(task, interface, vlan_id, platform):
                return True
            
            logger.debug(f"Access VLAN {vlan_id} not found on {interface}")
            return False
            
        except Exception as e:
            logger.error(f"Error checking access port on {task.host}: {str(e)}")
            return False

    def _check_vlan_membership(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check VLAN membership tables"""
        try:
            command_map = {
                "aruba_cx": f"show vlan {vlan_id}",
                "cisco_ios": f"show vlan id {vlan_id}",
                "cisco_xe": f"show vlan id {vlan_id}",
            }
            
            command = command_map.get(platform, f"show vlan id {vlan_id}")
            
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if result.result:
                for vlan in (result.result if isinstance(result.result, list) else [result.result]):
                    interfaces = vlan.get('interfaces', [])
                    if isinstance(interfaces, str):
                        interfaces = [interfaces]
                    
                    # Normalize interface names for comparison
                    normalized_interfaces = [self._normalize_interface_name(intf) for intf in interfaces]
                    normalized_target = self._normalize_interface_name(interface)
                    
                    if normalized_target in normalized_interfaces:
                        return True
                        
        except Exception as e:
            logger.debug(f"VLAN membership check failed: {str(e)}")
            
        return False

    def _check_interface_config(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check interface running configuration"""
        try:
            command = f"show running-config interface {interface}"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=False,
                enable=True
            )
            
            config = result.result.lower()
            
            # Platform-specific config patterns
            patterns = {
                "aruba_cx": [f"vlan access {vlan_id}"],
                "cisco_ios": [f"switchport access vlan {vlan_id}"],
                "cisco_xe": [f"switchport access vlan {vlan_id}"],
            }
            
            check_patterns = patterns.get(platform, [f"switchport access vlan {vlan_id}"])
            
            return any(pattern in config for pattern in check_patterns)
            
        except Exception as e:
            logger.debug(f"Interface config check failed: {str(e)}")
            
        return False

    def _normalize_interface_name(self, interface: str) -> str:
        """Normalize interface names for comparison"""
        # Handle common abbreviations
        interface = interface.replace("GigabitEthernet", "Gi")
        interface = interface.replace("FastEthernet", "Fa")
        interface = interface.replace("TenGigabitEthernet", "Te")
        
        # Remove spaces and convert to lowercase
        return interface.replace(" ", "").lower()

    def verify_trunk_vlan(self, task: Task, interface: str, vlan_id: str) -> bool:
        """Verify trunk allows the VLAN with comprehensive checking"""
        platform = task.host.platform
        
        try:
            # Method 1: Check switchport status
            if self._check_switchport_trunk(task, interface, vlan_id, platform):
                return True
            
            # Method 2: Check running configuration
            if self._check_trunk_config(task, interface, vlan_id, platform):
                return True
            
            return False
            
        except Exception as e:
            logger.error(f"Error checking trunk on {task.host}: {str(e)}")
            return False

    def _check_switchport_trunk(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check switchport trunk status"""
        try:
            command = f"show interfaces {interface} switchport"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if isinstance(result.result, str):
                # Parse raw output
                return self._parse_trunk_raw_output(result.result, vlan_id)
            
            if result.result and isinstance(result.result, list):
                sw_data = result.result[0]
                
                # Check if port is in trunk mode
                if sw_data.get('mode', '').lower() != 'trunk':
                    return False
                
                # Check allowed VLANs
                return self._check_allowed_vlans(sw_data, vlan_id)
                
        except Exception as e:
            logger.debug(f"Switchport trunk check failed: {str(e)}")
            
        return False

    def _parse_trunk_raw_output(self, output: str, vlan_id: str) -> bool:
        """Parse raw switchport output"""
        output_lower = output.lower()
        
        if "trunking" in output_lower:
            if "vlans allowed: all" in output_lower:
                return True
            if f"vlans allowed: {vlan_id}" in output_lower:
                return True
        
        return False

    def _check_allowed_vlans(self, switchport_data: Dict, vlan_id: str) -> bool:
        """Check if VLAN is in allowed VLAN list"""
        for field in ['trunking_vlans', 'vlans_allowed', 'allowed_vlans']:
            vlans = switchport_data.get(field, '')
            
            if vlans:
                if vlans.upper() == 'ALL':
                    return True
                if self._is_vlan_in_list(vlans, vlan_id):
                    return True
        
        return False

    def _check_trunk_config(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check trunk configuration in running config"""
        try:
            command = f"show running-config interface {interface}"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                enable=True
            )
            
            config = result.result.lower()
            
            # If trunk mode is configured but no allowed VLAN restrictions, assume all VLANs allowed
            if "switchport mode trunk" in config and "switchport trunk allowed vlan" not in config:
                return True
            
            # Check specific VLAN allowances
            if f"switchport trunk allowed vlan add {vlan_id}" in config:
                return True
            
            return False
            
        except Exception as e:
            logger.debug(f"Trunk config check failed: {str(e)}")
            
        return False

    def _is_vlan_in_list(self, vlan_str: str, target_vlan: str) -> bool:
        """Helper to safely parse VLAN lists (1,5,10-20,30)"""
        try:
            if not vlan_str:
                return False
                
            target_int = int(target_vlan)
            
            for part in str(vlan_str).split(','):
                part = part.strip()
                
                if '-' in part:
                    # Handle range (e.g., "10-20")
                    start, end = map(int, part.split('-'))
                    if start <= target_int <= end:
                        return True
                elif part.isdigit() and int(part) == target_int:
                    return True
                    
            return False
            
        except (ValueError, AttributeError) as e:
            logger.error(f"VLAN list parsing failed: {str(e)}")
            return False

    def trace_path_to_router(self, start_device: str) -> List[str]:
        """Trace path from edge switch to router using LLDP with improved logic"""
        logger.info("Starting path trace to router...")
        
        path = []
        current_device = start_device
        visited: Set[str] = set()
        
        # Get target router
        try:
            target_router = self.nr.inventory.hosts[start_device].data.get('router')
            if not target_router:
                logger.error(f"No router defined for {start_device}")
                return []
        except KeyError:
            logger.error(f"Device {start_device} not found in inventory")
            return []

        logger.info(f"Target router: {target_router}")

        while current_device and current_device not in visited and len(path) < self.max_hops:
            visited.add(current_device)
            path.append(current_device)
            
            logger.debug(f"Current device: {current_device}")
            logger.debug(f"Current path: {' -> '.join(path)}")
            
            # Check if we've reached the target router
            if current_device == target_router:
                logger.info(f"Reached target router: {current_device}")
                break
            
            # Get neighbors and find next hop
            next_hop = self._find_next_hop(current_device, target_router, visited)
            if not next_hop:
                logger.warning(f"No valid next hop found from {current_device}")
                break
                
            current_device = next_hop

        # Ensure router is in path
        if path and path[-1] != target_router:
            path.append(target_router)
            logger.debug(f"Added router {target_router} to path")

        logger.info(f"Final path: {' -> '.join(path)}")
        return path

    def _find_next_hop(self, current_device: str, target_router: str, visited: Set[str]) -> Optional[str]:
        """Find the next hop in the path"""
        try:
            neighbors_result = self.nr.filter(name=current_device).run(task=self.get_lldp_neighbors)
            neighbors = neighbors_result[current_device].result
            
            if not neighbors:
                logger.debug(f"No neighbors found for {current_device}")
                return None
            
            # Find unvisited neighbors
            possible_hops = []
            for neighbor in (neighbors if isinstance(neighbors, list) else [neighbors]):
                if isinstance(neighbor, dict):
                    neighbor_ip = self._extract_neighbor_ip(neighbor)
                    
                    if neighbor_ip and neighbor_ip not in visited:
                        # Try to resolve to inventory hostname
                        resolved_ip = self._resolve_neighbor_ip(neighbor_ip)
                        if resolved_ip:
                            possible_hops.append(resolved_ip)
            
            if not possible_hops:
                return None
            
            # Prioritize direct connection to router
            if target_router in possible_hops:
                return target_router
            
            # Prioritize devices that have the target router configured
            for hop in possible_hops:
                try:
                    if self.nr.inventory.hosts[hop].data.get('router') == target_router:
                        return hop
                except KeyError:
                    continue
            
            # Return first available hop
            return possible_hops[0]
            
        except Exception as e:
            logger.error(f"Error finding next hop from {current_device}: {str(e)}")
            return None

    def _extract_neighbor_ip(self, neighbor: Dict) -> Optional[str]:
        """Extract neighbor IP from LLDP data"""
        neighbor_ip = (neighbor.get('mgmt_address') or 
                      neighbor.get('neighbor') or 
                      neighbor.get('neighbor_name') or
                      neighbor.get('system_name'))
        
        if neighbor_ip and '.' not in neighbor_ip:
            # Handle hostname format
            neighbor_ip = neighbor_ip.split('.')[0]
        
        return neighbor_ip

    def _resolve_neighbor_ip(self, neighbor_ip: str) -> Optional[str]:
        """Resolve neighbor IP to inventory hostname"""
        # Direct match
        if neighbor_ip in self.nr.inventory.hosts:
            return neighbor_ip
        
        # Hostname match
        for hostname, host in self.nr.inventory.hosts.items():
            if (host.get('hostname', '') == neighbor_ip or 
                hostname.startswith(neighbor_ip)):
                return hostname
        
        return None

    def verify_vlan_path(self, initial_switch: str, target_port: str, vlan_id: str) -> Tuple[bool, str, List[str], Dict[str, DeviceResult]]:
        """Comprehensive VLAN path verification"""
        logger.info("Starting VLAN path verification")
        
        # Trace path
        path = self.trace_path_to_router(initial_switch)
        if not path:
            return False, "No path found to router", [], {}

        # Verify each device in path
        results = {}
        overall_success = True
        failure_reasons = []
        
        for i, device_ip in enumerate(path):
            logger.info(f"Verifying device {i+1}/{len(path)}: {device_ip}")
            
            result = DeviceResult(device_ip=device_ip, vlan_status="Unknown")
            
            # Check VLAN exists
            vlan_exists = self.nr.filter(name=device_ip).run(
                task=self.verify_vlan_exists,
                vlan_id=vlan_id
            )[device_ip].result
            
            if vlan_exists:
                result.vlan_status = "VLAN exists"
                logger.debug(f"VLAN {vlan_id} exists on {device_ip}")
            else:
                result.vlan_status = "VLAN missing"
                result.overall_status = VerificationStatus.FAIL
                overall_success = False
                failure_reasons.append(f"VLAN {vlan_id} missing on {device_ip}")
                logger.warning(f"VLAN {vlan_id} missing on {device_ip}")
            
            # First device: check access port
            if i == 0:
                access_ok = self.nr.filter(name=device_ip).run(
                    task=self.verify_access_vlan,
                    interface=target_port,
                    vlan_id=vlan_id
                )[device_ip].result
                
                if access_ok:
                    result.port_status = "Access port configured"
                    logger.debug(f"Access port {target_port} configured on {device_ip}")
                else:
                    result.port_status = f"Port {target_port} not in VLAN {vlan_id}"
                    result.overall_status = VerificationStatus.FAIL
                    overall_success = False
                    failure_reasons.append(f"Port {target_port} not in VLAN {vlan_id}")
                    logger.warning(f"Port {target_port} not in VLAN {vlan_id}")
            
            # Intermediate devices: check trunk ports
            elif i < len(path) - 1:
                next_device = path[i + 1]
                uplink_port = self.nr.filter(name=device_ip).run(
                    task=self.find_uplink_port,
                    neighbor_ip=next_device
                )[device_ip].result
                
                if uplink_port:
                    trunk_ok = self.nr.filter(name=device_ip).run(
                        task=self.verify_trunk_vlan,
                        interface=uplink_port,
                        vlan_id=vlan_id
                    )[device_ip].result
                    
                    if trunk_ok:
                        result.trunk_status = f"Trunk {uplink_port} allows VLAN"
                        logger.debug(f"Trunk {uplink_port} allows VLAN {vlan_id}")
                    else:
                        result.trunk_status = f"VLAN {vlan_id} blocked on {uplink_port}"
                        result.overall_status = VerificationStatus.FAIL
                        overall_success = False
                        failure_reasons.append(f"VLAN {vlan_id} blocked on {uplink_port}")
                        logger.warning(f"VLAN {vlan_id} blocked on {uplink_port}")
                else:
                    result.trunk_status = f"No uplink found to {next_device}"
                    result.overall_status = VerificationStatus.FAIL
                    overall_success = False
                    failure_reasons.append(f"No uplink found to {next_device}")
                    logger.warning(f"No uplink found to {next_device}")
            
            # Router endpoint
            else:
                result.role = "Router endpoint"
                logger.debug(f"Router endpoint: {device_ip}")
            
            # Set overall status if not already failed
            if result.overall_status == VerificationStatus.UNKNOWN:
                result.overall_status = VerificationStatus.PASS
            
            results[device_ip] = result

        # Generate summary message
        if overall_success:
            message = f"VLAN {vlan_id} path fully verified"
        else:
            message = f"VLAN path verification failed: {'; '.join(failure_reasons[:3])}"
        
        logger.info(f"Verification complete: {message}")
        return overall_success, message, path, results

    def visualize_path(self, path: List[str], verification_results: Dict[str, DeviceResult]):
        """Create enhanced visualization of the network path"""
        plt.ioff()
        fig, ax = plt.subplots(figsize=(18, 12))
        
        # Create graph
        G = nx.path_graph(path)
        
        # Position nodes
        pos = {node: (i * 3, 0) for i, node in enumerate(G.nodes())}
        
        # Prepare node colors and labels
        node_colors = []
        node_labels = {}
        status_labels = {}
        
        for node in G.nodes():
            result = verification_results.get(node)
            if not result:
                node_colors.append("gray")
                status_labels[node] = "No data"
                continue
            
            # Determine color based on status
            if result.overall_status == VerificationStatus.PASS:
                node_colors.append("lightgreen")
                status = "✓ PASS"
            elif result.overall_status == VerificationStatus.FAIL:
                node_colors.append("red")
                status = "✗ FAIL"
            else:
                node_colors.append("gray")
                status = "? UNKNOWN"
            
            # Create node label
            node_labels[node] = node
            
            # Create status label
            status_lines = [f"Status: {status}"]
            
            if result.vlan_status:
                status_lines.append(f"VLAN: {result.vlan_status}")
            
            if result.port_status:
                status_lines.append(f"Port: {result.port_status}")
            
            if result.trunk_status:
                status_lines.append(f"Trunk: {result.trunk_status}")
            
            if result.role:
                status_lines.append(f"Role: {result.role}")
            
            status_labels[node] = "\n".join(status_lines[:4])  # Limit to 4 lines
        
        # Draw network graph
        nx.draw_networkx_nodes(G, pos, node_color=node_colors, node_size=5000, 
                              edgecolors='black', linewidths=2)
        nx.draw_networkx_edges(G, pos, width=3, edge_color='steelblue', 
                              arrows=True, arrowstyle='-|>', arrowsize=30)
        
        # Add device labels (above nodes)
        name_pos = {k: (v[0], v[1] + 0.8) for k, v in pos.items()}
        nx.draw_networkx_labels(G, name_pos, labels=node_labels, font_size=10, 
                               font_weight="bold")
        
        # Add status labels (below nodes)
        status_pos = {k: (v[0], v[1] - 1.2) for k, v in pos.items()}
        nx.draw_networkx_labels(G, status_pos, labels=status_labels, font_size=8,
                               bbox=dict(facecolor='white', edgecolor='black',
                                       boxstyle='round,pad=0.5', alpha=0.9))
        
        # Add legend
        legend_elements = [
            plt.Line2D([0], [0], marker='o', color='w', label='Pass', 
                      markerfacecolor='lightgreen', markersize=15),
            plt.Line2D([0], [0], marker='o', color='w', label='Fail', 
                      markerfacecolor='red', markersize=15),
            plt.Line2D([0], [0], marker='o', color='w', label='Unknown', 
                      markerfacecolor='gray', markersize=15)
        ]
        
        plt.legend(handles=legend_elements, loc='upper right', fontsize=12, 
                  title="Verification Status", title_fontsize=14)
        
        plt.title("Network VLAN Path Verification Results", pad=40, fontsize=18, 
                 fontweight='bold')
        plt.axis('off')
        plt.tight_layout()
        plt.show(block=True)
        plt.ion()


def main():
    """Main function to run VLAN path verification"""
    # Configuration
    initial_switch = "172.17.57.243"
    target_port = "GigabitEthernet1/0/10"
    vlan_id = "5"
    
    # Create verifier instance
    verifier = NetworkVerifier(config_file="config.yaml")
    
    try:
        # Run verification
        success, message, path, results = verifier.verify_vlan_path(
            initial_switch, target_port, vlan_id
        )
        
        # Print results
        print("\n" + "="*60)
        print(f"VLAN PATH VERIFICATION {'SUCCEEDED' if success else 'FAILED'}")
        print("="*60)
        print(f"Initial Switch: {initial_switch}")
        print(f"Target Port: {target_port}")
        print(f"VLAN ID: {vlan_id}")
        print(f"Path: {' → '.join(path)}")
        print(f"Status: {message}")
        print("="*60)
        
        # Detailed results
        print("\nDETAILED RESULTS:")
        print("-" * 40)
        for device_ip, result in results.items():
            print(f"\nDevice: {device_ip}")
            print(f"  Overall Status: {result.overall_status.value.upper()}")
            print(f"  VLAN Status: {result.vlan_status}")
            if result.port_status:
                print(f"  Port Status: {result.port_status}")
            if result.trunk_status:
                print(f"  Trunk Status: {result.trunk_status}")
            if result.role:
                print(f"  Role: {result.role}")
        
        # Show visualization
        if path and results:
            print("\nGenerating network visualization...")
            verifier.visualize_path(path, results)
        
        return success
        
    except Exception as e:
        logger.error(f"Verification failed with error: {str(e)}")
        print(f"\nERROR: Verification failed - {str(e)}")
        return False
    
    finally:
        # Cleanup
        if hasattr(verifier, 'nr') and verifier.nr:
            verifier.nr.close_connections()


if __name__ == "__main__":
    import sys
    
    # Allow command line arguments
    if len(sys.argv) >= 4:
        initial_switch = sys.argv[1]
        target_port = sys.argv[2]
        vlan_id = sys.argv[3]
        
        verifier = NetworkVerifier()
        success, message, path, results = verifier.verify_vlan_path(
            initial_switch, target_port, vlan_id
        )
        
        if success:
            print(f"✓ VLAN {vlan_id} path verification successful")
            sys.exit(0)
        else:
            print(f"✗ VLAN {vlan_id} path verification failed: {message}")
            sys.exit(1)
    else:
        # Use default configuration
        success = main()
        sys.exit(0 if success else 1)eached router {target_router} with VLAN {vlan_id} intact")
from nornir import InitNornir
from nornir_netmiko import netmiko_send_command
from nornir.core.task import Task, Result
from typing import Dict, List, Tuple, Optional, Set
import networkx as nx
import matplotlib.pyplot as plt
import re
import logging
from dataclasses import dataclass
from enum import Enum

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class VerificationStatus(Enum):
    PASS = "pass"
    FAIL = "fail"
    UNKNOWN = "unknown"

@dataclass
class DeviceResult:
    device_ip: str
    vlan_status: str
    port_status: Optional[str] = None
    trunk_status: Optional[str] = None
    role: Optional[str] = None
    overall_status: VerificationStatus = VerificationStatus.UNKNOWN

class NetworkVerifier:
    def __init__(self, config_file: str = "config.yaml"):
        self.nr = InitNornir(config_file=config_file)
        self.max_hops = 15
        
    def get_lldp_neighbors(self, task: Task) -> List[Dict]:
        """Collect LLDP neighbor information in a vendor-neutral way"""
        platform = task.host.platform
        
        # Enhanced command mapping for different platforms
        command_map = {
            "aruba_cx": "show lldp neighbors detail",
            "cisco_ios": "show lldp neighbors detail",
            "cisco_xe": "show lldp neighbors detail",
            "hp_comware": "display lldp neighbor-information",
            "juniper": "show lldp neighbors detail"
        }
        
        command = command_map.get(platform, "show lldp neighbors detail")
        
        logger.debug(f"Running on {task.host}: {command}")
        
        try:
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            # Handle different result types
            if isinstance(result.result, str):
                logger.warning(f"TextFSM parsing failed for {task.host}, attempting manual parsing")
                return self._parse_lldp_manually(result.result, platform)
            elif isinstance(result.result, dict):
                return [result.result]
            elif isinstance(result.result, list):
                return result.result
            else:
                logger.warning(f"No LLDP neighbors found on {task.host}")
                return []
                
        except Exception as e:
            logger.error(f"Error getting LLDP neighbors on {task.host}: {str(e)}")
            return []

    def _parse_lldp_manually(self, output: str, platform: str) -> List[Dict]:
        """Manual parsing fallback for when TextFSM fails"""
        neighbors = []
        
        try:
            # Basic regex patterns for common LLDP output formats
            if platform == "cisco_ios":
                # Cisco IOS LLDP format
                pattern = r'Device ID: (\S+).*?Local Intf: (\S+).*?Port id: (\S+)'
                matches = re.findall(pattern, output, re.DOTALL)
                
                for match in matches:
                    neighbors.append({
                        'neighbor': match[0],
                        'local_interface': match[1],
                        'neighbor_port': match[2]
                    })
            
            # Add more platform-specific parsing as needed
            
        except Exception as e:
            logger.error(f"Manual LLDP parsing failed: {str(e)}")
            
        return neighbors

    def find_uplink_port(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find the local interface connected to a neighbor with improved error handling"""
        platform = task.host.platform
        
        try:
            # Try LLDP first (most reliable)
            lldp_result = self._find_port_via_lldp(task, neighbor_ip, platform)
            if lldp_result:
                return lldp_result
            
            # Fall back to CDP for Cisco devices
            if platform.startswith("cisco"):
                cdp_result = self._find_port_via_cdp(task, neighbor_ip)
                if cdp_result:
                    return cdp_result
                    
            # Last resort: MAC address table lookup
            mac_result = self._find_port_via_mac(task, neighbor_ip)
            if mac_result:
                return mac_result
                
        except Exception as e:
            logger.error(f"Error finding uplink port on {task.host}: {str(e)}")
        
        return None

    def _find_port_via_lldp(self, task: Task, neighbor_ip: str, platform: str) -> Optional[str]:
        """Find port using LLDP"""
        try:
            neighbors = self.get_lldp_neighbors(task)
            
            for neighbor in neighbors:
                # Check multiple possible neighbor identifier fields
                neighbor_id = (neighbor.get('neighbor') or 
                             neighbor.get('mgmt_address') or 
                             neighbor.get('system_name'))
                
                if neighbor_id and (neighbor_id == neighbor_ip or 
                                  neighbor_id.startswith(neighbor_ip.split('.')[0])):
                    return neighbor.get('local_interface')
                    
        except Exception as e:
            logger.debug(f"LLDP port lookup failed: {str(e)}")
            
        return None

    def _find_port_via_cdp(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find port using CDP (Cisco devices)"""
        try:
            command = "show cdp neighbors detail"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if result.result:
                for neighbor in (result.result if isinstance(result.result, list) else [result.result]):
                    if neighbor.get('mgmt_address') == neighbor_ip:
                        return neighbor.get('local_port')
                        
        except Exception as e:
            logger.debug(f"CDP port lookup failed: {str(e)}")
            
        return None

    def _find_port_via_mac(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find port using MAC address table (least reliable)"""
        try:
            # This would require ARP table lookup first, then MAC table
            # Implementation depends on specific requirements
            pass
        except Exception as e:
            logger.debug(f"MAC table port lookup failed: {str(e)}")
            
        return None

    def verify_vlan_exists(self, task: Task, vlan_id: str) -> bool:
        """Check if VLAN exists with enhanced platform support"""
        platform = task.host.platform
        
        command_map = {
            "aruba_cx": f"show vlan {vlan_id}",
            "cisco_ios": f"show vlan id {vlan_id}",
            "cisco_xe": f"show vlan id {vlan_id}",
            "hp_comware": f"display vlan {vlan_id}",
            "juniper": f"show vlans {vlan_id}"
        }
        
        command = command_map.get(platform, f"show vlan id {vlan_id}")
        
        try:
            logger.debug(f"Running on {task.host}: {command}")
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if isinstance(result.result, str):
                # Check for common error messages
                error_indicators = ["invalid", "not found", "does not exist", "error"]
                return not any(indicator in result.result.lower() for indicator in error_indicators)
            
            return bool(result.result)
            
        except Exception as e:
            logger.error(f"Error checking VLAN on {task.host}: {str(e)}")
            return False

    def verify_access_vlan(self, task: Task, interface: str, vlan_id: str) -> bool:
        """Verify access port VLAN configuration with better error handling"""
        platform = task.host.platform
        
        try:
            # Method 1: Check VLAN membership
            if self._check_vlan_membership(task, interface, vlan_id, platform):
                return True
            
            # Method 2: Check interface configuration
            if self._check_interface_config(task, interface, vlan_id, platform):
                return True
            
            logger.debug(f"Access VLAN {vlan_id} not found on {interface}")
            return False
            
        except Exception as e:
            logger.error(f"Error checking access port on {task.host}: {str(e)}")
            return False

    def _check_vlan_membership(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check VLAN membership tables"""
        try:
            command_map = {
                "aruba_cx": f"show vlan {vlan_id}",
                "cisco_ios": f"show vlan id {vlan_id}",
                "cisco_xe": f"show vlan id {vlan_id}",
            }
            
            command = command_map.get(platform, f"show vlan id {vlan_id}")
            
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if result.result:
                for vlan in (result.result if isinstance(result.result, list) else [result.result]):
                    interfaces = vlan.get('interfaces', [])
                    if isinstance(interfaces, str):
                        interfaces = [interfaces]
                    
                    # Normalize interface names for comparison
                    normalized_interfaces = [self._normalize_interface_name(intf) for intf in interfaces]
                    normalized_target = self._normalize_interface_name(interface)
                    
                    if normalized_target in normalized_interfaces:
                        return True
                        
        except Exception as e:
            logger.debug(f"VLAN membership check failed: {str(e)}")
            
        return False

    def _check_interface_config(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check interface running configuration"""
        try:
            command = f"show running-config interface {interface}"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=False,
                enable=True
            )
            
            config = result.result.lower()
            
            # Platform-specific config patterns
            patterns = {
                "aruba_cx": [f"vlan access {vlan_id}"],
                "cisco_ios": [f"switchport access vlan {vlan_id}"],
                "cisco_xe": [f"switchport access vlan {vlan_id}"],
            }
            
            check_patterns = patterns.get(platform, [f"switchport access vlan {vlan_id}"])
            
            return any(pattern in config for pattern in check_patterns)
            
        except Exception as e:
            logger.debug(f"Interface config check failed: {str(e)}")
            
        return False

    def _normalize_interface_name(self, interface: str) -> str:
        """Normalize interface names for comparison"""
        # Handle common abbreviations
        interface = interface.replace("GigabitEthernet", "Gi")
        interface = interface.replace("FastEthernet", "Fa")
        interface = interface.replace("TenGigabitEthernet", "Te")
        
        # Remove spaces and convert to lowercase
        return interface.replace(" ", "").lower()

    def verify_trunk_vlan(self, task: Task, interface: str, vlan_id: str) -> bool:
        """Verify trunk allows the VLAN with comprehensive checking"""
        platform = task.host.platform
        
        try:
            # Method 1: Check switchport status
            if self._check_switchport_trunk(task, interface, vlan_id, platform):
                return True
            
            # Method 2: Check running configuration
            if self._check_trunk_config(task, interface, vlan_id, platform):
                return True
            
            return False
            
        except Exception as e:
            logger.error(f"Error checking trunk on {task.host}: {str(e)}")
            return False

    def _check_switchport_trunk(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check switchport trunk status"""
        try:
            command = f"show interfaces {interface} switchport"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if isinstance(result.result, str):
                # Parse raw output
                return self._parse_trunk_raw_output(result.result, vlan_id)
            
            if result.result and isinstance(result.result, list):
                sw_data = result.result[0]
                
                # Check if port is in trunk mode
                if sw_data.get('mode', '').lower() != 'trunk':
                    return False
                
                # Check allowed VLANs
                return self._check_allowed_vlans(sw_data, vlan_id)
                
        except Exception as e:
            logger.debug(f"Switchport trunk check failed: {str(e)}")
            
        return False

    def _parse_trunk_raw_output(self, output: str, vlan_id: str) -> bool:
        """Parse raw switchport output"""
        output_lower = output.lower()
        
        if "trunking" in output_lower:
            if "vlans allowed: all" in output_lower:
                return True
            if f"vlans allowed: {vlan_id}" in output_lower:
                return True
        
        return False

    def _check_allowed_vlans(self, switchport_data: Dict, vlan_id: str) -> bool:
        """Check if VLAN is in allowed VLAN list"""
        for field in ['trunking_vlans', 'vlans_allowed', 'allowed_vlans']:
            vlans = switchport_data.get(field, '')
            
            if vlans:
                if vlans.upper() == 'ALL':
                    return True
                if self._is_vlan_in_list(vlans, vlan_id):
                    return True
        
        return False

    def _check_trunk_config(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check trunk configuration in running config"""
        try:
            command = f"show running-config interface {interface}"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                enable=True
            )
            
            config = result.result.lower()
            
            # If trunk mode is configured but no allowed VLAN restrictions, assume all VLANs allowed
            if "switchport mode trunk" in config and "switchport trunk allowed vlan" not in config:
                return True
            
            # Check specific VLAN allowances
            if f"switchport trunk allowed vlan add {vlan_id}" in config:
                return True
            
            return False
            
        except Exception as e:
            logger.debug(f"Trunk config check failed: {str(e)}")
            
        return False

    def _is_vlan_in_list(self, vlan_str: str, target_vlan: str) -> bool:
        """Helper to safely parse VLAN lists (1,5,10-20,30)"""
        try:
            if not vlan_str:
                return False
                
            target_int = int(target_vlan)
            
            for part in str(vlan_str).split(','):
                part = part.strip()
                
                if '-' in part:
                    # Handle range (e.g., "10-20")
                    start, end = map(int, part.split('-'))
                    if start <= target_int <= end:
                        return True
                elif part.isdigit() and int(part) == target_int:
                    return True
                    
            return False
            
        except (ValueError, AttributeError) as e:
            logger.error(f"VLAN list parsing failed: {str(e)}")
            return False

    def trace_path_to_router(self, start_device: str) -> List[str]:
        """Trace path from edge switch to router using LLDP with improved logic"""
        logger.info("Starting path trace to router...")
        
        path = []
        current_device = start_device
        visited: Set[str] = set()
        
        # Get target router
        try:
            target_router = self.nr.inventory.hosts[start_device].data.get('router')
            if not target_router:
                logger.error(f"No router defined for {start_device}")
                return []
        except KeyError:
            logger.error(f"Device {start_device} not found in inventory")
            return []

        logger.info(f"Target router: {target_router}")

        while current_device and current_device not in visited and len(path) < self.max_hops:
            visited.add(current_device)
            path.append(current_device)
            
            logger.debug(f"Current device: {current_device}")
            logger.debug(f"Current path: {' -> '.join(path)}")
            
            # Check if we've reached the target router
            if current_device == target_router:
                logger.info(f"Reached target router: {current_device}")
                break
            
            # Get neighbors and find next hop
            next_hop = self._find_next_hop(current_device, target_router, visited)
            if not next_hop:
                logger.warning(f"No valid next hop found from {current_device}")
                break
                
            current_device = next_hop

        # Ensure router is in path
        if path and path[-1] != target_router:
            path.append(target_router)
            logger.debug(f"Added router {target_router} to path")

        logger.info(f"Final path: {' -> '.join(path)}")
        return path

    def _find_next_hop(self, current_device: str, target_router: str, visited: Set[str]) -> Optional[str]:
        """Find the next hop in the path"""
        try:
            neighbors_result = self.nr.filter(name=current_device).run(task=self.get_lldp_neighbors)
            neighbors = neighbors_result[current_device].result
            
            if not neighbors:
                logger.debug(f"No neighbors found for {current_device}")
                return None
            
            # Find unvisited neighbors
            possible_hops = []
            for neighbor in (neighbors if isinstance(neighbors, list) else [neighbors]):
                if isinstance(neighbor, dict):
                    neighbor_ip = self._extract_neighbor_ip(neighbor)
                    
                    if neighbor_ip and neighbor_ip not in visited:
                        # Try to resolve to inventory hostname
                        resolved_ip = self._resolve_neighbor_ip(neighbor_ip)
                        if resolved_ip:
                            possible_hops.append(resolved_ip)
            
            if not possible_hops:
                return None
            
            # Prioritize direct connection to router
            if target_router in possible_hops:
                return target_router
            
            # Prioritize devices that have the target router configured
            for hop in possible_hops:
                try:
                    if self.nr.inventory.hosts[hop].data.get('router') == target_router:
                        return hop
                except KeyError:
                    continue
            
            # Return first available hop
            return possible_hops[0]
            
        except Exception as e:
            logger.error(f"Error finding next hop from {current_device}: {str(e)}")
            return None

    def _extract_neighbor_ip(self, neighbor: Dict) -> Optional[str]:
        """Extract neighbor IP from LLDP data"""
        neighbor_ip = (neighbor.get('mgmt_address') or 
                      neighbor.get('neighbor') or 
                      neighbor.get('neighbor_name') or
                      neighbor.get('system_name'))
        
        if neighbor_ip and '.' not in neighbor_ip:
            # Handle hostname format
            neighbor_ip = neighbor_ip.split('.')[0]
        
        return neighbor_ip

    def _resolve_neighbor_ip(self, neighbor_ip: str) -> Optional[str]:
        """Resolve neighbor IP to inventory hostname"""
        # Direct match
        if neighbor_ip in self.nr.inventory.hosts:
            return neighbor_ip
        
        # Hostname match
        for hostname, host in self.nr.inventory.hosts.items():
            if (host.get('hostname', '') == neighbor_ip or 
                hostname.startswith(neighbor_ip)):
                return hostname
        
        return None

    def verify_vlan_path(self, initial_switch: str, target_port: str, vlan_id: str) -> Tuple[bool, str, List[str], Dict[str, DeviceResult]]:
        """Comprehensive VLAN path verification"""
        logger.info("Starting VLAN path verification")
        
        # Trace path
        path = self.trace_path_to_router(initial_switch)
        if not path:
            return False, "No path found to router", [], {}

        # Verify each device in path
        results = {}
        overall_success = True
        failure_reasons = []
        
        for i, device_ip in enumerate(path):
            logger.info(f"Verifying device {i+1}/{len(path)}: {device_ip}")
            
            result = DeviceResult(device_ip=device_ip, vlan_status="Unknown")
            
            # Check VLAN exists
            vlan_exists = self.nr.filter(name=device_ip).run(
                task=self.verify_vlan_exists,
                vlan_id=vlan_id
            )[device_ip].result
            
            if vlan_exists:
                result.vlan_status = "VLAN exists"
                logger.debug(f"VLAN {vlan_id} exists on {device_ip}")
            else:
                result.vlan_status = "VLAN missing"
                result.overall_status = VerificationStatus.FAIL
                overall_success = False
                failure_reasons.append(f"VLAN {vlan_id} missing on {device_ip}")
                logger.warning(f"VLAN {vlan_id} missing on {device_ip}")
            
            # First device: check access port
            if i == 0:
                access_ok = self.nr.filter(name=device_ip).run(
                    task=self.verify_access_vlan,
                    interface=target_port,
                    vlan_id=vlan_id
                )[device_ip].result
                
                if access_ok:
                    result.port_status = "Access port configured"
                    logger.debug(f"Access port {target_port} configured on {device_ip}")
                else:
                    result.port_status = f"Port {target_port} not in VLAN {vlan_id}"
                    result.overall_status = VerificationStatus.FAIL
                    overall_success = False
                    failure_reasons.append(f"Port {target_port} not in VLAN {vlan_id}")
                    logger.warning(f"Port {target_port} not in VLAN {vlan_id}")
            
            # Intermediate devices: check trunk ports
            elif i < len(path) - 1:
                next_device = path[i + 1]
                uplink_port = self.nr.filter(name=device_ip).run(
                    task=self.find_uplink_port,
                    neighbor_ip=next_device
                )[device_ip].result
                
                if uplink_port:
                    trunk_ok = self.nr.filter(name=device_ip).run(
                        task=self.verify_trunk_vlan,
                        interface=uplink_port,
                        vlan_id=vlan_id
                    )[device_ip].result
                    
                    if trunk_ok:
                        result.trunk_status = f"Trunk {uplink_port} allows VLAN"
                        logger.debug(f"Trunk {uplink_port} allows VLAN {vlan_id}")
                    else:
                        result.trunk_status = f"VLAN {vlan_id} blocked on {uplink_port}"
                        result.overall_status = VerificationStatus.FAIL
                        overall_success = False
                        failure_reasons.append(f"VLAN {vlan_id} blocked on {uplink_port}")
                        logger.warning(f"VLAN {vlan_id} blocked on {uplink_port}")
                else:
                    result.trunk_status = f"No uplink found to {next_device}"
                    result.overall_status = VerificationStatus.FAIL
                    overall_success = False
                    failure_reasons.append(f"No uplink found to {next_device}")
                    logger.warning(f"No uplink found to {next_device}")
            
            # Router endpoint
            else:
                result.role = "Router endpoint"
                logger.debug(f"Router endpoint: {device_ip}")
            
            # Set overall status if not already failed
            if result.overall_status == VerificationStatus.UNKNOWN:
                result.overall_status = VerificationStatus.PASS
            
            results[device_ip] = result

        # Generate summary message
        if overall_success:
            message = f"VLAN {vlan_id} path fully verified"
        else:
            message = f"VLAN path verification failed: {'; '.join(failure_reasons[:3])}"
        
        logger.info(f"Verification complete: {message}")
        return overall_success, message, path, results

    def visualize_path(self, path: List[str], verification_results: Dict[str, DeviceResult]):
        """Create enhanced visualization of the network path"""
        plt.ioff()
        fig, ax = plt.subplots(figsize=(18, 12))
        
        # Create graph
        G = nx.path_graph(path)
        
        # Position nodes
        pos = {node: (i * 3, 0) for i, node in enumerate(G.nodes())}
        
        # Prepare node colors and labels
        node_colors = []
        node_labels = {}
        status_labels = {}
        
        for node in G.nodes():
            result = verification_results.get(node)
            if not result:
                node_colors.append("gray")
                status_labels[node] = "No data"
                continue
            
            # Determine color based on status
            if result.overall_status == VerificationStatus.PASS:
                node_colors.append("lightgreen")
                status = "✓ PASS"
            elif result.overall_status == VerificationStatus.FAIL:
                node_colors.append("red")
                status = "✗ FAIL"
            else:
                node_colors.append("gray")
                status = "? UNKNOWN"
            
            # Create node label
            node_labels[node] = node
            
            # Create status label
            status_lines = [f"Status: {status}"]
            
            if result.vlan_status:
                status_lines.append(f"VLAN: {result.vlan_status}")
            
            if result.port_status:
                status_lines.append(f"Port: {result.port_status}")
            
            if result.trunk_status:
                status_lines.append(f"Trunk: {result.trunk_status}")
            
            if result.role:
                status_lines.append(f"Role: {result.role}")
            
            status_labels[node] = "\n".join(status_lines[:4])  # Limit to 4 lines
        
        # Draw network graph
        nx.draw_networkx_nodes(G, pos, node_color=node_colors, node_size=5000, 
                              edgecolors='black', linewidths=2)
        nx.draw_networkx_edges(G, pos, width=3, edge_color='steelblue', 
                              arrows=True, arrowstyle='-|>', arrowsize=30)
        
        # Add device labels (above nodes)
        name_pos = {k: (v[0], v[1] + 0.8) for k, v in pos.items()}
        nx.draw_networkx_labels(G, name_pos, labels=node_labels, font_size=10, 
                               font_weight="bold")
        
        # Add status labels (below nodes)
        status_pos = {k: (v[0], v[1] - 1.2) for k, v in pos.items()}
        nx.draw_networkx_labels(G, status_pos, labels=status_labels, font_size=8,
                               bbox=dict(facecolor='white', edgecolor='black',
                                       boxstyle='round,pad=0.5', alpha=0.9))
        
        # Add legend
        legend_elements = [
            plt.Line2D([0], [0], marker='o', color='w', label='Pass', 
                      markerfacecolor='lightgreen', markersize=15),
            plt.Line2D([0], [0], marker='o', color='w', label='Fail', 
                      markerfacecolor='red', markersize=15),
            plt.Line2D([0], [0], marker='o', color='w', label='Unknown', 
                      markerfacecolor='gray', markersize=15)
        ]
        
        plt.legend(handles=legend_elements, loc='upper right', fontsize=12, 
                  title="Verification Status", title_fontsize=14)
        
        plt.title("Network VLAN Path Verification Results", pad=40, fontsize=18, 
                 fontweight='bold')
        plt.axis('off')
        plt.tight_layout()
        plt.show(block=True)
        plt.ion()


def main():
    """Main function to run VLAN path verification"""
    # Configuration
    initial_switch = "172.17.57.243"
    target_port = "GigabitEthernet1/0/10"
    vlan_id = "5"
    
    # Create verifier instance
    verifier = NetworkVerifier(config_file="config.yaml")
    
    try:
        # Run verification
        success, message, path, results = verifier.verify_vlan_path(
            initial_switch, target_port, vlan_id
        )
        
        # Print results
        print("\n" + "="*60)
        print(f"VLAN PATH VERIFICATION {'SUCCEEDED' if success else 'FAILED'}")
        print("="*60)
        print(f"Initial Switch: {initial_switch}")
        print(f"Target Port: {target_port}")
        print(f"VLAN ID: {vlan_id}")
        print(f"Path: {' → '.join(path)}")
        print(f"Status: {message}")
        print("="*60)
        
        # Detailed results
        print("\nDETAILED RESULTS:")
        print("-" * 40)
        for device_ip, result in results.items():
            print(f"\nDevice: {device_ip}")
            print(f"  Overall Status: {result.overall_status.value.upper()}")
            print(f"  VLAN Status: {result.vlan_status}")
            if result.port_status:
                print(f"  Port Status: {result.port_status}")
            if result.trunk_status:
                print(f"  Trunk Status: {result.trunk_status}")
            if result.role:
                print(f"  Role: {result.role}")
        
        # Show visualization
        if path and results:
            print("\nGenerating network visualization...")
            verifier.visualize_path(path, results)
        
        return success
        
    except Exception as e:
        logger.error(f"Verification failed with error: {str(e)}")
        print(f"\nERROR: Verification failed - {str(e)}")
        return False
    
    finally:
        # Cleanup
        if hasattr(verifier, 'nr') and verifier.nr:
            verifier.nr.close_connections()


if __name__ == "__main__":
    import sys
    
    # Allow command line arguments
    if len(sys.argv) >= 4:
        initial_switch = sys.argv[1]
        target_port = sys.argv[2]
        vlan_id = sys.argv[3]
        
        verifier = NetworkVerifier()
        success, message, path, results = verifier.verify_vlan_path(
            initial_switch, target_port, vlan_id
        )
        
        if success:
            print(f"✓ VLAN {vlan_id} path verification successful")
            sys.exit(0)
        else:
            print(f"✗ VLAN {vlan_id} path verification failed: {message}")
            sys.exit(1)
    else:
        # Use default configuration
        success = main()
        sys.exit(0 if success else 1)✔ VLAN {vlan_id} reached router {target_router}"
from nornir import InitNornir
from nornir_netmiko import netmiko_send_command
from nornir.core.task import Task, Result
from typing import Dict, List, Tuple, Optional, Set
import networkx as nx
import matplotlib.pyplot as plt
import re
import logging
from dataclasses import dataclass
from enum import Enum

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class VerificationStatus(Enum):
    PASS = "pass"
    FAIL = "fail"
    UNKNOWN = "unknown"

@dataclass
class DeviceResult:
    device_ip: str
    vlan_status: str
    port_status: Optional[str] = None
    trunk_status: Optional[str] = None
    role: Optional[str] = None
    overall_status: VerificationStatus = VerificationStatus.UNKNOWN

class NetworkVerifier:
    def __init__(self, config_file: str = "config.yaml"):
        self.nr = InitNornir(config_file=config_file)
        self.max_hops = 15
        
    def get_lldp_neighbors(self, task: Task) -> List[Dict]:
        """Collect LLDP neighbor information in a vendor-neutral way"""
        platform = task.host.platform
        
        # Enhanced command mapping for different platforms
        command_map = {
            "aruba_cx": "show lldp neighbors detail",
            "cisco_ios": "show lldp neighbors detail",
            "cisco_xe": "show lldp neighbors detail",
            "hp_comware": "display lldp neighbor-information",
            "juniper": "show lldp neighbors detail"
        }
        
        command = command_map.get(platform, "show lldp neighbors detail")
        
        logger.debug(f"Running on {task.host}: {command}")
        
        try:
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            # Handle different result types
            if isinstance(result.result, str):
                logger.warning(f"TextFSM parsing failed for {task.host}, attempting manual parsing")
                return self._parse_lldp_manually(result.result, platform)
            elif isinstance(result.result, dict):
                return [result.result]
            elif isinstance(result.result, list):
                return result.result
            else:
                logger.warning(f"No LLDP neighbors found on {task.host}")
                return []
                
        except Exception as e:
            logger.error(f"Error getting LLDP neighbors on {task.host}: {str(e)}")
            return []

    def _parse_lldp_manually(self, output: str, platform: str) -> List[Dict]:
        """Manual parsing fallback for when TextFSM fails"""
        neighbors = []
        
        try:
            # Basic regex patterns for common LLDP output formats
            if platform == "cisco_ios":
                # Cisco IOS LLDP format
                pattern = r'Device ID: (\S+).*?Local Intf: (\S+).*?Port id: (\S+)'
                matches = re.findall(pattern, output, re.DOTALL)
                
                for match in matches:
                    neighbors.append({
                        'neighbor': match[0],
                        'local_interface': match[1],
                        'neighbor_port': match[2]
                    })
            
            # Add more platform-specific parsing as needed
            
        except Exception as e:
            logger.error(f"Manual LLDP parsing failed: {str(e)}")
            
        return neighbors

    def find_uplink_port(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find the local interface connected to a neighbor with improved error handling"""
        platform = task.host.platform
        
        try:
            # Try LLDP first (most reliable)
            lldp_result = self._find_port_via_lldp(task, neighbor_ip, platform)
            if lldp_result:
                return lldp_result
            
            # Fall back to CDP for Cisco devices
            if platform.startswith("cisco"):
                cdp_result = self._find_port_via_cdp(task, neighbor_ip)
                if cdp_result:
                    return cdp_result
                    
            # Last resort: MAC address table lookup
            mac_result = self._find_port_via_mac(task, neighbor_ip)
            if mac_result:
                return mac_result
                
        except Exception as e:
            logger.error(f"Error finding uplink port on {task.host}: {str(e)}")
        
        return None

    def _find_port_via_lldp(self, task: Task, neighbor_ip: str, platform: str) -> Optional[str]:
        """Find port using LLDP"""
        try:
            neighbors = self.get_lldp_neighbors(task)
            
            for neighbor in neighbors:
                # Check multiple possible neighbor identifier fields
                neighbor_id = (neighbor.get('neighbor') or 
                             neighbor.get('mgmt_address') or 
                             neighbor.get('system_name'))
                
                if neighbor_id and (neighbor_id == neighbor_ip or 
                                  neighbor_id.startswith(neighbor_ip.split('.')[0])):
                    return neighbor.get('local_interface')
                    
        except Exception as e:
            logger.debug(f"LLDP port lookup failed: {str(e)}")
            
        return None

    def _find_port_via_cdp(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find port using CDP (Cisco devices)"""
        try:
            command = "show cdp neighbors detail"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if result.result:
                for neighbor in (result.result if isinstance(result.result, list) else [result.result]):
                    if neighbor.get('mgmt_address') == neighbor_ip:
                        return neighbor.get('local_port')
                        
        except Exception as e:
            logger.debug(f"CDP port lookup failed: {str(e)}")
            
        return None

    def _find_port_via_mac(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find port using MAC address table (least reliable)"""
        try:
            # This would require ARP table lookup first, then MAC table
            # Implementation depends on specific requirements
            pass
        except Exception as e:
            logger.debug(f"MAC table port lookup failed: {str(e)}")
            
        return None

    def verify_vlan_exists(self, task: Task, vlan_id: str) -> bool:
        """Check if VLAN exists with enhanced platform support"""
        platform = task.host.platform
        
        command_map = {
            "aruba_cx": f"show vlan {vlan_id}",
            "cisco_ios": f"show vlan id {vlan_id}",
            "cisco_xe": f"show vlan id {vlan_id}",
            "hp_comware": f"display vlan {vlan_id}",
            "juniper": f"show vlans {vlan_id}"
        }
        
        command = command_map.get(platform, f"show vlan id {vlan_id}")
        
        try:
            logger.debug(f"Running on {task.host}: {command}")
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if isinstance(result.result, str):
                # Check for common error messages
                error_indicators = ["invalid", "not found", "does not exist", "error"]
                return not any(indicator in result.result.lower() for indicator in error_indicators)
            
            return bool(result.result)
            
        except Exception as e:
            logger.error(f"Error checking VLAN on {task.host}: {str(e)}")
            return False

    def verify_access_vlan(self, task: Task, interface: str, vlan_id: str) -> bool:
        """Verify access port VLAN configuration with better error handling"""
        platform = task.host.platform
        
        try:
            # Method 1: Check VLAN membership
            if self._check_vlan_membership(task, interface, vlan_id, platform):
                return True
            
            # Method 2: Check interface configuration
            if self._check_interface_config(task, interface, vlan_id, platform):
                return True
            
            logger.debug(f"Access VLAN {vlan_id} not found on {interface}")
            return False
            
        except Exception as e:
            logger.error(f"Error checking access port on {task.host}: {str(e)}")
            return False

    def _check_vlan_membership(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check VLAN membership tables"""
        try:
            command_map = {
                "aruba_cx": f"show vlan {vlan_id}",
                "cisco_ios": f"show vlan id {vlan_id}",
                "cisco_xe": f"show vlan id {vlan_id}",
            }
            
            command = command_map.get(platform, f"show vlan id {vlan_id}")
            
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if result.result:
                for vlan in (result.result if isinstance(result.result, list) else [result.result]):
                    interfaces = vlan.get('interfaces', [])
                    if isinstance(interfaces, str):
                        interfaces = [interfaces]
                    
                    # Normalize interface names for comparison
                    normalized_interfaces = [self._normalize_interface_name(intf) for intf in interfaces]
                    normalized_target = self._normalize_interface_name(interface)
                    
                    if normalized_target in normalized_interfaces:
                        return True
                        
        except Exception as e:
            logger.debug(f"VLAN membership check failed: {str(e)}")
            
        return False

    def _check_interface_config(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check interface running configuration"""
        try:
            command = f"show running-config interface {interface}"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=False,
                enable=True
            )
            
            config = result.result.lower()
            
            # Platform-specific config patterns
            patterns = {
                "aruba_cx": [f"vlan access {vlan_id}"],
                "cisco_ios": [f"switchport access vlan {vlan_id}"],
                "cisco_xe": [f"switchport access vlan {vlan_id}"],
            }
            
            check_patterns = patterns.get(platform, [f"switchport access vlan {vlan_id}"])
            
            return any(pattern in config for pattern in check_patterns)
            
        except Exception as e:
            logger.debug(f"Interface config check failed: {str(e)}")
            
        return False

    def _normalize_interface_name(self, interface: str) -> str:
        """Normalize interface names for comparison"""
        # Handle common abbreviations
        interface = interface.replace("GigabitEthernet", "Gi")
        interface = interface.replace("FastEthernet", "Fa")
        interface = interface.replace("TenGigabitEthernet", "Te")
        
        # Remove spaces and convert to lowercase
        return interface.replace(" ", "").lower()

    def verify_trunk_vlan(self, task: Task, interface: str, vlan_id: str) -> bool:
        """Verify trunk allows the VLAN with comprehensive checking"""
        platform = task.host.platform
        
        try:
            # Method 1: Check switchport status
            if self._check_switchport_trunk(task, interface, vlan_id, platform):
                return True
            
            # Method 2: Check running configuration
            if self._check_trunk_config(task, interface, vlan_id, platform):
                return True
            
            return False
            
        except Exception as e:
            logger.error(f"Error checking trunk on {task.host}: {str(e)}")
            return False

    def _check_switchport_trunk(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check switchport trunk status"""
        try:
            command = f"show interfaces {interface} switchport"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if isinstance(result.result, str):
                # Parse raw output
                return self._parse_trunk_raw_output(result.result, vlan_id)
            
            if result.result and isinstance(result.result, list):
                sw_data = result.result[0]
                
                # Check if port is in trunk mode
                if sw_data.get('mode', '').lower() != 'trunk':
                    return False
                
                # Check allowed VLANs
                return self._check_allowed_vlans(sw_data, vlan_id)
                
        except Exception as e:
            logger.debug(f"Switchport trunk check failed: {str(e)}")
            
        return False

    def _parse_trunk_raw_output(self, output: str, vlan_id: str) -> bool:
        """Parse raw switchport output"""
        output_lower = output.lower()
        
        if "trunking" in output_lower:
            if "vlans allowed: all" in output_lower:
                return True
            if f"vlans allowed: {vlan_id}" in output_lower:
                return True
        
        return False

    def _check_allowed_vlans(self, switchport_data: Dict, vlan_id: str) -> bool:
        """Check if VLAN is in allowed VLAN list"""
        for field in ['trunking_vlans', 'vlans_allowed', 'allowed_vlans']:
            vlans = switchport_data.get(field, '')
            
            if vlans:
                if vlans.upper() == 'ALL':
                    return True
                if self._is_vlan_in_list(vlans, vlan_id):
                    return True
        
        return False

    def _check_trunk_config(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check trunk configuration in running config"""
        try:
            command = f"show running-config interface {interface}"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                enable=True
            )
            
            config = result.result.lower()
            
            # If trunk mode is configured but no allowed VLAN restrictions, assume all VLANs allowed
            if "switchport mode trunk" in config and "switchport trunk allowed vlan" not in config:
                return True
            
            # Check specific VLAN allowances
            if f"switchport trunk allowed vlan add {vlan_id}" in config:
                return True
            
            return False
            
        except Exception as e:
            logger.debug(f"Trunk config check failed: {str(e)}")
            
        return False

    def _is_vlan_in_list(self, vlan_str: str, target_vlan: str) -> bool:
        """Helper to safely parse VLAN lists (1,5,10-20,30)"""
        try:
            if not vlan_str:
                return False
                
            target_int = int(target_vlan)
            
            for part in str(vlan_str).split(','):
                part = part.strip()
                
                if '-' in part:
                    # Handle range (e.g., "10-20")
                    start, end = map(int, part.split('-'))
                    if start <= target_int <= end:
                        return True
                elif part.isdigit() and int(part) == target_int:
                    return True
                    
            return False
            
        except (ValueError, AttributeError) as e:
            logger.error(f"VLAN list parsing failed: {str(e)}")
            return False

    def trace_path_to_router(self, start_device: str) -> List[str]:
        """Trace path from edge switch to router using LLDP with improved logic"""
        logger.info("Starting path trace to router...")
        
        path = []
        current_device = start_device
        visited: Set[str] = set()
        
        # Get target router
        try:
            target_router = self.nr.inventory.hosts[start_device].data.get('router')
            if not target_router:
                logger.error(f"No router defined for {start_device}")
                return []
        except KeyError:
            logger.error(f"Device {start_device} not found in inventory")
            return []

        logger.info(f"Target router: {target_router}")

        while current_device and current_device not in visited and len(path) < self.max_hops:
            visited.add(current_device)
            path.append(current_device)
            
            logger.debug(f"Current device: {current_device}")
            logger.debug(f"Current path: {' -> '.join(path)}")
            
            # Check if we've reached the target router
            if current_device == target_router:
                logger.info(f"Reached target router: {current_device}")
                break
            
            # Get neighbors and find next hop
            next_hop = self._find_next_hop(current_device, target_router, visited)
            if not next_hop:
                logger.warning(f"No valid next hop found from {current_device}")
                break
                
            current_device = next_hop

        # Ensure router is in path
        if path and path[-1] != target_router:
            path.append(target_router)
            logger.debug(f"Added router {target_router} to path")

        logger.info(f"Final path: {' -> '.join(path)}")
        return path

    def _find_next_hop(self, current_device: str, target_router: str, visited: Set[str]) -> Optional[str]:
        """Find the next hop in the path"""
        try:
            neighbors_result = self.nr.filter(name=current_device).run(task=self.get_lldp_neighbors)
            neighbors = neighbors_result[current_device].result
            
            if not neighbors:
                logger.debug(f"No neighbors found for {current_device}")
                return None
            
            # Find unvisited neighbors
            possible_hops = []
            for neighbor in (neighbors if isinstance(neighbors, list) else [neighbors]):
                if isinstance(neighbor, dict):
                    neighbor_ip = self._extract_neighbor_ip(neighbor)
                    
                    if neighbor_ip and neighbor_ip not in visited:
                        # Try to resolve to inventory hostname
                        resolved_ip = self._resolve_neighbor_ip(neighbor_ip)
                        if resolved_ip:
                            possible_hops.append(resolved_ip)
            
            if not possible_hops:
                return None
            
            # Prioritize direct connection to router
            if target_router in possible_hops:
                return target_router
            
            # Prioritize devices that have the target router configured
            for hop in possible_hops:
                try:
                    if self.nr.inventory.hosts[hop].data.get('router') == target_router:
                        return hop
                except KeyError:
                    continue
            
            # Return first available hop
            return possible_hops[0]
            
        except Exception as e:
            logger.error(f"Error finding next hop from {current_device}: {str(e)}")
            return None

    def _extract_neighbor_ip(self, neighbor: Dict) -> Optional[str]:
        """Extract neighbor IP from LLDP data"""
        neighbor_ip = (neighbor.get('mgmt_address') or 
                      neighbor.get('neighbor') or 
                      neighbor.get('neighbor_name') or
                      neighbor.get('system_name'))
        
        if neighbor_ip and '.' not in neighbor_ip:
            # Handle hostname format
            neighbor_ip = neighbor_ip.split('.')[0]
        
        return neighbor_ip

    def _resolve_neighbor_ip(self, neighbor_ip: str) -> Optional[str]:
        """Resolve neighbor IP to inventory hostname"""
        # Direct match
        if neighbor_ip in self.nr.inventory.hosts:
            return neighbor_ip
        
        # Hostname match
        for hostname, host in self.nr.inventory.hosts.items():
            if (host.get('hostname', '') == neighbor_ip or 
                hostname.startswith(neighbor_ip)):
                return hostname
        
        return None

    def verify_vlan_path(self, initial_switch: str, target_port: str, vlan_id: str) -> Tuple[bool, str, List[str], Dict[str, DeviceResult]]:
        """Comprehensive VLAN path verification"""
        logger.info("Starting VLAN path verification")
        
        # Trace path
        path = self.trace_path_to_router(initial_switch)
        if not path:
            return False, "No path found to router", [], {}

        # Verify each device in path
        results = {}
        overall_success = True
        failure_reasons = []
        
        for i, device_ip in enumerate(path):
            logger.info(f"Verifying device {i+1}/{len(path)}: {device_ip}")
            
            result = DeviceResult(device_ip=device_ip, vlan_status="Unknown")
            
            # Check VLAN exists
            vlan_exists = self.nr.filter(name=device_ip).run(
                task=self.verify_vlan_exists,
                vlan_id=vlan_id
            )[device_ip].result
            
            if vlan_exists:
                result.vlan_status = "VLAN exists"
                logger.debug(f"VLAN {vlan_id} exists on {device_ip}")
            else:
                result.vlan_status = "VLAN missing"
                result.overall_status = VerificationStatus.FAIL
                overall_success = False
                failure_reasons.append(f"VLAN {vlan_id} missing on {device_ip}")
                logger.warning(f"VLAN {vlan_id} missing on {device_ip}")
            
            # First device: check access port
            if i == 0:
                access_ok = self.nr.filter(name=device_ip).run(
                    task=self.verify_access_vlan,
                    interface=target_port,
                    vlan_id=vlan_id
                )[device_ip].result
                
                if access_ok:
                    result.port_status = "Access port configured"
                    logger.debug(f"Access port {target_port} configured on {device_ip}")
                else:
                    result.port_status = f"Port {target_port} not in VLAN {vlan_id}"
                    result.overall_status = VerificationStatus.FAIL
                    overall_success = False
                    failure_reasons.append(f"Port {target_port} not in VLAN {vlan_id}")
                    logger.warning(f"Port {target_port} not in VLAN {vlan_id}")
            
            # Intermediate devices: check trunk ports
            elif i < len(path) - 1:
                next_device = path[i + 1]
                uplink_port = self.nr.filter(name=device_ip).run(
                    task=self.find_uplink_port,
                    neighbor_ip=next_device
                )[device_ip].result
                
                if uplink_port:
                    trunk_ok = self.nr.filter(name=device_ip).run(
                        task=self.verify_trunk_vlan,
                        interface=uplink_port,
                        vlan_id=vlan_id
                    )[device_ip].result
                    
                    if trunk_ok:
                        result.trunk_status = f"Trunk {uplink_port} allows VLAN"
                        logger.debug(f"Trunk {uplink_port} allows VLAN {vlan_id}")
                    else:
                        result.trunk_status = f"VLAN {vlan_id} blocked on {uplink_port}"
                        result.overall_status = VerificationStatus.FAIL
                        overall_success = False
                        failure_reasons.append(f"VLAN {vlan_id} blocked on {uplink_port}")
                        logger.warning(f"VLAN {vlan_id} blocked on {uplink_port}")
                else:
                    result.trunk_status = f"No uplink found to {next_device}"
                    result.overall_status = VerificationStatus.FAIL
                    overall_success = False
                    failure_reasons.append(f"No uplink found to {next_device}")
                    logger.warning(f"No uplink found to {next_device}")
            
            # Router endpoint
            else:
                result.role = "Router endpoint"
                logger.debug(f"Router endpoint: {device_ip}")
            
            # Set overall status if not already failed
            if result.overall_status == VerificationStatus.UNKNOWN:
                result.overall_status = VerificationStatus.PASS
            
            results[device_ip] = result

        # Generate summary message
        if overall_success:
            message = f"VLAN {vlan_id} path fully verified"
        else:
            message = f"VLAN path verification failed: {'; '.join(failure_reasons[:3])}"
        
        logger.info(f"Verification complete: {message}")
        return overall_success, message, path, results

    def visualize_path(self, path: List[str], verification_results: Dict[str, DeviceResult]):
        """Create enhanced visualization of the network path"""
        plt.ioff()
        fig, ax = plt.subplots(figsize=(18, 12))
        
        # Create graph
        G = nx.path_graph(path)
        
        # Position nodes
        pos = {node: (i * 3, 0) for i, node in enumerate(G.nodes())}
        
        # Prepare node colors and labels
        node_colors = []
        node_labels = {}
        status_labels = {}
        
        for node in G.nodes():
            result = verification_results.get(node)
            if not result:
                node_colors.append("gray")
                status_labels[node] = "No data"
                continue
            
            # Determine color based on status
            if result.overall_status == VerificationStatus.PASS:
                node_colors.append("lightgreen")
                status = "✓ PASS"
            elif result.overall_status == VerificationStatus.FAIL:
                node_colors.append("red")
                status = "✗ FAIL"
            else:
                node_colors.append("gray")
                status = "? UNKNOWN"
            
            # Create node label
            node_labels[node] = node
            
            # Create status label
            status_lines = [f"Status: {status}"]
            
            if result.vlan_status:
                status_lines.append(f"VLAN: {result.vlan_status}")
            
            if result.port_status:
                status_lines.append(f"Port: {result.port_status}")
            
            if result.trunk_status:
                status_lines.append(f"Trunk: {result.trunk_status}")
            
            if result.role:
                status_lines.append(f"Role: {result.role}")
            
            status_labels[node] = "\n".join(status_lines[:4])  # Limit to 4 lines
        
        # Draw network graph
        nx.draw_networkx_nodes(G, pos, node_color=node_colors, node_size=5000, 
                              edgecolors='black', linewidths=2)
        nx.draw_networkx_edges(G, pos, width=3, edge_color='steelblue', 
                              arrows=True, arrowstyle='-|>', arrowsize=30)
        
        # Add device labels (above nodes)
        name_pos = {k: (v[0], v[1] + 0.8) for k, v in pos.items()}
        nx.draw_networkx_labels(G, name_pos, labels=node_labels, font_size=10, 
                               font_weight="bold")
        
        # Add status labels (below nodes)
        status_pos = {k: (v[0], v[1] - 1.2) for k, v in pos.items()}
        nx.draw_networkx_labels(G, status_pos, labels=status_labels, font_size=8,
                               bbox=dict(facecolor='white', edgecolor='black',
                                       boxstyle='round,pad=0.5', alpha=0.9))
        
        # Add legend
        legend_elements = [
            plt.Line2D([0], [0], marker='o', color='w', label='Pass', 
                      markerfacecolor='lightgreen', markersize=15),
            plt.Line2D([0], [0], marker='o', color='w', label='Fail', 
                      markerfacecolor='red', markersize=15),
            plt.Line2D([0], [0], marker='o', color='w', label='Unknown', 
                      markerfacecolor='gray', markersize=15)
        ]
        
        plt.legend(handles=legend_elements, loc='upper right', fontsize=12, 
                  title="Verification Status", title_fontsize=14)
        
        plt.title("Network VLAN Path Verification Results", pad=40, fontsize=18, 
                 fontweight='bold')
        plt.axis('off')
        plt.tight_layout()
        plt.show(block=True)
        plt.ion()


def main():
    """Main function to run VLAN path verification"""
    # Configuration
    initial_switch = "172.17.57.243"
    target_port = "GigabitEthernet1/0/10"
    vlan_id = "5"
    
    # Create verifier instance
    verifier = NetworkVerifier(config_file="config.yaml")
    
    try:
        # Run verification
        success, message, path, results = verifier.verify_vlan_path(
            initial_switch, target_port, vlan_id
        )
        
        # Print results
        print("\n" + "="*60)
        print(f"VLAN PATH VERIFICATION {'SUCCEEDED' if success else 'FAILED'}")
        print("="*60)
        print(f"Initial Switch: {initial_switch}")
        print(f"Target Port: {target_port}")
        print(f"VLAN ID: {vlan_id}")
        print(f"Path: {' → '.join(path)}")
        print(f"Status: {message}")
        print("="*60)
        
        # Detailed results
        print("\nDETAILED RESULTS:")
        print("-" * 40)
        for device_ip, result in results.items():
            print(f"\nDevice: {device_ip}")
            print(f"  Overall Status: {result.overall_status.value.upper()}")
            print(f"  VLAN Status: {result.vlan_status}")
            if result.port_status:
                print(f"  Port Status: {result.port_status}")
            if result.trunk_status:
                print(f"  Trunk Status: {result.trunk_status}")
            if result.role:
                print(f"  Role: {result.role}")
        
        # Show visualization
        if path and results:
            print("\nGenerating network visualization...")
            verifier.visualize_path(path, results)
        
        return success
        
    except Exception as e:
        logger.error(f"Verification failed with error: {str(e)}")
        print(f"\nERROR: Verification failed - {str(e)}")
        return False
    
    finally:
        # Cleanup
        if hasattr(verifier, 'nr') and verifier.nr:
            verifier.nr.close_connections()


if __name__ == "__main__":
    import sys
    
    # Allow command line arguments
    if len(sys.argv) >= 4:
        initial_switch = sys.argv[1]
        target_port = sys.argv[2]
        vlan_id = sys.argv[3]
        
        verifier = NetworkVerifier()
        success, message, path, results = verifier.verify_vlan_path(
            initial_switch, target_port, vlan_id
        )
        
        if success:
            print(f"✓ VLAN {vlan_id} path verification successful")
            sys.exit(0)
        else:
            print(f"✗ VLAN {vlan_id} path verification failed: {message}")
            sys.exit(1)
    else:
        # Use default configuration
        success = main()
        sys.exit(0 if success else 1)
from nornir import InitNornir
from nornir_netmiko import netmiko_send_command
from nornir.core.task import Task, Result
from typing import Dict, List, Tuple, Optional, Set
import networkx as nx
import matplotlib.pyplot as plt
import re
import logging
from dataclasses import dataclass
from enum import Enum

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class VerificationStatus(Enum):
    PASS = "pass"
    FAIL = "fail"
    UNKNOWN = "unknown"

@dataclass
class DeviceResult:
    device_ip: str
    vlan_status: str
    port_status: Optional[str] = None
    trunk_status: Optional[str] = None
    role: Optional[str] = None
    overall_status: VerificationStatus = VerificationStatus.UNKNOWN

class NetworkVerifier:
    def __init__(self, config_file: str = "config.yaml"):
        self.nr = InitNornir(config_file=config_file)
        self.max_hops = 15
        
    def get_lldp_neighbors(self, task: Task) -> List[Dict]:
        """Collect LLDP neighbor information in a vendor-neutral way"""
        platform = task.host.platform
        
        # Enhanced command mapping for different platforms
        command_map = {
            "aruba_cx": "show lldp neighbors detail",
            "cisco_ios": "show lldp neighbors detail",
            "cisco_xe": "show lldp neighbors detail",
            "hp_comware": "display lldp neighbor-information",
            "juniper": "show lldp neighbors detail"
        }
        
        command = command_map.get(platform, "show lldp neighbors detail")
        
        logger.debug(f"Running on {task.host}: {command}")
        
        try:
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            # Handle different result types
            if isinstance(result.result, str):
                logger.warning(f"TextFSM parsing failed for {task.host}, attempting manual parsing")
                return self._parse_lldp_manually(result.result, platform)
            elif isinstance(result.result, dict):
                return [result.result]
            elif isinstance(result.result, list):
                return result.result
            else:
                logger.warning(f"No LLDP neighbors found on {task.host}")
                return []
                
        except Exception as e:
            logger.error(f"Error getting LLDP neighbors on {task.host}: {str(e)}")
            return []

    def _parse_lldp_manually(self, output: str, platform: str) -> List[Dict]:
        """Manual parsing fallback for when TextFSM fails"""
        neighbors = []
        
        try:
            # Basic regex patterns for common LLDP output formats
            if platform == "cisco_ios":
                # Cisco IOS LLDP format
                pattern = r'Device ID: (\S+).*?Local Intf: (\S+).*?Port id: (\S+)'
                matches = re.findall(pattern, output, re.DOTALL)
                
                for match in matches:
                    neighbors.append({
                        'neighbor': match[0],
                        'local_interface': match[1],
                        'neighbor_port': match[2]
                    })
            
            # Add more platform-specific parsing as needed
            
        except Exception as e:
            logger.error(f"Manual LLDP parsing failed: {str(e)}")
            
        return neighbors

    def find_uplink_port(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find the local interface connected to a neighbor with improved error handling"""
        platform = task.host.platform
        
        try:
            # Try LLDP first (most reliable)
            lldp_result = self._find_port_via_lldp(task, neighbor_ip, platform)
            if lldp_result:
                return lldp_result
            
            # Fall back to CDP for Cisco devices
            if platform.startswith("cisco"):
                cdp_result = self._find_port_via_cdp(task, neighbor_ip)
                if cdp_result:
                    return cdp_result
                    
            # Last resort: MAC address table lookup
            mac_result = self._find_port_via_mac(task, neighbor_ip)
            if mac_result:
                return mac_result
                
        except Exception as e:
            logger.error(f"Error finding uplink port on {task.host}: {str(e)}")
        
        return None

    def _find_port_via_lldp(self, task: Task, neighbor_ip: str, platform: str) -> Optional[str]:
        """Find port using LLDP"""
        try:
            neighbors = self.get_lldp_neighbors(task)
            
            for neighbor in neighbors:
                # Check multiple possible neighbor identifier fields
                neighbor_id = (neighbor.get('neighbor') or 
                             neighbor.get('mgmt_address') or 
                             neighbor.get('system_name'))
                
                if neighbor_id and (neighbor_id == neighbor_ip or 
                                  neighbor_id.startswith(neighbor_ip.split('.')[0])):
                    return neighbor.get('local_interface')
                    
        except Exception as e:
            logger.debug(f"LLDP port lookup failed: {str(e)}")
            
        return None

    def _find_port_via_cdp(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find port using CDP (Cisco devices)"""
        try:
            command = "show cdp neighbors detail"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if result.result:
                for neighbor in (result.result if isinstance(result.result, list) else [result.result]):
                    if neighbor.get('mgmt_address') == neighbor_ip:
                        return neighbor.get('local_port')
                        
        except Exception as e:
            logger.debug(f"CDP port lookup failed: {str(e)}")
            
        return None

    def _find_port_via_mac(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find port using MAC address table (least reliable)"""
        try:
            # This would require ARP table lookup first, then MAC table
            # Implementation depends on specific requirements
            pass
        except Exception as e:
            logger.debug(f"MAC table port lookup failed: {str(e)}")
            
        return None

    def verify_vlan_exists(self, task: Task, vlan_id: str) -> bool:
        """Check if VLAN exists with enhanced platform support"""
        platform = task.host.platform
        
        command_map = {
            "aruba_cx": f"show vlan {vlan_id}",
            "cisco_ios": f"show vlan id {vlan_id}",
            "cisco_xe": f"show vlan id {vlan_id}",
            "hp_comware": f"display vlan {vlan_id}",
            "juniper": f"show vlans {vlan_id}"
        }
        
        command = command_map.get(platform, f"show vlan id {vlan_id}")
        
        try:
            logger.debug(f"Running on {task.host}: {command}")
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if isinstance(result.result, str):
                # Check for common error messages
                error_indicators = ["invalid", "not found", "does not exist", "error"]
                return not any(indicator in result.result.lower() for indicator in error_indicators)
            
            return bool(result.result)
            
        except Exception as e:
            logger.error(f"Error checking VLAN on {task.host}: {str(e)}")
            return False

    def verify_access_vlan(self, task: Task, interface: str, vlan_id: str) -> bool:
        """Verify access port VLAN configuration with better error handling"""
        platform = task.host.platform
        
        try:
            # Method 1: Check VLAN membership
            if self._check_vlan_membership(task, interface, vlan_id, platform):
                return True
            
            # Method 2: Check interface configuration
            if self._check_interface_config(task, interface, vlan_id, platform):
                return True
            
            logger.debug(f"Access VLAN {vlan_id} not found on {interface}")
            return False
            
        except Exception as e:
            logger.error(f"Error checking access port on {task.host}: {str(e)}")
            return False

    def _check_vlan_membership(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check VLAN membership tables"""
        try:
            command_map = {
                "aruba_cx": f"show vlan {vlan_id}",
                "cisco_ios": f"show vlan id {vlan_id}",
                "cisco_xe": f"show vlan id {vlan_id}",
            }
            
            command = command_map.get(platform, f"show vlan id {vlan_id}")
            
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if result.result:
                for vlan in (result.result if isinstance(result.result, list) else [result.result]):
                    interfaces = vlan.get('interfaces', [])
                    if isinstance(interfaces, str):
                        interfaces = [interfaces]
                    
                    # Normalize interface names for comparison
                    normalized_interfaces = [self._normalize_interface_name(intf) for intf in interfaces]
                    normalized_target = self._normalize_interface_name(interface)
                    
                    if normalized_target in normalized_interfaces:
                        return True
                        
        except Exception as e:
            logger.debug(f"VLAN membership check failed: {str(e)}")
            
        return False

    def _check_interface_config(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check interface running configuration"""
        try:
            command = f"show running-config interface {interface}"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=False,
                enable=True
            )
            
            config = result.result.lower()
            
            # Platform-specific config patterns
            patterns = {
                "aruba_cx": [f"vlan access {vlan_id}"],
                "cisco_ios": [f"switchport access vlan {vlan_id}"],
                "cisco_xe": [f"switchport access vlan {vlan_id}"],
            }
            
            check_patterns = patterns.get(platform, [f"switchport access vlan {vlan_id}"])
            
            return any(pattern in config for pattern in check_patterns)
            
        except Exception as e:
            logger.debug(f"Interface config check failed: {str(e)}")
            
        return False

    def _normalize_interface_name(self, interface: str) -> str:
        """Normalize interface names for comparison"""
        # Handle common abbreviations
        interface = interface.replace("GigabitEthernet", "Gi")
        interface = interface.replace("FastEthernet", "Fa")
        interface = interface.replace("TenGigabitEthernet", "Te")
        
        # Remove spaces and convert to lowercase
        return interface.replace(" ", "").lower()

    def verify_trunk_vlan(self, task: Task, interface: str, vlan_id: str) -> bool:
        """Verify trunk allows the VLAN with comprehensive checking"""
        platform = task.host.platform
        
        try:
            # Method 1: Check switchport status
            if self._check_switchport_trunk(task, interface, vlan_id, platform):
                return True
            
            # Method 2: Check running configuration
            if self._check_trunk_config(task, interface, vlan_id, platform):
                return True
            
            return False
            
        except Exception as e:
            logger.error(f"Error checking trunk on {task.host}: {str(e)}")
            return False

    def _check_switchport_trunk(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check switchport trunk status"""
        try:
            command = f"show interfaces {interface} switchport"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if isinstance(result.result, str):
                # Parse raw output
                return self._parse_trunk_raw_output(result.result, vlan_id)
            
            if result.result and isinstance(result.result, list):
                sw_data = result.result[0]
                
                # Check if port is in trunk mode
                if sw_data.get('mode', '').lower() != 'trunk':
                    return False
                
                # Check allowed VLANs
                return self._check_allowed_vlans(sw_data, vlan_id)
                
        except Exception as e:
            logger.debug(f"Switchport trunk check failed: {str(e)}")
            
        return False

    def _parse_trunk_raw_output(self, output: str, vlan_id: str) -> bool:
        """Parse raw switchport output"""
        output_lower = output.lower()
        
        if "trunking" in output_lower:
            if "vlans allowed: all" in output_lower:
                return True
            if f"vlans allowed: {vlan_id}" in output_lower:
                return True
        
        return False

    def _check_allowed_vlans(self, switchport_data: Dict, vlan_id: str) -> bool:
        """Check if VLAN is in allowed VLAN list"""
        for field in ['trunking_vlans', 'vlans_allowed', 'allowed_vlans']:
            vlans = switchport_data.get(field, '')
            
            if vlans:
                if vlans.upper() == 'ALL':
                    return True
                if self._is_vlan_in_list(vlans, vlan_id):
                    return True
        
        return False

    def _check_trunk_config(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check trunk configuration in running config"""
        try:
            command = f"show running-config interface {interface}"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                enable=True
            )
            
            config = result.result.lower()
            
            # If trunk mode is configured but no allowed VLAN restrictions, assume all VLANs allowed
            if "switchport mode trunk" in config and "switchport trunk allowed vlan" not in config:
                return True
            
            # Check specific VLAN allowances
            if f"switchport trunk allowed vlan add {vlan_id}" in config:
                return True
            
            return False
            
        except Exception as e:
            logger.debug(f"Trunk config check failed: {str(e)}")
            
        return False

    def _is_vlan_in_list(self, vlan_str: str, target_vlan: str) -> bool:
        """Helper to safely parse VLAN lists (1,5,10-20,30)"""
        try:
            if not vlan_str:
                return False
                
            target_int = int(target_vlan)
            
            for part in str(vlan_str).split(','):
                part = part.strip()
                
                if '-' in part:
                    # Handle range (e.g., "10-20")
                    start, end = map(int, part.split('-'))
                    if start <= target_int <= end:
                        return True
                elif part.isdigit() and int(part) == target_int:
                    return True
                    
            return False
            
        except (ValueError, AttributeError) as e:
            logger.error(f"VLAN list parsing failed: {str(e)}")
            return False

    def trace_path_to_router(self, start_device: str) -> List[str]:
        """Trace path from edge switch to router using LLDP with improved logic"""
        logger.info("Starting path trace to router...")
        
        path = []
        current_device = start_device
        visited: Set[str] = set()
        
        # Get target router
        try:
            target_router = self.nr.inventory.hosts[start_device].data.get('router')
            if not target_router:
                logger.error(f"No router defined for {start_device}")
                return []
        except KeyError:
            logger.error(f"Device {start_device} not found in inventory")
            return []

        logger.info(f"Target router: {target_router}")

        while current_device and current_device not in visited and len(path) < self.max_hops:
            visited.add(current_device)
            path.append(current_device)
            
            logger.debug(f"Current device: {current_device}")
            logger.debug(f"Current path: {' -> '.join(path)}")
            
            # Check if we've reached the target router
            if current_device == target_router:
                logger.info(f"Reached target router: {current_device}")
                break
            
            # Get neighbors and find next hop
            next_hop = self._find_next_hop(current_device, target_router, visited)
            if not next_hop:
                logger.warning(f"No valid next hop found from {current_device}")
                break
                
            current_device = next_hop

        # Ensure router is in path
        if path and path[-1] != target_router:
            path.append(target_router)
            logger.debug(f"Added router {target_router} to path")

        logger.info(f"Final path: {' -> '.join(path)}")
        return path

    def _find_next_hop(self, current_device: str, target_router: str, visited: Set[str]) -> Optional[str]:
        """Find the next hop in the path"""
        try:
            neighbors_result = self.nr.filter(name=current_device).run(task=self.get_lldp_neighbors)
            neighbors = neighbors_result[current_device].result
            
            if not neighbors:
                logger.debug(f"No neighbors found for {current_device}")
                return None
            
            # Find unvisited neighbors
            possible_hops = []
            for neighbor in (neighbors if isinstance(neighbors, list) else [neighbors]):
                if isinstance(neighbor, dict):
                    neighbor_ip = self._extract_neighbor_ip(neighbor)
                    
                    if neighbor_ip and neighbor_ip not in visited:
                        # Try to resolve to inventory hostname
                        resolved_ip = self._resolve_neighbor_ip(neighbor_ip)
                        if resolved_ip:
                            possible_hops.append(resolved_ip)
            
            if not possible_hops:
                return None
            
            # Prioritize direct connection to router
            if target_router in possible_hops:
                return target_router
            
            # Prioritize devices that have the target router configured
            for hop in possible_hops:
                try:
                    if self.nr.inventory.hosts[hop].data.get('router') == target_router:
                        return hop
                except KeyError:
                    continue
            
            # Return first available hop
            return possible_hops[0]
            
        except Exception as e:
            logger.error(f"Error finding next hop from {current_device}: {str(e)}")
            return None

    def _extract_neighbor_ip(self, neighbor: Dict) -> Optional[str]:
        """Extract neighbor IP from LLDP data"""
        neighbor_ip = (neighbor.get('mgmt_address') or 
                      neighbor.get('neighbor') or 
                      neighbor.get('neighbor_name') or
                      neighbor.get('system_name'))
        
        if neighbor_ip and '.' not in neighbor_ip:
            # Handle hostname format
            neighbor_ip = neighbor_ip.split('.')[0]
        
        return neighbor_ip

    def _resolve_neighbor_ip(self, neighbor_ip: str) -> Optional[str]:
        """Resolve neighbor IP to inventory hostname"""
        # Direct match
        if neighbor_ip in self.nr.inventory.hosts:
            return neighbor_ip
        
        # Hostname match
        for hostname, host in self.nr.inventory.hosts.items():
            if (host.get('hostname', '') == neighbor_ip or 
                hostname.startswith(neighbor_ip)):
                return hostname
        
        return None

    def verify_vlan_path(self, initial_switch: str, target_port: str, vlan_id: str) -> Tuple[bool, str, List[str], Dict[str, DeviceResult]]:
        """Comprehensive VLAN path verification"""
        logger.info("Starting VLAN path verification")
        
        # Trace path
        path = self.trace_path_to_router(initial_switch)
        if not path:
            return False, "No path found to router", [], {}

        # Verify each device in path
        results = {}
        overall_success = True
        failure_reasons = []
        
        for i, device_ip in enumerate(path):
            logger.info(f"Verifying device {i+1}/{len(path)}: {device_ip}")
            
            result = DeviceResult(device_ip=device_ip, vlan_status="Unknown")
            
            # Check VLAN exists
            vlan_exists = self.nr.filter(name=device_ip).run(
                task=self.verify_vlan_exists,
                vlan_id=vlan_id
            )[device_ip].result
            
            if vlan_exists:
                result.vlan_status = "VLAN exists"
                logger.debug(f"VLAN {vlan_id} exists on {device_ip}")
            else:
                result.vlan_status = "VLAN missing"
                result.overall_status = VerificationStatus.FAIL
                overall_success = False
                failure_reasons.append(f"VLAN {vlan_id} missing on {device_ip}")
                logger.warning(f"VLAN {vlan_id} missing on {device_ip}")
            
            # First device: check access port
            if i == 0:
                access_ok = self.nr.filter(name=device_ip).run(
                    task=self.verify_access_vlan,
                    interface=target_port,
                    vlan_id=vlan_id
                )[device_ip].result
                
                if access_ok:
                    result.port_status = "Access port configured"
                    logger.debug(f"Access port {target_port} configured on {device_ip}")
                else:
                    result.port_status = f"Port {target_port} not in VLAN {vlan_id}"
                    result.overall_status = VerificationStatus.FAIL
                    overall_success = False
                    failure_reasons.append(f"Port {target_port} not in VLAN {vlan_id}")
                    logger.warning(f"Port {target_port} not in VLAN {vlan_id}")
            
            # Intermediate devices: check trunk ports
            elif i < len(path) - 1:
                next_device = path[i + 1]
                uplink_port = self.nr.filter(name=device_ip).run(
                    task=self.find_uplink_port,
                    neighbor_ip=next_device
                )[device_ip].result
                
                if uplink_port:
                    trunk_ok = self.nr.filter(name=device_ip).run(
                        task=self.verify_trunk_vlan,
                        interface=uplink_port,
                        vlan_id=vlan_id
                    )[device_ip].result
                    
                    if trunk_ok:
                        result.trunk_status = f"Trunk {uplink_port} allows VLAN"
                        logger.debug(f"Trunk {uplink_port} allows VLAN {vlan_id}")
                    else:
                        result.trunk_status = f"VLAN {vlan_id} blocked on {uplink_port}"
                        result.overall_status = VerificationStatus.FAIL
                        overall_success = False
                        failure_reasons.append(f"VLAN {vlan_id} blocked on {uplink_port}")
                        logger.warning(f"VLAN {vlan_id} blocked on {uplink_port}")
                else:
                    result.trunk_status = f"No uplink found to {next_device}"
                    result.overall_status = VerificationStatus.FAIL
                    overall_success = False
                    failure_reasons.append(f"No uplink found to {next_device}")
                    logger.warning(f"No uplink found to {next_device}")
            
            # Router endpoint
            else:
                result.role = "Router endpoint"
                logger.debug(f"Router endpoint: {device_ip}")
            
            # Set overall status if not already failed
            if result.overall_status == VerificationStatus.UNKNOWN:
                result.overall_status = VerificationStatus.PASS
            
            results[device_ip] = result

        # Generate summary message
        if overall_success:
            message = f"VLAN {vlan_id} path fully verified"
        else:
            message = f"VLAN path verification failed: {'; '.join(failure_reasons[:3])}"
        
        logger.info(f"Verification complete: {message}")
        return overall_success, message, path, results

    def visualize_path(self, path: List[str], verification_results: Dict[str, DeviceResult]):
        """Create enhanced visualization of the network path"""
        plt.ioff()
        fig, ax = plt.subplots(figsize=(18, 12))
        
        # Create graph
        G = nx.path_graph(path)
        
        # Position nodes
        pos = {node: (i * 3, 0) for i, node in enumerate(G.nodes())}
        
        # Prepare node colors and labels
        node_colors = []
        node_labels = {}
        status_labels = {}
        
        for node in G.nodes():
            result = verification_results.get(node)
            if not result:
                node_colors.append("gray")
                status_labels[node] = "No data"
                continue
            
            # Determine color based on status
            if result.overall_status == VerificationStatus.PASS:
                node_colors.append("lightgreen")
                status = "✓ PASS"
            elif result.overall_status == VerificationStatus.FAIL:
                node_colors.append("red")
                status = "✗ FAIL"
            else:
                node_colors.append("gray")
                status = "? UNKNOWN"
            
            # Create node label
            node_labels[node] = node
            
            # Create status label
            status_lines = [f"Status: {status}"]
            
            if result.vlan_status:
                status_lines.append(f"VLAN: {result.vlan_status}")
            
            if result.port_status:
                status_lines.append(f"Port: {result.port_status}")
            
            if result.trunk_status:
                status_lines.append(f"Trunk: {result.trunk_status}")
            
            if result.role:
                status_lines.append(f"Role: {result.role}")
            
            status_labels[node] = "\n".join(status_lines[:4])  # Limit to 4 lines
        
        # Draw network graph
        nx.draw_networkx_nodes(G, pos, node_color=node_colors, node_size=5000, 
                              edgecolors='black', linewidths=2)
        nx.draw_networkx_edges(G, pos, width=3, edge_color='steelblue', 
                              arrows=True, arrowstyle='-|>', arrowsize=30)
        
        # Add device labels (above nodes)
        name_pos = {k: (v[0], v[1] + 0.8) for k, v in pos.items()}
        nx.draw_networkx_labels(G, name_pos, labels=node_labels, font_size=10, 
                               font_weight="bold")
        
        # Add status labels (below nodes)
        status_pos = {k: (v[0], v[1] - 1.2) for k, v in pos.items()}
        nx.draw_networkx_labels(G, status_pos, labels=status_labels, font_size=8,
                               bbox=dict(facecolor='white', edgecolor='black',
                                       boxstyle='round,pad=0.5', alpha=0.9))
        
        # Add legend
        legend_elements = [
            plt.Line2D([0], [0], marker='o', color='w', label='Pass', 
                      markerfacecolor='lightgreen', markersize=15),
            plt.Line2D([0], [0], marker='o', color='w', label='Fail', 
                      markerfacecolor='red', markersize=15),
            plt.Line2D([0], [0], marker='o', color='w', label='Unknown', 
                      markerfacecolor='gray', markersize=15)
        ]
        
        plt.legend(handles=legend_elements, loc='upper right', fontsize=12, 
                  title="Verification Status", title_fontsize=14)
        
        plt.title("Network VLAN Path Verification Results", pad=40, fontsize=18, 
                 fontweight='bold')
        plt.axis('off')
        plt.tight_layout()
        plt.show(block=True)
        plt.ion()


def main():
    """Main function to run VLAN path verification"""
    # Configuration
    initial_switch = "172.17.57.243"
    target_port = "GigabitEthernet1/0/10"
    vlan_id = "5"
    
    # Create verifier instance
    verifier = NetworkVerifier(config_file="config.yaml")
    
    try:
        # Run verification
        success, message, path, results = verifier.verify_vlan_path(
            initial_switch, target_port, vlan_id
        )
        
        # Print results
        print("\n" + "="*60)
        print(f"VLAN PATH VERIFICATION {'SUCCEEDED' if success else 'FAILED'}")
        print("="*60)
        print(f"Initial Switch: {initial_switch}")
        print(f"Target Port: {target_port}")
        print(f"VLAN ID: {vlan_id}")
        print(f"Path: {' → '.join(path)}")
        print(f"Status: {message}")
        print("="*60)
        
        # Detailed results
        print("\nDETAILED RESULTS:")
        print("-" * 40)
        for device_ip, result in results.items():
            print(f"\nDevice: {device_ip}")
            print(f"  Overall Status: {result.overall_status.value.upper()}")
            print(f"  VLAN Status: {result.vlan_status}")
            if result.port_status:
                print(f"  Port Status: {result.port_status}")
            if result.trunk_status:
                print(f"  Trunk Status: {result.trunk_status}")
            if result.role:
                print(f"  Role: {result.role}")
        
        # Show visualization
        if path and results:
            print("\nGenerating network visualization...")
            verifier.visualize_path(path, results)
        
        return success
        
    except Exception as e:
        logger.error(f"Verification failed with error: {str(e)}")
        print(f"\nERROR: Verification failed - {str(e)}")
        return False
    
    finally:
        # Cleanup
        if hasattr(verifier, 'nr') and verifier.nr:
            verifier.nr.close_connections()


if __name__ == "__main__":
    import sys
    
    # Allow command line arguments
    if len(sys.argv) >= 4:
        initial_switch = sys.argv[1]
        target_port = sys.argv[2]
        vlan_id = sys.argv[3]
        
        verifier = NetworkVerifier()
        success, message, path, results = verifier.verify_vlan_path(
            initial_switch, target_port, vlan_id
        )
        
        if success:
            print(f"✓ VLAN {vlan_id} path verification successful")
            sys.exit(0)
        else:
            print(f"✗ VLAN {vlan_id} path verification failed: {message}")
            sys.exit(1)
    else:
        # Use default configuration
        success = main()
        sys.exit(0 if success else 1)list in neighbors.items():
from nornir import InitNornir
from nornir_netmiko import netmiko_send_command
from nornir.core.task import Task, Result
from typing import Dict, List, Tuple, Optional, Set
import networkx as nx
import matplotlib.pyplot as plt
import re
import logging
from dataclasses import dataclass
from enum import Enum

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class VerificationStatus(Enum):
    PASS = "pass"
    FAIL = "fail"
    UNKNOWN = "unknown"

@dataclass
class DeviceResult:
    device_ip: str
    vlan_status: str
    port_status: Optional[str] = None
    trunk_status: Optional[str] = None
    role: Optional[str] = None
    overall_status: VerificationStatus = VerificationStatus.UNKNOWN

class NetworkVerifier:
    def __init__(self, config_file: str = "config.yaml"):
        self.nr = InitNornir(config_file=config_file)
        self.max_hops = 15
        
    def get_lldp_neighbors(self, task: Task) -> List[Dict]:
        """Collect LLDP neighbor information in a vendor-neutral way"""
        platform = task.host.platform
        
        # Enhanced command mapping for different platforms
        command_map = {
            "aruba_cx": "show lldp neighbors detail",
            "cisco_ios": "show lldp neighbors detail",
            "cisco_xe": "show lldp neighbors detail",
            "hp_comware": "display lldp neighbor-information",
            "juniper": "show lldp neighbors detail"
        }
        
        command = command_map.get(platform, "show lldp neighbors detail")
        
        logger.debug(f"Running on {task.host}: {command}")
        
        try:
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            # Handle different result types
            if isinstance(result.result, str):
                logger.warning(f"TextFSM parsing failed for {task.host}, attempting manual parsing")
                return self._parse_lldp_manually(result.result, platform)
            elif isinstance(result.result, dict):
                return [result.result]
            elif isinstance(result.result, list):
                return result.result
            else:
                logger.warning(f"No LLDP neighbors found on {task.host}")
                return []
                
        except Exception as e:
            logger.error(f"Error getting LLDP neighbors on {task.host}: {str(e)}")
            return []

    def _parse_lldp_manually(self, output: str, platform: str) -> List[Dict]:
        """Manual parsing fallback for when TextFSM fails"""
        neighbors = []
        
        try:
            # Basic regex patterns for common LLDP output formats
            if platform == "cisco_ios":
                # Cisco IOS LLDP format
                pattern = r'Device ID: (\S+).*?Local Intf: (\S+).*?Port id: (\S+)'
                matches = re.findall(pattern, output, re.DOTALL)
                
                for match in matches:
                    neighbors.append({
                        'neighbor': match[0],
                        'local_interface': match[1],
                        'neighbor_port': match[2]
                    })
            
            # Add more platform-specific parsing as needed
            
        except Exception as e:
            logger.error(f"Manual LLDP parsing failed: {str(e)}")
            
        return neighbors

    def find_uplink_port(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find the local interface connected to a neighbor with improved error handling"""
        platform = task.host.platform
        
        try:
            # Try LLDP first (most reliable)
            lldp_result = self._find_port_via_lldp(task, neighbor_ip, platform)
            if lldp_result:
                return lldp_result
            
            # Fall back to CDP for Cisco devices
            if platform.startswith("cisco"):
                cdp_result = self._find_port_via_cdp(task, neighbor_ip)
                if cdp_result:
                    return cdp_result
                    
            # Last resort: MAC address table lookup
            mac_result = self._find_port_via_mac(task, neighbor_ip)
            if mac_result:
                return mac_result
                
        except Exception as e:
            logger.error(f"Error finding uplink port on {task.host}: {str(e)}")
        
        return None

    def _find_port_via_lldp(self, task: Task, neighbor_ip: str, platform: str) -> Optional[str]:
        """Find port using LLDP"""
        try:
            neighbors = self.get_lldp_neighbors(task)
            
            for neighbor in neighbors:
                # Check multiple possible neighbor identifier fields
                neighbor_id = (neighbor.get('neighbor') or 
                             neighbor.get('mgmt_address') or 
                             neighbor.get('system_name'))
                
                if neighbor_id and (neighbor_id == neighbor_ip or 
                                  neighbor_id.startswith(neighbor_ip.split('.')[0])):
                    return neighbor.get('local_interface')
                    
        except Exception as e:
            logger.debug(f"LLDP port lookup failed: {str(e)}")
            
        return None

    def _find_port_via_cdp(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find port using CDP (Cisco devices)"""
        try:
            command = "show cdp neighbors detail"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if result.result:
                for neighbor in (result.result if isinstance(result.result, list) else [result.result]):
                    if neighbor.get('mgmt_address') == neighbor_ip:
                        return neighbor.get('local_port')
                        
        except Exception as e:
            logger.debug(f"CDP port lookup failed: {str(e)}")
            
        return None

    def _find_port_via_mac(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find port using MAC address table (least reliable)"""
        try:
            # This would require ARP table lookup first, then MAC table
            # Implementation depends on specific requirements
            pass
        except Exception as e:
            logger.debug(f"MAC table port lookup failed: {str(e)}")
            
        return None

    def verify_vlan_exists(self, task: Task, vlan_id: str) -> bool:
        """Check if VLAN exists with enhanced platform support"""
        platform = task.host.platform
        
        command_map = {
            "aruba_cx": f"show vlan {vlan_id}",
            "cisco_ios": f"show vlan id {vlan_id}",
            "cisco_xe": f"show vlan id {vlan_id}",
            "hp_comware": f"display vlan {vlan_id}",
            "juniper": f"show vlans {vlan_id}"
        }
        
        command = command_map.get(platform, f"show vlan id {vlan_id}")
        
        try:
            logger.debug(f"Running on {task.host}: {command}")
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if isinstance(result.result, str):
                # Check for common error messages
                error_indicators = ["invalid", "not found", "does not exist", "error"]
                return not any(indicator in result.result.lower() for indicator in error_indicators)
            
            return bool(result.result)
            
        except Exception as e:
            logger.error(f"Error checking VLAN on {task.host}: {str(e)}")
            return False

    def verify_access_vlan(self, task: Task, interface: str, vlan_id: str) -> bool:
        """Verify access port VLAN configuration with better error handling"""
        platform = task.host.platform
        
        try:
            # Method 1: Check VLAN membership
            if self._check_vlan_membership(task, interface, vlan_id, platform):
                return True
            
            # Method 2: Check interface configuration
            if self._check_interface_config(task, interface, vlan_id, platform):
                return True
            
            logger.debug(f"Access VLAN {vlan_id} not found on {interface}")
            return False
            
        except Exception as e:
            logger.error(f"Error checking access port on {task.host}: {str(e)}")
            return False

    def _check_vlan_membership(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check VLAN membership tables"""
        try:
            command_map = {
                "aruba_cx": f"show vlan {vlan_id}",
                "cisco_ios": f"show vlan id {vlan_id}",
                "cisco_xe": f"show vlan id {vlan_id}",
            }
            
            command = command_map.get(platform, f"show vlan id {vlan_id}")
            
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if result.result:
                for vlan in (result.result if isinstance(result.result, list) else [result.result]):
                    interfaces = vlan.get('interfaces', [])
                    if isinstance(interfaces, str):
                        interfaces = [interfaces]
                    
                    # Normalize interface names for comparison
                    normalized_interfaces = [self._normalize_interface_name(intf) for intf in interfaces]
                    normalized_target = self._normalize_interface_name(interface)
                    
                    if normalized_target in normalized_interfaces:
                        return True
                        
        except Exception as e:
            logger.debug(f"VLAN membership check failed: {str(e)}")
            
        return False

    def _check_interface_config(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check interface running configuration"""
        try:
            command = f"show running-config interface {interface}"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=False,
                enable=True
            )
            
            config = result.result.lower()
            
            # Platform-specific config patterns
            patterns = {
                "aruba_cx": [f"vlan access {vlan_id}"],
                "cisco_ios": [f"switchport access vlan {vlan_id}"],
                "cisco_xe": [f"switchport access vlan {vlan_id}"],
            }
            
            check_patterns = patterns.get(platform, [f"switchport access vlan {vlan_id}"])
            
            return any(pattern in config for pattern in check_patterns)
            
        except Exception as e:
            logger.debug(f"Interface config check failed: {str(e)}")
            
        return False

    def _normalize_interface_name(self, interface: str) -> str:
        """Normalize interface names for comparison"""
        # Handle common abbreviations
        interface = interface.replace("GigabitEthernet", "Gi")
        interface = interface.replace("FastEthernet", "Fa")
        interface = interface.replace("TenGigabitEthernet", "Te")
        
        # Remove spaces and convert to lowercase
        return interface.replace(" ", "").lower()

    def verify_trunk_vlan(self, task: Task, interface: str, vlan_id: str) -> bool:
        """Verify trunk allows the VLAN with comprehensive checking"""
        platform = task.host.platform
        
        try:
            # Method 1: Check switchport status
            if self._check_switchport_trunk(task, interface, vlan_id, platform):
                return True
            
            # Method 2: Check running configuration
            if self._check_trunk_config(task, interface, vlan_id, platform):
                return True
            
            return False
            
        except Exception as e:
            logger.error(f"Error checking trunk on {task.host}: {str(e)}")
            return False

    def _check_switchport_trunk(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check switchport trunk status"""
        try:
            command = f"show interfaces {interface} switchport"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if isinstance(result.result, str):
                # Parse raw output
                return self._parse_trunk_raw_output(result.result, vlan_id)
            
            if result.result and isinstance(result.result, list):
                sw_data = result.result[0]
                
                # Check if port is in trunk mode
                if sw_data.get('mode', '').lower() != 'trunk':
                    return False
                
                # Check allowed VLANs
                return self._check_allowed_vlans(sw_data, vlan_id)
                
        except Exception as e:
            logger.debug(f"Switchport trunk check failed: {str(e)}")
            
        return False

    def _parse_trunk_raw_output(self, output: str, vlan_id: str) -> bool:
        """Parse raw switchport output"""
        output_lower = output.lower()
        
        if "trunking" in output_lower:
            if "vlans allowed: all" in output_lower:
                return True
            if f"vlans allowed: {vlan_id}" in output_lower:
                return True
        
        return False

    def _check_allowed_vlans(self, switchport_data: Dict, vlan_id: str) -> bool:
        """Check if VLAN is in allowed VLAN list"""
        for field in ['trunking_vlans', 'vlans_allowed', 'allowed_vlans']:
            vlans = switchport_data.get(field, '')
            
            if vlans:
                if vlans.upper() == 'ALL':
                    return True
                if self._is_vlan_in_list(vlans, vlan_id):
                    return True
        
        return False

    def _check_trunk_config(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check trunk configuration in running config"""
        try:
            command = f"show running-config interface {interface}"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                enable=True
            )
            
            config = result.result.lower()
            
            # If trunk mode is configured but no allowed VLAN restrictions, assume all VLANs allowed
            if "switchport mode trunk" in config and "switchport trunk allowed vlan" not in config:
                return True
            
            # Check specific VLAN allowances
            if f"switchport trunk allowed vlan add {vlan_id}" in config:
                return True
            
            return False
            
        except Exception as e:
            logger.debug(f"Trunk config check failed: {str(e)}")
            
        return False

    def _is_vlan_in_list(self, vlan_str: str, target_vlan: str) -> bool:
        """Helper to safely parse VLAN lists (1,5,10-20,30)"""
        try:
            if not vlan_str:
                return False
                
            target_int = int(target_vlan)
            
            for part in str(vlan_str).split(','):
                part = part.strip()
                
                if '-' in part:
                    # Handle range (e.g., "10-20")
                    start, end = map(int, part.split('-'))
                    if start <= target_int <= end:
                        return True
                elif part.isdigit() and int(part) == target_int:
                    return True
                    
            return False
            
        except (ValueError, AttributeError) as e:
            logger.error(f"VLAN list parsing failed: {str(e)}")
            return False

    def trace_path_to_router(self, start_device: str) -> List[str]:
        """Trace path from edge switch to router using LLDP with improved logic"""
        logger.info("Starting path trace to router...")
        
        path = []
        current_device = start_device
        visited: Set[str] = set()
        
        # Get target router
        try:
            target_router = self.nr.inventory.hosts[start_device].data.get('router')
            if not target_router:
                logger.error(f"No router defined for {start_device}")
                return []
        except KeyError:
            logger.error(f"Device {start_device} not found in inventory")
            return []

        logger.info(f"Target router: {target_router}")

        while current_device and current_device not in visited and len(path) < self.max_hops:
            visited.add(current_device)
            path.append(current_device)
            
            logger.debug(f"Current device: {current_device}")
            logger.debug(f"Current path: {' -> '.join(path)}")
            
            # Check if we've reached the target router
            if current_device == target_router:
                logger.info(f"Reached target router: {current_device}")
                break
            
            # Get neighbors and find next hop
            next_hop = self._find_next_hop(current_device, target_router, visited)
            if not next_hop:
                logger.warning(f"No valid next hop found from {current_device}")
                break
                
            current_device = next_hop

        # Ensure router is in path
        if path and path[-1] != target_router:
            path.append(target_router)
            logger.debug(f"Added router {target_router} to path")

        logger.info(f"Final path: {' -> '.join(path)}")
        return path

    def _find_next_hop(self, current_device: str, target_router: str, visited: Set[str]) -> Optional[str]:
        """Find the next hop in the path"""
        try:
            neighbors_result = self.nr.filter(name=current_device).run(task=self.get_lldp_neighbors)
            neighbors = neighbors_result[current_device].result
            
            if not neighbors:
                logger.debug(f"No neighbors found for {current_device}")
                return None
            
            # Find unvisited neighbors
            possible_hops = []
            for neighbor in (neighbors if isinstance(neighbors, list) else [neighbors]):
                if isinstance(neighbor, dict):
                    neighbor_ip = self._extract_neighbor_ip(neighbor)
                    
                    if neighbor_ip and neighbor_ip not in visited:
                        # Try to resolve to inventory hostname
                        resolved_ip = self._resolve_neighbor_ip(neighbor_ip)
                        if resolved_ip:
                            possible_hops.append(resolved_ip)
            
            if not possible_hops:
                return None
            
            # Prioritize direct connection to router
            if target_router in possible_hops:
                return target_router
            
            # Prioritize devices that have the target router configured
            for hop in possible_hops:
                try:
                    if self.nr.inventory.hosts[hop].data.get('router') == target_router:
                        return hop
                except KeyError:
                    continue
            
            # Return first available hop
            return possible_hops[0]
            
        except Exception as e:
            logger.error(f"Error finding next hop from {current_device}: {str(e)}")
            return None

    def _extract_neighbor_ip(self, neighbor: Dict) -> Optional[str]:
        """Extract neighbor IP from LLDP data"""
        neighbor_ip = (neighbor.get('mgmt_address') or 
                      neighbor.get('neighbor') or 
                      neighbor.get('neighbor_name') or
                      neighbor.get('system_name'))
        
        if neighbor_ip and '.' not in neighbor_ip:
            # Handle hostname format
            neighbor_ip = neighbor_ip.split('.')[0]
        
        return neighbor_ip

    def _resolve_neighbor_ip(self, neighbor_ip: str) -> Optional[str]:
        """Resolve neighbor IP to inventory hostname"""
        # Direct match
        if neighbor_ip in self.nr.inventory.hosts:
            return neighbor_ip
        
        # Hostname match
        for hostname, host in self.nr.inventory.hosts.items():
            if (host.get('hostname', '') == neighbor_ip or 
                hostname.startswith(neighbor_ip)):
                return hostname
        
        return None

    def verify_vlan_path(self, initial_switch: str, target_port: str, vlan_id: str) -> Tuple[bool, str, List[str], Dict[str, DeviceResult]]:
        """Comprehensive VLAN path verification"""
        logger.info("Starting VLAN path verification")
        
        # Trace path
        path = self.trace_path_to_router(initial_switch)
        if not path:
            return False, "No path found to router", [], {}

        # Verify each device in path
        results = {}
        overall_success = True
        failure_reasons = []
        
        for i, device_ip in enumerate(path):
            logger.info(f"Verifying device {i+1}/{len(path)}: {device_ip}")
            
            result = DeviceResult(device_ip=device_ip, vlan_status="Unknown")
            
            # Check VLAN exists
            vlan_exists = self.nr.filter(name=device_ip).run(
                task=self.verify_vlan_exists,
                vlan_id=vlan_id
            )[device_ip].result
            
            if vlan_exists:
                result.vlan_status = "VLAN exists"
                logger.debug(f"VLAN {vlan_id} exists on {device_ip}")
            else:
                result.vlan_status = "VLAN missing"
                result.overall_status = VerificationStatus.FAIL
                overall_success = False
                failure_reasons.append(f"VLAN {vlan_id} missing on {device_ip}")
                logger.warning(f"VLAN {vlan_id} missing on {device_ip}")
            
            # First device: check access port
            if i == 0:
                access_ok = self.nr.filter(name=device_ip).run(
                    task=self.verify_access_vlan,
                    interface=target_port,
                    vlan_id=vlan_id
                )[device_ip].result
                
                if access_ok:
                    result.port_status = "Access port configured"
                    logger.debug(f"Access port {target_port} configured on {device_ip}")
                else:
                    result.port_status = f"Port {target_port} not in VLAN {vlan_id}"
                    result.overall_status = VerificationStatus.FAIL
                    overall_success = False
                    failure_reasons.append(f"Port {target_port} not in VLAN {vlan_id}")
                    logger.warning(f"Port {target_port} not in VLAN {vlan_id}")
            
            # Intermediate devices: check trunk ports
            elif i < len(path) - 1:
                next_device = path[i + 1]
                uplink_port = self.nr.filter(name=device_ip).run(
                    task=self.find_uplink_port,
                    neighbor_ip=next_device
                )[device_ip].result
                
                if uplink_port:
                    trunk_ok = self.nr.filter(name=device_ip).run(
                        task=self.verify_trunk_vlan,
                        interface=uplink_port,
                        vlan_id=vlan_id
                    )[device_ip].result
                    
                    if trunk_ok:
                        result.trunk_status = f"Trunk {uplink_port} allows VLAN"
                        logger.debug(f"Trunk {uplink_port} allows VLAN {vlan_id}")
                    else:
                        result.trunk_status = f"VLAN {vlan_id} blocked on {uplink_port}"
                        result.overall_status = VerificationStatus.FAIL
                        overall_success = False
                        failure_reasons.append(f"VLAN {vlan_id} blocked on {uplink_port}")
                        logger.warning(f"VLAN {vlan_id} blocked on {uplink_port}")
                else:
                    result.trunk_status = f"No uplink found to {next_device}"
                    result.overall_status = VerificationStatus.FAIL
                    overall_success = False
                    failure_reasons.append(f"No uplink found to {next_device}")
                    logger.warning(f"No uplink found to {next_device}")
            
            # Router endpoint
            else:
                result.role = "Router endpoint"
                logger.debug(f"Router endpoint: {device_ip}")
            
            # Set overall status if not already failed
            if result.overall_status == VerificationStatus.UNKNOWN:
                result.overall_status = VerificationStatus.PASS
            
            results[device_ip] = result

        # Generate summary message
        if overall_success:
            message = f"VLAN {vlan_id} path fully verified"
        else:
            message = f"VLAN path verification failed: {'; '.join(failure_reasons[:3])}"
        
        logger.info(f"Verification complete: {message}")
        return overall_success, message, path, results

    def visualize_path(self, path: List[str], verification_results: Dict[str, DeviceResult]):
        """Create enhanced visualization of the network path"""
        plt.ioff()
        fig, ax = plt.subplots(figsize=(18, 12))
        
        # Create graph
        G = nx.path_graph(path)
        
        # Position nodes
        pos = {node: (i * 3, 0) for i, node in enumerate(G.nodes())}
        
        # Prepare node colors and labels
        node_colors = []
        node_labels = {}
        status_labels = {}
        
        for node in G.nodes():
            result = verification_results.get(node)
            if not result:
                node_colors.append("gray")
                status_labels[node] = "No data"
                continue
            
            # Determine color based on status
            if result.overall_status == VerificationStatus.PASS:
                node_colors.append("lightgreen")
                status = "✓ PASS"
            elif result.overall_status == VerificationStatus.FAIL:
                node_colors.append("red")
                status = "✗ FAIL"
            else:
                node_colors.append("gray")
                status = "? UNKNOWN"
            
            # Create node label
            node_labels[node] = node
            
            # Create status label
            status_lines = [f"Status: {status}"]
            
            if result.vlan_status:
                status_lines.append(f"VLAN: {result.vlan_status}")
            
            if result.port_status:
                status_lines.append(f"Port: {result.port_status}")
            
            if result.trunk_status:
                status_lines.append(f"Trunk: {result.trunk_status}")
            
            if result.role:
                status_lines.append(f"Role: {result.role}")
            
            status_labels[node] = "\n".join(status_lines[:4])  # Limit to 4 lines
        
        # Draw network graph
        nx.draw_networkx_nodes(G, pos, node_color=node_colors, node_size=5000, 
                              edgecolors='black', linewidths=2)
        nx.draw_networkx_edges(G, pos, width=3, edge_color='steelblue', 
                              arrows=True, arrowstyle='-|>', arrowsize=30)
        
        # Add device labels (above nodes)
        name_pos = {k: (v[0], v[1] + 0.8) for k, v in pos.items()}
        nx.draw_networkx_labels(G, name_pos, labels=node_labels, font_size=10, 
                               font_weight="bold")
        
        # Add status labels (below nodes)
        status_pos = {k: (v[0], v[1] - 1.2) for k, v in pos.items()}
        nx.draw_networkx_labels(G, status_pos, labels=status_labels, font_size=8,
                               bbox=dict(facecolor='white', edgecolor='black',
                                       boxstyle='round,pad=0.5', alpha=0.9))
        
        # Add legend
        legend_elements = [
            plt.Line2D([0], [0], marker='o', color='w', label='Pass', 
                      markerfacecolor='lightgreen', markersize=15),
            plt.Line2D([0], [0], marker='o', color='w', label='Fail', 
                      markerfacecolor='red', markersize=15),
            plt.Line2D([0], [0], marker='o', color='w', label='Unknown', 
                      markerfacecolor='gray', markersize=15)
        ]
        
        plt.legend(handles=legend_elements, loc='upper right', fontsize=12, 
                  title="Verification Status", title_fontsize=14)
        
        plt.title("Network VLAN Path Verification Results", pad=40, fontsize=18, 
                 fontweight='bold')
        plt.axis('off')
        plt.tight_layout()
        plt.show(block=True)
        plt.ion()


def main():
    """Main function to run VLAN path verification"""
    # Configuration
    initial_switch = "172.17.57.243"
    target_port = "GigabitEthernet1/0/10"
    vlan_id = "5"
    
    # Create verifier instance
    verifier = NetworkVerifier(config_file="config.yaml")
    
    try:
        # Run verification
        success, message, path, results = verifier.verify_vlan_path(
            initial_switch, target_port, vlan_id
        )
        
        # Print results
        print("\n" + "="*60)
        print(f"VLAN PATH VERIFICATION {'SUCCEEDED' if success else 'FAILED'}")
        print("="*60)
        print(f"Initial Switch: {initial_switch}")
        print(f"Target Port: {target_port}")
        print(f"VLAN ID: {vlan_id}")
        print(f"Path: {' → '.join(path)}")
        print(f"Status: {message}")
        print("="*60)
        
        # Detailed results
        print("\nDETAILED RESULTS:")
        print("-" * 40)
        for device_ip, result in results.items():
            print(f"\nDevice: {device_ip}")
            print(f"  Overall Status: {result.overall_status.value.upper()}")
            print(f"  VLAN Status: {result.vlan_status}")
            if result.port_status:
                print(f"  Port Status: {result.port_status}")
            if result.trunk_status:
                print(f"  Trunk Status: {result.trunk_status}")
            if result.role:
                print(f"  Role: {result.role}")
        
        # Show visualization
        if path and results:
            print("\nGenerating network visualization...")
            verifier.visualize_path(path, results)
        
        return success
        
    except Exception as e:
        logger.error(f"Verification failed with error: {str(e)}")
        print(f"\nERROR: Verification failed - {str(e)}")
        return False
    
    finally:
        # Cleanup
        if hasattr(verifier, 'nr') and verifier.nr:
            verifier.nr.close_connections()


if __name__ == "__main__":
    import sys
    
    # Allow command line arguments
    if len(sys.argv) >= 4:
        initial_switch = sys.argv[1]
        target_port = sys.argv[2]
        vlan_id = sys.argv[3]
        
        verifier = NetworkVerifier()
        success, message, path, results = verifier.verify_vlan_path(
            initial_switch, target_port, vlan_id
        )
        
        if success:
            print(f"✓ VLAN {vlan_id} path verification successful")
            sys.exit(0)
        else:
            print(f"✗ VLAN {vlan_id} path verification failed: {message}")
            sys.exit(1)
    else:
        # Use default configuration
        success = main()
        sys.exit(0 if success else 1)neighbor_list:
from nornir import InitNornir
from nornir_netmiko import netmiko_send_command
from nornir.core.task import Task, Result
from typing import Dict, List, Tuple, Optional, Set
import networkx as nx
import matplotlib.pyplot as plt
import re
import logging
from dataclasses import dataclass
from enum import Enum

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class VerificationStatus(Enum):
    PASS = "pass"
    FAIL = "fail"
    UNKNOWN = "unknown"

@dataclass
class DeviceResult:
    device_ip: str
    vlan_status: str
    port_status: Optional[str] = None
    trunk_status: Optional[str] = None
    role: Optional[str] = None
    overall_status: VerificationStatus = VerificationStatus.UNKNOWN

class NetworkVerifier:
    def __init__(self, config_file: str = "config.yaml"):
        self.nr = InitNornir(config_file=config_file)
        self.max_hops = 15
        
    def get_lldp_neighbors(self, task: Task) -> List[Dict]:
        """Collect LLDP neighbor information in a vendor-neutral way"""
        platform = task.host.platform
        
        # Enhanced command mapping for different platforms
        command_map = {
            "aruba_cx": "show lldp neighbors detail",
            "cisco_ios": "show lldp neighbors detail",
            "cisco_xe": "show lldp neighbors detail",
            "hp_comware": "display lldp neighbor-information",
            "juniper": "show lldp neighbors detail"
        }
        
        command = command_map.get(platform, "show lldp neighbors detail")
        
        logger.debug(f"Running on {task.host}: {command}")
        
        try:
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            # Handle different result types
            if isinstance(result.result, str):
                logger.warning(f"TextFSM parsing failed for {task.host}, attempting manual parsing")
                return self._parse_lldp_manually(result.result, platform)
            elif isinstance(result.result, dict):
                return [result.result]
            elif isinstance(result.result, list):
                return result.result
            else:
                logger.warning(f"No LLDP neighbors found on {task.host}")
                return []
                
        except Exception as e:
            logger.error(f"Error getting LLDP neighbors on {task.host}: {str(e)}")
            return []

    def _parse_lldp_manually(self, output: str, platform: str) -> List[Dict]:
        """Manual parsing fallback for when TextFSM fails"""
        neighbors = []
        
        try:
            # Basic regex patterns for common LLDP output formats
            if platform == "cisco_ios":
                # Cisco IOS LLDP format
                pattern = r'Device ID: (\S+).*?Local Intf: (\S+).*?Port id: (\S+)'
                matches = re.findall(pattern, output, re.DOTALL)
                
                for match in matches:
                    neighbors.append({
                        'neighbor': match[0],
                        'local_interface': match[1],
                        'neighbor_port': match[2]
                    })
            
            # Add more platform-specific parsing as needed
            
        except Exception as e:
            logger.error(f"Manual LLDP parsing failed: {str(e)}")
            
        return neighbors

    def find_uplink_port(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find the local interface connected to a neighbor with improved error handling"""
        platform = task.host.platform
        
        try:
            # Try LLDP first (most reliable)
            lldp_result = self._find_port_via_lldp(task, neighbor_ip, platform)
            if lldp_result:
                return lldp_result
            
            # Fall back to CDP for Cisco devices
            if platform.startswith("cisco"):
                cdp_result = self._find_port_via_cdp(task, neighbor_ip)
                if cdp_result:
                    return cdp_result
                    
            # Last resort: MAC address table lookup
            mac_result = self._find_port_via_mac(task, neighbor_ip)
            if mac_result:
                return mac_result
                
        except Exception as e:
            logger.error(f"Error finding uplink port on {task.host}: {str(e)}")
        
        return None

    def _find_port_via_lldp(self, task: Task, neighbor_ip: str, platform: str) -> Optional[str]:
        """Find port using LLDP"""
        try:
            neighbors = self.get_lldp_neighbors(task)
            
            for neighbor in neighbors:
                # Check multiple possible neighbor identifier fields
                neighbor_id = (neighbor.get('neighbor') or 
                             neighbor.get('mgmt_address') or 
                             neighbor.get('system_name'))
                
                if neighbor_id and (neighbor_id == neighbor_ip or 
                                  neighbor_id.startswith(neighbor_ip.split('.')[0])):
                    return neighbor.get('local_interface')
                    
        except Exception as e:
            logger.debug(f"LLDP port lookup failed: {str(e)}")
            
        return None

    def _find_port_via_cdp(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find port using CDP (Cisco devices)"""
        try:
            command = "show cdp neighbors detail"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if result.result:
                for neighbor in (result.result if isinstance(result.result, list) else [result.result]):
                    if neighbor.get('mgmt_address') == neighbor_ip:
                        return neighbor.get('local_port')
                        
        except Exception as e:
            logger.debug(f"CDP port lookup failed: {str(e)}")
            
        return None

    def _find_port_via_mac(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find port using MAC address table (least reliable)"""
        try:
            # This would require ARP table lookup first, then MAC table
            # Implementation depends on specific requirements
            pass
        except Exception as e:
            logger.debug(f"MAC table port lookup failed: {str(e)}")
            
        return None

    def verify_vlan_exists(self, task: Task, vlan_id: str) -> bool:
        """Check if VLAN exists with enhanced platform support"""
        platform = task.host.platform
        
        command_map = {
            "aruba_cx": f"show vlan {vlan_id}",
            "cisco_ios": f"show vlan id {vlan_id}",
            "cisco_xe": f"show vlan id {vlan_id}",
            "hp_comware": f"display vlan {vlan_id}",
            "juniper": f"show vlans {vlan_id}"
        }
        
        command = command_map.get(platform, f"show vlan id {vlan_id}")
        
        try:
            logger.debug(f"Running on {task.host}: {command}")
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if isinstance(result.result, str):
                # Check for common error messages
                error_indicators = ["invalid", "not found", "does not exist", "error"]
                return not any(indicator in result.result.lower() for indicator in error_indicators)
            
            return bool(result.result)
            
        except Exception as e:
            logger.error(f"Error checking VLAN on {task.host}: {str(e)}")
            return False

    def verify_access_vlan(self, task: Task, interface: str, vlan_id: str) -> bool:
        """Verify access port VLAN configuration with better error handling"""
        platform = task.host.platform
        
        try:
            # Method 1: Check VLAN membership
            if self._check_vlan_membership(task, interface, vlan_id, platform):
                return True
            
            # Method 2: Check interface configuration
            if self._check_interface_config(task, interface, vlan_id, platform):
                return True
            
            logger.debug(f"Access VLAN {vlan_id} not found on {interface}")
            return False
            
        except Exception as e:
            logger.error(f"Error checking access port on {task.host}: {str(e)}")
            return False

    def _check_vlan_membership(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check VLAN membership tables"""
        try:
            command_map = {
                "aruba_cx": f"show vlan {vlan_id}",
                "cisco_ios": f"show vlan id {vlan_id}",
                "cisco_xe": f"show vlan id {vlan_id}",
            }
            
            command = command_map.get(platform, f"show vlan id {vlan_id}")
            
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if result.result:
                for vlan in (result.result if isinstance(result.result, list) else [result.result]):
                    interfaces = vlan.get('interfaces', [])
                    if isinstance(interfaces, str):
                        interfaces = [interfaces]
                    
                    # Normalize interface names for comparison
                    normalized_interfaces = [self._normalize_interface_name(intf) for intf in interfaces]
                    normalized_target = self._normalize_interface_name(interface)
                    
                    if normalized_target in normalized_interfaces:
                        return True
                        
        except Exception as e:
            logger.debug(f"VLAN membership check failed: {str(e)}")
            
        return False

    def _check_interface_config(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check interface running configuration"""
        try:
            command = f"show running-config interface {interface}"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=False,
                enable=True
            )
            
            config = result.result.lower()
            
            # Platform-specific config patterns
            patterns = {
                "aruba_cx": [f"vlan access {vlan_id}"],
                "cisco_ios": [f"switchport access vlan {vlan_id}"],
                "cisco_xe": [f"switchport access vlan {vlan_id}"],
            }
            
            check_patterns = patterns.get(platform, [f"switchport access vlan {vlan_id}"])
            
            return any(pattern in config for pattern in check_patterns)
            
        except Exception as e:
            logger.debug(f"Interface config check failed: {str(e)}")
            
        return False

    def _normalize_interface_name(self, interface: str) -> str:
        """Normalize interface names for comparison"""
        # Handle common abbreviations
        interface = interface.replace("GigabitEthernet", "Gi")
        interface = interface.replace("FastEthernet", "Fa")
        interface = interface.replace("TenGigabitEthernet", "Te")
        
        # Remove spaces and convert to lowercase
        return interface.replace(" ", "").lower()

    def verify_trunk_vlan(self, task: Task, interface: str, vlan_id: str) -> bool:
        """Verify trunk allows the VLAN with comprehensive checking"""
        platform = task.host.platform
        
        try:
            # Method 1: Check switchport status
            if self._check_switchport_trunk(task, interface, vlan_id, platform):
                return True
            
            # Method 2: Check running configuration
            if self._check_trunk_config(task, interface, vlan_id, platform):
                return True
            
            return False
            
        except Exception as e:
            logger.error(f"Error checking trunk on {task.host}: {str(e)}")
            return False

    def _check_switchport_trunk(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check switchport trunk status"""
        try:
            command = f"show interfaces {interface} switchport"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if isinstance(result.result, str):
                # Parse raw output
                return self._parse_trunk_raw_output(result.result, vlan_id)
            
            if result.result and isinstance(result.result, list):
                sw_data = result.result[0]
                
                # Check if port is in trunk mode
                if sw_data.get('mode', '').lower() != 'trunk':
                    return False
                
                # Check allowed VLANs
                return self._check_allowed_vlans(sw_data, vlan_id)
                
        except Exception as e:
            logger.debug(f"Switchport trunk check failed: {str(e)}")
            
        return False

    def _parse_trunk_raw_output(self, output: str, vlan_id: str) -> bool:
        """Parse raw switchport output"""
        output_lower = output.lower()
        
        if "trunking" in output_lower:
            if "vlans allowed: all" in output_lower:
                return True
            if f"vlans allowed: {vlan_id}" in output_lower:
                return True
        
        return False

    def _check_allowed_vlans(self, switchport_data: Dict, vlan_id: str) -> bool:
        """Check if VLAN is in allowed VLAN list"""
        for field in ['trunking_vlans', 'vlans_allowed', 'allowed_vlans']:
            vlans = switchport_data.get(field, '')
            
            if vlans:
                if vlans.upper() == 'ALL':
                    return True
                if self._is_vlan_in_list(vlans, vlan_id):
                    return True
        
        return False

    def _check_trunk_config(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check trunk configuration in running config"""
        try:
            command = f"show running-config interface {interface}"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                enable=True
            )
            
            config = result.result.lower()
            
            # If trunk mode is configured but no allowed VLAN restrictions, assume all VLANs allowed
            if "switchport mode trunk" in config and "switchport trunk allowed vlan" not in config:
                return True
            
            # Check specific VLAN allowances
            if f"switchport trunk allowed vlan add {vlan_id}" in config:
                return True
            
            return False
            
        except Exception as e:
            logger.debug(f"Trunk config check failed: {str(e)}")
            
        return False

    def _is_vlan_in_list(self, vlan_str: str, target_vlan: str) -> bool:
        """Helper to safely parse VLAN lists (1,5,10-20,30)"""
        try:
            if not vlan_str:
                return False
                
            target_int = int(target_vlan)
            
            for part in str(vlan_str).split(','):
                part = part.strip()
                
                if '-' in part:
                    # Handle range (e.g., "10-20")
                    start, end = map(int, part.split('-'))
                    if start <= target_int <= end:
                        return True
                elif part.isdigit() and int(part) == target_int:
                    return True
                    
            return False
            
        except (ValueError, AttributeError) as e:
            logger.error(f"VLAN list parsing failed: {str(e)}")
            return False

    def trace_path_to_router(self, start_device: str) -> List[str]:
        """Trace path from edge switch to router using LLDP with improved logic"""
        logger.info("Starting path trace to router...")
        
        path = []
        current_device = start_device
        visited: Set[str] = set()
        
        # Get target router
        try:
            target_router = self.nr.inventory.hosts[start_device].data.get('router')
            if not target_router:
                logger.error(f"No router defined for {start_device}")
                return []
        except KeyError:
            logger.error(f"Device {start_device} not found in inventory")
            return []

        logger.info(f"Target router: {target_router}")

        while current_device and current_device not in visited and len(path) < self.max_hops:
            visited.add(current_device)
            path.append(current_device)
            
            logger.debug(f"Current device: {current_device}")
            logger.debug(f"Current path: {' -> '.join(path)}")
            
            # Check if we've reached the target router
            if current_device == target_router:
                logger.info(f"Reached target router: {current_device}")
                break
            
            # Get neighbors and find next hop
            next_hop = self._find_next_hop(current_device, target_router, visited)
            if not next_hop:
                logger.warning(f"No valid next hop found from {current_device}")
                break
                
            current_device = next_hop

        # Ensure router is in path
        if path and path[-1] != target_router:
            path.append(target_router)
            logger.debug(f"Added router {target_router} to path")

        logger.info(f"Final path: {' -> '.join(path)}")
        return path

    def _find_next_hop(self, current_device: str, target_router: str, visited: Set[str]) -> Optional[str]:
        """Find the next hop in the path"""
        try:
            neighbors_result = self.nr.filter(name=current_device).run(task=self.get_lldp_neighbors)
            neighbors = neighbors_result[current_device].result
            
            if not neighbors:
                logger.debug(f"No neighbors found for {current_device}")
                return None
            
            # Find unvisited neighbors
            possible_hops = []
            for neighbor in (neighbors if isinstance(neighbors, list) else [neighbors]):
                if isinstance(neighbor, dict):
                    neighbor_ip = self._extract_neighbor_ip(neighbor)
                    
                    if neighbor_ip and neighbor_ip not in visited:
                        # Try to resolve to inventory hostname
                        resolved_ip = self._resolve_neighbor_ip(neighbor_ip)
                        if resolved_ip:
                            possible_hops.append(resolved_ip)
            
            if not possible_hops:
                return None
            
            # Prioritize direct connection to router
            if target_router in possible_hops:
                return target_router
            
            # Prioritize devices that have the target router configured
            for hop in possible_hops:
                try:
                    if self.nr.inventory.hosts[hop].data.get('router') == target_router:
                        return hop
                except KeyError:
                    continue
            
            # Return first available hop
            return possible_hops[0]
            
        except Exception as e:
            logger.error(f"Error finding next hop from {current_device}: {str(e)}")
            return None

    def _extract_neighbor_ip(self, neighbor: Dict) -> Optional[str]:
        """Extract neighbor IP from LLDP data"""
        neighbor_ip = (neighbor.get('mgmt_address') or 
                      neighbor.get('neighbor') or 
                      neighbor.get('neighbor_name') or
                      neighbor.get('system_name'))
        
        if neighbor_ip and '.' not in neighbor_ip:
            # Handle hostname format
            neighbor_ip = neighbor_ip.split('.')[0]
        
        return neighbor_ip

    def _resolve_neighbor_ip(self, neighbor_ip: str) -> Optional[str]:
        """Resolve neighbor IP to inventory hostname"""
        # Direct match
        if neighbor_ip in self.nr.inventory.hosts:
            return neighbor_ip
        
        # Hostname match
        for hostname, host in self.nr.inventory.hosts.items():
            if (host.get('hostname', '') == neighbor_ip or 
                hostname.startswith(neighbor_ip)):
                return hostname
        
        return None

    def verify_vlan_path(self, initial_switch: str, target_port: str, vlan_id: str) -> Tuple[bool, str, List[str], Dict[str, DeviceResult]]:
        """Comprehensive VLAN path verification"""
        logger.info("Starting VLAN path verification")
        
        # Trace path
        path = self.trace_path_to_router(initial_switch)
        if not path:
            return False, "No path found to router", [], {}

        # Verify each device in path
        results = {}
        overall_success = True
        failure_reasons = []
        
        for i, device_ip in enumerate(path):
            logger.info(f"Verifying device {i+1}/{len(path)}: {device_ip}")
            
            result = DeviceResult(device_ip=device_ip, vlan_status="Unknown")
            
            # Check VLAN exists
            vlan_exists = self.nr.filter(name=device_ip).run(
                task=self.verify_vlan_exists,
                vlan_id=vlan_id
            )[device_ip].result
            
            if vlan_exists:
                result.vlan_status = "VLAN exists"
                logger.debug(f"VLAN {vlan_id} exists on {device_ip}")
            else:
                result.vlan_status = "VLAN missing"
                result.overall_status = VerificationStatus.FAIL
                overall_success = False
                failure_reasons.append(f"VLAN {vlan_id} missing on {device_ip}")
                logger.warning(f"VLAN {vlan_id} missing on {device_ip}")
            
            # First device: check access port
            if i == 0:
                access_ok = self.nr.filter(name=device_ip).run(
                    task=self.verify_access_vlan,
                    interface=target_port,
                    vlan_id=vlan_id
                )[device_ip].result
                
                if access_ok:
                    result.port_status = "Access port configured"
                    logger.debug(f"Access port {target_port} configured on {device_ip}")
                else:
                    result.port_status = f"Port {target_port} not in VLAN {vlan_id}"
                    result.overall_status = VerificationStatus.FAIL
                    overall_success = False
                    failure_reasons.append(f"Port {target_port} not in VLAN {vlan_id}")
                    logger.warning(f"Port {target_port} not in VLAN {vlan_id}")
            
            # Intermediate devices: check trunk ports
            elif i < len(path) - 1:
                next_device = path[i + 1]
                uplink_port = self.nr.filter(name=device_ip).run(
                    task=self.find_uplink_port,
                    neighbor_ip=next_device
                )[device_ip].result
                
                if uplink_port:
                    trunk_ok = self.nr.filter(name=device_ip).run(
                        task=self.verify_trunk_vlan,
                        interface=uplink_port,
                        vlan_id=vlan_id
                    )[device_ip].result
                    
                    if trunk_ok:
                        result.trunk_status = f"Trunk {uplink_port} allows VLAN"
                        logger.debug(f"Trunk {uplink_port} allows VLAN {vlan_id}")
                    else:
                        result.trunk_status = f"VLAN {vlan_id} blocked on {uplink_port}"
                        result.overall_status = VerificationStatus.FAIL
                        overall_success = False
                        failure_reasons.append(f"VLAN {vlan_id} blocked on {uplink_port}")
                        logger.warning(f"VLAN {vlan_id} blocked on {uplink_port}")
                else:
                    result.trunk_status = f"No uplink found to {next_device}"
                    result.overall_status = VerificationStatus.FAIL
                    overall_success = False
                    failure_reasons.append(f"No uplink found to {next_device}")
                    logger.warning(f"No uplink found to {next_device}")
            
            # Router endpoint
            else:
                result.role = "Router endpoint"
                logger.debug(f"Router endpoint: {device_ip}")
            
            # Set overall status if not already failed
            if result.overall_status == VerificationStatus.UNKNOWN:
                result.overall_status = VerificationStatus.PASS
            
            results[device_ip] = result

        # Generate summary message
        if overall_success:
            message = f"VLAN {vlan_id} path fully verified"
        else:
            message = f"VLAN path verification failed: {'; '.join(failure_reasons[:3])}"
        
        logger.info(f"Verification complete: {message}")
        return overall_success, message, path, results

    def visualize_path(self, path: List[str], verification_results: Dict[str, DeviceResult]):
        """Create enhanced visualization of the network path"""
        plt.ioff()
        fig, ax = plt.subplots(figsize=(18, 12))
        
        # Create graph
        G = nx.path_graph(path)
        
        # Position nodes
        pos = {node: (i * 3, 0) for i, node in enumerate(G.nodes())}
        
        # Prepare node colors and labels
        node_colors = []
        node_labels = {}
        status_labels = {}
        
        for node in G.nodes():
            result = verification_results.get(node)
            if not result:
                node_colors.append("gray")
                status_labels[node] = "No data"
                continue
            
            # Determine color based on status
            if result.overall_status == VerificationStatus.PASS:
                node_colors.append("lightgreen")
                status = "✓ PASS"
            elif result.overall_status == VerificationStatus.FAIL:
                node_colors.append("red")
                status = "✗ FAIL"
            else:
                node_colors.append("gray")
                status = "? UNKNOWN"
            
            # Create node label
            node_labels[node] = node
            
            # Create status label
            status_lines = [f"Status: {status}"]
            
            if result.vlan_status:
                status_lines.append(f"VLAN: {result.vlan_status}")
            
            if result.port_status:
                status_lines.append(f"Port: {result.port_status}")
            
            if result.trunk_status:
                status_lines.append(f"Trunk: {result.trunk_status}")
            
            if result.role:
                status_lines.append(f"Role: {result.role}")
            
            status_labels[node] = "\n".join(status_lines[:4])  # Limit to 4 lines
        
        # Draw network graph
        nx.draw_networkx_nodes(G, pos, node_color=node_colors, node_size=5000, 
                              edgecolors='black', linewidths=2)
        nx.draw_networkx_edges(G, pos, width=3, edge_color='steelblue', 
                              arrows=True, arrowstyle='-|>', arrowsize=30)
        
        # Add device labels (above nodes)
        name_pos = {k: (v[0], v[1] + 0.8) for k, v in pos.items()}
        nx.draw_networkx_labels(G, name_pos, labels=node_labels, font_size=10, 
                               font_weight="bold")
        
        # Add status labels (below nodes)
        status_pos = {k: (v[0], v[1] - 1.2) for k, v in pos.items()}
        nx.draw_networkx_labels(G, status_pos, labels=status_labels, font_size=8,
                               bbox=dict(facecolor='white', edgecolor='black',
                                       boxstyle='round,pad=0.5', alpha=0.9))
        
        # Add legend
        legend_elements = [
            plt.Line2D([0], [0], marker='o', color='w', label='Pass', 
                      markerfacecolor='lightgreen', markersize=15),
            plt.Line2D([0], [0], marker='o', color='w', label='Fail', 
                      markerfacecolor='red', markersize=15),
            plt.Line2D([0], [0], marker='o', color='w', label='Unknown', 
                      markerfacecolor='gray', markersize=15)
        ]
        
        plt.legend(handles=legend_elements, loc='upper right', fontsize=12, 
                  title="Verification Status", title_fontsize=14)
        
        plt.title("Network VLAN Path Verification Results", pad=40, fontsize=18, 
                 fontweight='bold')
        plt.axis('off')
        plt.tight_layout()
        plt.show(block=True)
        plt.ion()


def main():
    """Main function to run VLAN path verification"""
    # Configuration
    initial_switch = "172.17.57.243"
    target_port = "GigabitEthernet1/0/10"
    vlan_id = "5"
    
    # Create verifier instance
    verifier = NetworkVerifier(config_file="config.yaml")
    
    try:
        # Run verification
        success, message, path, results = verifier.verify_vlan_path(
            initial_switch, target_port, vlan_id
        )
        
        # Print results
        print("\n" + "="*60)
        print(f"VLAN PATH VERIFICATION {'SUCCEEDED' if success else 'FAILED'}")
        print("="*60)
        print(f"Initial Switch: {initial_switch}")
        print(f"Target Port: {target_port}")
        print(f"VLAN ID: {vlan_id}")
        print(f"Path: {' → '.join(path)}")
        print(f"Status: {message}")
        print("="*60)
        
        # Detailed results
        print("\nDETAILED RESULTS:")
        print("-" * 40)
        for device_ip, result in results.items():
            print(f"\nDevice: {device_ip}")
            print(f"  Overall Status: {result.overall_status.value.upper()}")
            print(f"  VLAN Status: {result.vlan_status}")
            if result.port_status:
                print(f"  Port Status: {result.port_status}")
            if result.trunk_status:
                print(f"  Trunk Status: {result.trunk_status}")
            if result.role:
                print(f"  Role: {result.role}")
        
        # Show visualization
        if path and results:
            print("\nGenerating network visualization...")
            verifier.visualize_path(path, results)
        
        return success
        
    except Exception as e:
        logger.error(f"Verification failed with error: {str(e)}")
        print(f"\nERROR: Verification failed - {str(e)}")
        return False
    
    finally:
        # Cleanup
        if hasattr(verifier, 'nr') and verifier.nr:
            verifier.nr.close_connections()


if __name__ == "__main__":
    import sys
    
    # Allow command line arguments
    if len(sys.argv) >= 4:
        initial_switch = sys.argv[1]
        target_port = sys.argv[2]
        vlan_id = sys.argv[3]
        
        verifier = NetworkVerifier()
        success, message, path, results = verifier.verify_vlan_path(
            initial_switch, target_port, vlan_id
        )
        
        if success:
            print(f"✓ VLAN {vlan_id} path verification successful")
            sys.exit(0)
        else:
            print(f"✗ VLAN {vlan_id} path verification failed: {message}")
            sys.exit(1)
    else:
        # Use default configuration
        success = main()
        sys.exit(0 if success else 1)= resolve_neighbor_name(neighbor)
from nornir import InitNornir
from nornir_netmiko import netmiko_send_command
from nornir.core.task import Task, Result
from typing import Dict, List, Tuple, Optional, Set
import networkx as nx
import matplotlib.pyplot as plt
import re
import logging
from dataclasses import dataclass
from enum import Enum

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class VerificationStatus(Enum):
    PASS = "pass"
    FAIL = "fail"
    UNKNOWN = "unknown"

@dataclass
class DeviceResult:
    device_ip: str
    vlan_status: str
    port_status: Optional[str] = None
    trunk_status: Optional[str] = None
    role: Optional[str] = None
    overall_status: VerificationStatus = VerificationStatus.UNKNOWN

class NetworkVerifier:
    def __init__(self, config_file: str = "config.yaml"):
        self.nr = InitNornir(config_file=config_file)
        self.max_hops = 15
        
    def get_lldp_neighbors(self, task: Task) -> List[Dict]:
        """Collect LLDP neighbor information in a vendor-neutral way"""
        platform = task.host.platform
        
        # Enhanced command mapping for different platforms
        command_map = {
            "aruba_cx": "show lldp neighbors detail",
            "cisco_ios": "show lldp neighbors detail",
            "cisco_xe": "show lldp neighbors detail",
            "hp_comware": "display lldp neighbor-information",
            "juniper": "show lldp neighbors detail"
        }
        
        command = command_map.get(platform, "show lldp neighbors detail")
        
        logger.debug(f"Running on {task.host}: {command}")
        
        try:
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            # Handle different result types
            if isinstance(result.result, str):
                logger.warning(f"TextFSM parsing failed for {task.host}, attempting manual parsing")
                return self._parse_lldp_manually(result.result, platform)
            elif isinstance(result.result, dict):
                return [result.result]
            elif isinstance(result.result, list):
                return result.result
            else:
                logger.warning(f"No LLDP neighbors found on {task.host}")
                return []
                
        except Exception as e:
            logger.error(f"Error getting LLDP neighbors on {task.host}: {str(e)}")
            return []

    def _parse_lldp_manually(self, output: str, platform: str) -> List[Dict]:
        """Manual parsing fallback for when TextFSM fails"""
        neighbors = []
        
        try:
            # Basic regex patterns for common LLDP output formats
            if platform == "cisco_ios":
                # Cisco IOS LLDP format
                pattern = r'Device ID: (\S+).*?Local Intf: (\S+).*?Port id: (\S+)'
                matches = re.findall(pattern, output, re.DOTALL)
                
                for match in matches:
                    neighbors.append({
                        'neighbor': match[0],
                        'local_interface': match[1],
                        'neighbor_port': match[2]
                    })
            
            # Add more platform-specific parsing as needed
            
        except Exception as e:
            logger.error(f"Manual LLDP parsing failed: {str(e)}")
            
        return neighbors

    def find_uplink_port(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find the local interface connected to a neighbor with improved error handling"""
        platform = task.host.platform
        
        try:
            # Try LLDP first (most reliable)
            lldp_result = self._find_port_via_lldp(task, neighbor_ip, platform)
            if lldp_result:
                return lldp_result
            
            # Fall back to CDP for Cisco devices
            if platform.startswith("cisco"):
                cdp_result = self._find_port_via_cdp(task, neighbor_ip)
                if cdp_result:
                    return cdp_result
                    
            # Last resort: MAC address table lookup
            mac_result = self._find_port_via_mac(task, neighbor_ip)
            if mac_result:
                return mac_result
                
        except Exception as e:
            logger.error(f"Error finding uplink port on {task.host}: {str(e)}")
        
        return None

    def _find_port_via_lldp(self, task: Task, neighbor_ip: str, platform: str) -> Optional[str]:
        """Find port using LLDP"""
        try:
            neighbors = self.get_lldp_neighbors(task)
            
            for neighbor in neighbors:
                # Check multiple possible neighbor identifier fields
                neighbor_id = (neighbor.get('neighbor') or 
                             neighbor.get('mgmt_address') or 
                             neighbor.get('system_name'))
                
                if neighbor_id and (neighbor_id == neighbor_ip or 
                                  neighbor_id.startswith(neighbor_ip.split('.')[0])):
                    return neighbor.get('local_interface')
                    
        except Exception as e:
            logger.debug(f"LLDP port lookup failed: {str(e)}")
            
        return None

    def _find_port_via_cdp(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find port using CDP (Cisco devices)"""
        try:
            command = "show cdp neighbors detail"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if result.result:
                for neighbor in (result.result if isinstance(result.result, list) else [result.result]):
                    if neighbor.get('mgmt_address') == neighbor_ip:
                        return neighbor.get('local_port')
                        
        except Exception as e:
            logger.debug(f"CDP port lookup failed: {str(e)}")
            
        return None

    def _find_port_via_mac(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find port using MAC address table (least reliable)"""
        try:
            # This would require ARP table lookup first, then MAC table
            # Implementation depends on specific requirements
            pass
        except Exception as e:
            logger.debug(f"MAC table port lookup failed: {str(e)}")
            
        return None

    def verify_vlan_exists(self, task: Task, vlan_id: str) -> bool:
        """Check if VLAN exists with enhanced platform support"""
        platform = task.host.platform
        
        command_map = {
            "aruba_cx": f"show vlan {vlan_id}",
            "cisco_ios": f"show vlan id {vlan_id}",
            "cisco_xe": f"show vlan id {vlan_id}",
            "hp_comware": f"display vlan {vlan_id}",
            "juniper": f"show vlans {vlan_id}"
        }
        
        command = command_map.get(platform, f"show vlan id {vlan_id}")
        
        try:
            logger.debug(f"Running on {task.host}: {command}")
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if isinstance(result.result, str):
                # Check for common error messages
                error_indicators = ["invalid", "not found", "does not exist", "error"]
                return not any(indicator in result.result.lower() for indicator in error_indicators)
            
            return bool(result.result)
            
        except Exception as e:
            logger.error(f"Error checking VLAN on {task.host}: {str(e)}")
            return False

    def verify_access_vlan(self, task: Task, interface: str, vlan_id: str) -> bool:
        """Verify access port VLAN configuration with better error handling"""
        platform = task.host.platform
        
        try:
            # Method 1: Check VLAN membership
            if self._check_vlan_membership(task, interface, vlan_id, platform):
                return True
            
            # Method 2: Check interface configuration
            if self._check_interface_config(task, interface, vlan_id, platform):
                return True
            
            logger.debug(f"Access VLAN {vlan_id} not found on {interface}")
            return False
            
        except Exception as e:
            logger.error(f"Error checking access port on {task.host}: {str(e)}")
            return False

    def _check_vlan_membership(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check VLAN membership tables"""
        try:
            command_map = {
                "aruba_cx": f"show vlan {vlan_id}",
                "cisco_ios": f"show vlan id {vlan_id}",
                "cisco_xe": f"show vlan id {vlan_id}",
            }
            
            command = command_map.get(platform, f"show vlan id {vlan_id}")
            
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if result.result:
                for vlan in (result.result if isinstance(result.result, list) else [result.result]):
                    interfaces = vlan.get('interfaces', [])
                    if isinstance(interfaces, str):
                        interfaces = [interfaces]
                    
                    # Normalize interface names for comparison
                    normalized_interfaces = [self._normalize_interface_name(intf) for intf in interfaces]
                    normalized_target = self._normalize_interface_name(interface)
                    
                    if normalized_target in normalized_interfaces:
                        return True
                        
        except Exception as e:
            logger.debug(f"VLAN membership check failed: {str(e)}")
            
        return False

    def _check_interface_config(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check interface running configuration"""
        try:
            command = f"show running-config interface {interface}"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=False,
                enable=True
            )
            
            config = result.result.lower()
            
            # Platform-specific config patterns
            patterns = {
                "aruba_cx": [f"vlan access {vlan_id}"],
                "cisco_ios": [f"switchport access vlan {vlan_id}"],
                "cisco_xe": [f"switchport access vlan {vlan_id}"],
            }
            
            check_patterns = patterns.get(platform, [f"switchport access vlan {vlan_id}"])
            
            return any(pattern in config for pattern in check_patterns)
            
        except Exception as e:
            logger.debug(f"Interface config check failed: {str(e)}")
            
        return False

    def _normalize_interface_name(self, interface: str) -> str:
        """Normalize interface names for comparison"""
        # Handle common abbreviations
        interface = interface.replace("GigabitEthernet", "Gi")
        interface = interface.replace("FastEthernet", "Fa")
        interface = interface.replace("TenGigabitEthernet", "Te")
        
        # Remove spaces and convert to lowercase
        return interface.replace(" ", "").lower()

    def verify_trunk_vlan(self, task: Task, interface: str, vlan_id: str) -> bool:
        """Verify trunk allows the VLAN with comprehensive checking"""
        platform = task.host.platform
        
        try:
            # Method 1: Check switchport status
            if self._check_switchport_trunk(task, interface, vlan_id, platform):
                return True
            
            # Method 2: Check running configuration
            if self._check_trunk_config(task, interface, vlan_id, platform):
                return True
            
            return False
            
        except Exception as e:
            logger.error(f"Error checking trunk on {task.host}: {str(e)}")
            return False

    def _check_switchport_trunk(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check switchport trunk status"""
        try:
            command = f"show interfaces {interface} switchport"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if isinstance(result.result, str):
                # Parse raw output
                return self._parse_trunk_raw_output(result.result, vlan_id)
            
            if result.result and isinstance(result.result, list):
                sw_data = result.result[0]
                
                # Check if port is in trunk mode
                if sw_data.get('mode', '').lower() != 'trunk':
                    return False
                
                # Check allowed VLANs
                return self._check_allowed_vlans(sw_data, vlan_id)
                
        except Exception as e:
            logger.debug(f"Switchport trunk check failed: {str(e)}")
            
        return False

    def _parse_trunk_raw_output(self, output: str, vlan_id: str) -> bool:
        """Parse raw switchport output"""
        output_lower = output.lower()
        
        if "trunking" in output_lower:
            if "vlans allowed: all" in output_lower:
                return True
            if f"vlans allowed: {vlan_id}" in output_lower:
                return True
        
        return False

    def _check_allowed_vlans(self, switchport_data: Dict, vlan_id: str) -> bool:
        """Check if VLAN is in allowed VLAN list"""
        for field in ['trunking_vlans', 'vlans_allowed', 'allowed_vlans']:
            vlans = switchport_data.get(field, '')
            
            if vlans:
                if vlans.upper() == 'ALL':
                    return True
                if self._is_vlan_in_list(vlans, vlan_id):
                    return True
        
        return False

    def _check_trunk_config(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check trunk configuration in running config"""
        try:
            command = f"show running-config interface {interface}"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                enable=True
            )
            
            config = result.result.lower()
            
            # If trunk mode is configured but no allowed VLAN restrictions, assume all VLANs allowed
            if "switchport mode trunk" in config and "switchport trunk allowed vlan" not in config:
                return True
            
            # Check specific VLAN allowances
            if f"switchport trunk allowed vlan add {vlan_id}" in config:
                return True
            
            return False
            
        except Exception as e:
            logger.debug(f"Trunk config check failed: {str(e)}")
            
        return False

    def _is_vlan_in_list(self, vlan_str: str, target_vlan: str) -> bool:
        """Helper to safely parse VLAN lists (1,5,10-20,30)"""
        try:
            if not vlan_str:
                return False
                
            target_int = int(target_vlan)
            
            for part in str(vlan_str).split(','):
                part = part.strip()
                
                if '-' in part:
                    # Handle range (e.g., "10-20")
                    start, end = map(int, part.split('-'))
                    if start <= target_int <= end:
                        return True
                elif part.isdigit() and int(part) == target_int:
                    return True
                    
            return False
            
        except (ValueError, AttributeError) as e:
            logger.error(f"VLAN list parsing failed: {str(e)}")
            return False

    def trace_path_to_router(self, start_device: str) -> List[str]:
        """Trace path from edge switch to router using LLDP with improved logic"""
        logger.info("Starting path trace to router...")
        
        path = []
        current_device = start_device
        visited: Set[str] = set()
        
        # Get target router
        try:
            target_router = self.nr.inventory.hosts[start_device].data.get('router')
            if not target_router:
                logger.error(f"No router defined for {start_device}")
                return []
        except KeyError:
            logger.error(f"Device {start_device} not found in inventory")
            return []

        logger.info(f"Target router: {target_router}")

        while current_device and current_device not in visited and len(path) < self.max_hops:
            visited.add(current_device)
            path.append(current_device)
            
            logger.debug(f"Current device: {current_device}")
            logger.debug(f"Current path: {' -> '.join(path)}")
            
            # Check if we've reached the target router
            if current_device == target_router:
                logger.info(f"Reached target router: {current_device}")
                break
            
            # Get neighbors and find next hop
            next_hop = self._find_next_hop(current_device, target_router, visited)
            if not next_hop:
                logger.warning(f"No valid next hop found from {current_device}")
                break
                
            current_device = next_hop

        # Ensure router is in path
        if path and path[-1] != target_router:
            path.append(target_router)
            logger.debug(f"Added router {target_router} to path")

        logger.info(f"Final path: {' -> '.join(path)}")
        return path

    def _find_next_hop(self, current_device: str, target_router: str, visited: Set[str]) -> Optional[str]:
        """Find the next hop in the path"""
        try:
            neighbors_result = self.nr.filter(name=current_device).run(task=self.get_lldp_neighbors)
            neighbors = neighbors_result[current_device].result
            
            if not neighbors:
                logger.debug(f"No neighbors found for {current_device}")
                return None
            
            # Find unvisited neighbors
            possible_hops = []
            for neighbor in (neighbors if isinstance(neighbors, list) else [neighbors]):
                if isinstance(neighbor, dict):
                    neighbor_ip = self._extract_neighbor_ip(neighbor)
                    
                    if neighbor_ip and neighbor_ip not in visited:
                        # Try to resolve to inventory hostname
                        resolved_ip = self._resolve_neighbor_ip(neighbor_ip)
                        if resolved_ip:
                            possible_hops.append(resolved_ip)
            
            if not possible_hops:
                return None
            
            # Prioritize direct connection to router
            if target_router in possible_hops:
                return target_router
            
            # Prioritize devices that have the target router configured
            for hop in possible_hops:
                try:
                    if self.nr.inventory.hosts[hop].data.get('router') == target_router:
                        return hop
                except KeyError:
                    continue
            
            # Return first available hop
            return possible_hops[0]
            
        except Exception as e:
            logger.error(f"Error finding next hop from {current_device}: {str(e)}")
            return None

    def _extract_neighbor_ip(self, neighbor: Dict) -> Optional[str]:
        """Extract neighbor IP from LLDP data"""
        neighbor_ip = (neighbor.get('mgmt_address') or 
                      neighbor.get('neighbor') or 
                      neighbor.get('neighbor_name') or
                      neighbor.get('system_name'))
        
        if neighbor_ip and '.' not in neighbor_ip:
            # Handle hostname format
            neighbor_ip = neighbor_ip.split('.')[0]
        
        return neighbor_ip

    def _resolve_neighbor_ip(self, neighbor_ip: str) -> Optional[str]:
        """Resolve neighbor IP to inventory hostname"""
        # Direct match
        if neighbor_ip in self.nr.inventory.hosts:
            return neighbor_ip
        
        # Hostname match
        for hostname, host in self.nr.inventory.hosts.items():
            if (host.get('hostname', '') == neighbor_ip or 
                hostname.startswith(neighbor_ip)):
                return hostname
        
        return None

    def verify_vlan_path(self, initial_switch: str, target_port: str, vlan_id: str) -> Tuple[bool, str, List[str], Dict[str, DeviceResult]]:
        """Comprehensive VLAN path verification"""
        logger.info("Starting VLAN path verification")
        
        # Trace path
        path = self.trace_path_to_router(initial_switch)
        if not path:
            return False, "No path found to router", [], {}

        # Verify each device in path
        results = {}
        overall_success = True
        failure_reasons = []
        
        for i, device_ip in enumerate(path):
            logger.info(f"Verifying device {i+1}/{len(path)}: {device_ip}")
            
            result = DeviceResult(device_ip=device_ip, vlan_status="Unknown")
            
            # Check VLAN exists
            vlan_exists = self.nr.filter(name=device_ip).run(
                task=self.verify_vlan_exists,
                vlan_id=vlan_id
            )[device_ip].result
            
            if vlan_exists:
                result.vlan_status = "VLAN exists"
                logger.debug(f"VLAN {vlan_id} exists on {device_ip}")
            else:
                result.vlan_status = "VLAN missing"
                result.overall_status = VerificationStatus.FAIL
                overall_success = False
                failure_reasons.append(f"VLAN {vlan_id} missing on {device_ip}")
                logger.warning(f"VLAN {vlan_id} missing on {device_ip}")
            
            # First device: check access port
            if i == 0:
                access_ok = self.nr.filter(name=device_ip).run(
                    task=self.verify_access_vlan,
                    interface=target_port,
                    vlan_id=vlan_id
                )[device_ip].result
                
                if access_ok:
                    result.port_status = "Access port configured"
                    logger.debug(f"Access port {target_port} configured on {device_ip}")
                else:
                    result.port_status = f"Port {target_port} not in VLAN {vlan_id}"
                    result.overall_status = VerificationStatus.FAIL
                    overall_success = False
                    failure_reasons.append(f"Port {target_port} not in VLAN {vlan_id}")
                    logger.warning(f"Port {target_port} not in VLAN {vlan_id}")
            
            # Intermediate devices: check trunk ports
            elif i < len(path) - 1:
                next_device = path[i + 1]
                uplink_port = self.nr.filter(name=device_ip).run(
                    task=self.find_uplink_port,
                    neighbor_ip=next_device
                )[device_ip].result
                
                if uplink_port:
                    trunk_ok = self.nr.filter(name=device_ip).run(
                        task=self.verify_trunk_vlan,
                        interface=uplink_port,
                        vlan_id=vlan_id
                    )[device_ip].result
                    
                    if trunk_ok:
                        result.trunk_status = f"Trunk {uplink_port} allows VLAN"
                        logger.debug(f"Trunk {uplink_port} allows VLAN {vlan_id}")
                    else:
                        result.trunk_status = f"VLAN {vlan_id} blocked on {uplink_port}"
                        result.overall_status = VerificationStatus.FAIL
                        overall_success = False
                        failure_reasons.append(f"VLAN {vlan_id} blocked on {uplink_port}")
                        logger.warning(f"VLAN {vlan_id} blocked on {uplink_port}")
                else:
                    result.trunk_status = f"No uplink found to {next_device}"
                    result.overall_status = VerificationStatus.FAIL
                    overall_success = False
                    failure_reasons.append(f"No uplink found to {next_device}")
                    logger.warning(f"No uplink found to {next_device}")
            
            # Router endpoint
            else:
                result.role = "Router endpoint"
                logger.debug(f"Router endpoint: {device_ip}")
            
            # Set overall status if not already failed
            if result.overall_status == VerificationStatus.UNKNOWN:
                result.overall_status = VerificationStatus.PASS
            
            results[device_ip] = result

        # Generate summary message
        if overall_success:
            message = f"VLAN {vlan_id} path fully verified"
        else:
            message = f"VLAN path verification failed: {'; '.join(failure_reasons[:3])}"
        
        logger.info(f"Verification complete: {message}")
        return overall_success, message, path, results

    def visualize_path(self, path: List[str], verification_results: Dict[str, DeviceResult]):
        """Create enhanced visualization of the network path"""
        plt.ioff()
        fig, ax = plt.subplots(figsize=(18, 12))
        
        # Create graph
        G = nx.path_graph(path)
        
        # Position nodes
        pos = {node: (i * 3, 0) for i, node in enumerate(G.nodes())}
        
        # Prepare node colors and labels
        node_colors = []
        node_labels = {}
        status_labels = {}
        
        for node in G.nodes():
            result = verification_results.get(node)
            if not result:
                node_colors.append("gray")
                status_labels[node] = "No data"
                continue
            
            # Determine color based on status
            if result.overall_status == VerificationStatus.PASS:
                node_colors.append("lightgreen")
                status = "✓ PASS"
            elif result.overall_status == VerificationStatus.FAIL:
                node_colors.append("red")
                status = "✗ FAIL"
            else:
                node_colors.append("gray")
                status = "? UNKNOWN"
            
            # Create node label
            node_labels[node] = node
            
            # Create status label
            status_lines = [f"Status: {status}"]
            
            if result.vlan_status:
                status_lines.append(f"VLAN: {result.vlan_status}")
            
            if result.port_status:
                status_lines.append(f"Port: {result.port_status}")
            
            if result.trunk_status:
                status_lines.append(f"Trunk: {result.trunk_status}")
            
            if result.role:
                status_lines.append(f"Role: {result.role}")
            
            status_labels[node] = "\n".join(status_lines[:4])  # Limit to 4 lines
        
        # Draw network graph
        nx.draw_networkx_nodes(G, pos, node_color=node_colors, node_size=5000, 
                              edgecolors='black', linewidths=2)
        nx.draw_networkx_edges(G, pos, width=3, edge_color='steelblue', 
                              arrows=True, arrowstyle='-|>', arrowsize=30)
        
        # Add device labels (above nodes)
        name_pos = {k: (v[0], v[1] + 0.8) for k, v in pos.items()}
        nx.draw_networkx_labels(G, name_pos, labels=node_labels, font_size=10, 
                               font_weight="bold")
        
        # Add status labels (below nodes)
        status_pos = {k: (v[0], v[1] - 1.2) for k, v in pos.items()}
        nx.draw_networkx_labels(G, status_pos, labels=status_labels, font_size=8,
                               bbox=dict(facecolor='white', edgecolor='black',
                                       boxstyle='round,pad=0.5', alpha=0.9))
        
        # Add legend
        legend_elements = [
            plt.Line2D([0], [0], marker='o', color='w', label='Pass', 
                      markerfacecolor='lightgreen', markersize=15),
            plt.Line2D([0], [0], marker='o', color='w', label='Fail', 
                      markerfacecolor='red', markersize=15),
            plt.Line2D([0], [0], marker='o', color='w', label='Unknown', 
                      markerfacecolor='gray', markersize=15)
        ]
        
        plt.legend(handles=legend_elements, loc='upper right', fontsize=12, 
                  title="Verification Status", title_fontsize=14)
        
        plt.title("Network VLAN Path Verification Results", pad=40, fontsize=18, 
                 fontweight='bold')
        plt.axis('off')
        plt.tight_layout()
        plt.show(block=True)
        plt.ion()


def main():
    """Main function to run VLAN path verification"""
    # Configuration
    initial_switch = "172.17.57.243"
    target_port = "GigabitEthernet1/0/10"
    vlan_id = "5"
    
    # Create verifier instance
    verifier = NetworkVerifier(config_file="config.yaml")
    
    try:
        # Run verification
        success, message, path, results = verifier.verify_vlan_path(
            initial_switch, target_port, vlan_id
        )
        
        # Print results
        print("\n" + "="*60)
        print(f"VLAN PATH VERIFICATION {'SUCCEEDED' if success else 'FAILED'}")
        print("="*60)
        print(f"Initial Switch: {initial_switch}")
        print(f"Target Port: {target_port}")
        print(f"VLAN ID: {vlan_id}")
        print(f"Path: {' → '.join(path)}")
        print(f"Status: {message}")
        print("="*60)
        
        # Detailed results
        print("\nDETAILED RESULTS:")
        print("-" * 40)
        for device_ip, result in results.items():
            print(f"\nDevice: {device_ip}")
            print(f"  Overall Status: {result.overall_status.value.upper()}")
            print(f"  VLAN Status: {result.vlan_status}")
            if result.port_status:
                print(f"  Port Status: {result.port_status}")
            if result.trunk_status:
                print(f"  Trunk Status: {result.trunk_status}")
            if result.role:
                print(f"  Role: {result.role}")
        
        # Show visualization
        if path and results:
            print("\nGenerating network visualization...")
            verifier.visualize_path(path, results)
        
        return success
        
    except Exception as e:
        logger.error(f"Verification failed with error: {str(e)}")
        print(f"\nERROR: Verification failed - {str(e)}")
        return False
    
    finally:
        # Cleanup
        if hasattr(verifier, 'nr') and verifier.nr:
            verifier.nr.close_connections()


if __name__ == "__main__":
    import sys
    
    # Allow command line arguments
    if len(sys.argv) >= 4:
        initial_switch = sys.argv[1]
        target_port = sys.argv[2]
        vlan_id = sys.argv[3]
        
        verifier = NetworkVerifier()
        success, message, path, results = verifier.verify_vlan_path(
            initial_switch, target_port, vlan_id
        )
        
        if success:
            print(f"✓ VLAN {vlan_id} path verification successful")
            sys.exit(0)
        else:
            print(f"✗ VLAN {vlan_id} path verification failed: {message}")
            sys.exit(1)
    else:
        # Use default configuration
        success = main()
        sys.exit(0 if success else 1)ce in nr.inventory.hosts:
from nornir import InitNornir
from nornir_netmiko import netmiko_send_command
from nornir.core.task import Task, Result
from typing import Dict, List, Tuple, Optional, Set
import networkx as nx
import matplotlib.pyplot as plt
import re
import logging
from dataclasses import dataclass
from enum import Enum

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class VerificationStatus(Enum):
    PASS = "pass"
    FAIL = "fail"
    UNKNOWN = "unknown"

@dataclass
class DeviceResult:
    device_ip: str
    vlan_status: str
    port_status: Optional[str] = None
    trunk_status: Optional[str] = None
    role: Optional[str] = None
    overall_status: VerificationStatus = VerificationStatus.UNKNOWN

class NetworkVerifier:
    def __init__(self, config_file: str = "config.yaml"):
        self.nr = InitNornir(config_file=config_file)
        self.max_hops = 15
        
    def get_lldp_neighbors(self, task: Task) -> List[Dict]:
        """Collect LLDP neighbor information in a vendor-neutral way"""
        platform = task.host.platform
        
        # Enhanced command mapping for different platforms
        command_map = {
            "aruba_cx": "show lldp neighbors detail",
            "cisco_ios": "show lldp neighbors detail",
            "cisco_xe": "show lldp neighbors detail",
            "hp_comware": "display lldp neighbor-information",
            "juniper": "show lldp neighbors detail"
        }
        
        command = command_map.get(platform, "show lldp neighbors detail")
        
        logger.debug(f"Running on {task.host}: {command}")
        
        try:
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            # Handle different result types
            if isinstance(result.result, str):
                logger.warning(f"TextFSM parsing failed for {task.host}, attempting manual parsing")
                return self._parse_lldp_manually(result.result, platform)
            elif isinstance(result.result, dict):
                return [result.result]
            elif isinstance(result.result, list):
                return result.result
            else:
                logger.warning(f"No LLDP neighbors found on {task.host}")
                return []
                
        except Exception as e:
            logger.error(f"Error getting LLDP neighbors on {task.host}: {str(e)}")
            return []

    def _parse_lldp_manually(self, output: str, platform: str) -> List[Dict]:
        """Manual parsing fallback for when TextFSM fails"""
        neighbors = []
        
        try:
            # Basic regex patterns for common LLDP output formats
            if platform == "cisco_ios":
                # Cisco IOS LLDP format
                pattern = r'Device ID: (\S+).*?Local Intf: (\S+).*?Port id: (\S+)'
                matches = re.findall(pattern, output, re.DOTALL)
                
                for match in matches:
                    neighbors.append({
                        'neighbor': match[0],
                        'local_interface': match[1],
                        'neighbor_port': match[2]
                    })
            
            # Add more platform-specific parsing as needed
            
        except Exception as e:
            logger.error(f"Manual LLDP parsing failed: {str(e)}")
            
        return neighbors

    def find_uplink_port(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find the local interface connected to a neighbor with improved error handling"""
        platform = task.host.platform
        
        try:
            # Try LLDP first (most reliable)
            lldp_result = self._find_port_via_lldp(task, neighbor_ip, platform)
            if lldp_result:
                return lldp_result
            
            # Fall back to CDP for Cisco devices
            if platform.startswith("cisco"):
                cdp_result = self._find_port_via_cdp(task, neighbor_ip)
                if cdp_result:
                    return cdp_result
                    
            # Last resort: MAC address table lookup
            mac_result = self._find_port_via_mac(task, neighbor_ip)
            if mac_result:
                return mac_result
                
        except Exception as e:
            logger.error(f"Error finding uplink port on {task.host}: {str(e)}")
        
        return None

    def _find_port_via_lldp(self, task: Task, neighbor_ip: str, platform: str) -> Optional[str]:
        """Find port using LLDP"""
        try:
            neighbors = self.get_lldp_neighbors(task)
            
            for neighbor in neighbors:
                # Check multiple possible neighbor identifier fields
                neighbor_id = (neighbor.get('neighbor') or 
                             neighbor.get('mgmt_address') or 
                             neighbor.get('system_name'))
                
                if neighbor_id and (neighbor_id == neighbor_ip or 
                                  neighbor_id.startswith(neighbor_ip.split('.')[0])):
                    return neighbor.get('local_interface')
                    
        except Exception as e:
            logger.debug(f"LLDP port lookup failed: {str(e)}")
            
        return None

    def _find_port_via_cdp(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find port using CDP (Cisco devices)"""
        try:
            command = "show cdp neighbors detail"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if result.result:
                for neighbor in (result.result if isinstance(result.result, list) else [result.result]):
                    if neighbor.get('mgmt_address') == neighbor_ip:
                        return neighbor.get('local_port')
                        
        except Exception as e:
            logger.debug(f"CDP port lookup failed: {str(e)}")
            
        return None

    def _find_port_via_mac(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find port using MAC address table (least reliable)"""
        try:
            # This would require ARP table lookup first, then MAC table
            # Implementation depends on specific requirements
            pass
        except Exception as e:
            logger.debug(f"MAC table port lookup failed: {str(e)}")
            
        return None

    def verify_vlan_exists(self, task: Task, vlan_id: str) -> bool:
        """Check if VLAN exists with enhanced platform support"""
        platform = task.host.platform
        
        command_map = {
            "aruba_cx": f"show vlan {vlan_id}",
            "cisco_ios": f"show vlan id {vlan_id}",
            "cisco_xe": f"show vlan id {vlan_id}",
            "hp_comware": f"display vlan {vlan_id}",
            "juniper": f"show vlans {vlan_id}"
        }
        
        command = command_map.get(platform, f"show vlan id {vlan_id}")
        
        try:
            logger.debug(f"Running on {task.host}: {command}")
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if isinstance(result.result, str):
                # Check for common error messages
                error_indicators = ["invalid", "not found", "does not exist", "error"]
                return not any(indicator in result.result.lower() for indicator in error_indicators)
            
            return bool(result.result)
            
        except Exception as e:
            logger.error(f"Error checking VLAN on {task.host}: {str(e)}")
            return False

    def verify_access_vlan(self, task: Task, interface: str, vlan_id: str) -> bool:
        """Verify access port VLAN configuration with better error handling"""
        platform = task.host.platform
        
        try:
            # Method 1: Check VLAN membership
            if self._check_vlan_membership(task, interface, vlan_id, platform):
                return True
            
            # Method 2: Check interface configuration
            if self._check_interface_config(task, interface, vlan_id, platform):
                return True
            
            logger.debug(f"Access VLAN {vlan_id} not found on {interface}")
            return False
            
        except Exception as e:
            logger.error(f"Error checking access port on {task.host}: {str(e)}")
            return False

    def _check_vlan_membership(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check VLAN membership tables"""
        try:
            command_map = {
                "aruba_cx": f"show vlan {vlan_id}",
                "cisco_ios": f"show vlan id {vlan_id}",
                "cisco_xe": f"show vlan id {vlan_id}",
            }
            
            command = command_map.get(platform, f"show vlan id {vlan_id}")
            
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if result.result:
                for vlan in (result.result if isinstance(result.result, list) else [result.result]):
                    interfaces = vlan.get('interfaces', [])
                    if isinstance(interfaces, str):
                        interfaces = [interfaces]
                    
                    # Normalize interface names for comparison
                    normalized_interfaces = [self._normalize_interface_name(intf) for intf in interfaces]
                    normalized_target = self._normalize_interface_name(interface)
                    
                    if normalized_target in normalized_interfaces:
                        return True
                        
        except Exception as e:
            logger.debug(f"VLAN membership check failed: {str(e)}")
            
        return False

    def _check_interface_config(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check interface running configuration"""
        try:
            command = f"show running-config interface {interface}"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=False,
                enable=True
            )
            
            config = result.result.lower()
            
            # Platform-specific config patterns
            patterns = {
                "aruba_cx": [f"vlan access {vlan_id}"],
                "cisco_ios": [f"switchport access vlan {vlan_id}"],
                "cisco_xe": [f"switchport access vlan {vlan_id}"],
            }
            
            check_patterns = patterns.get(platform, [f"switchport access vlan {vlan_id}"])
            
            return any(pattern in config for pattern in check_patterns)
            
        except Exception as e:
            logger.debug(f"Interface config check failed: {str(e)}")
            
        return False

    def _normalize_interface_name(self, interface: str) -> str:
        """Normalize interface names for comparison"""
        # Handle common abbreviations
        interface = interface.replace("GigabitEthernet", "Gi")
        interface = interface.replace("FastEthernet", "Fa")
        interface = interface.replace("TenGigabitEthernet", "Te")
        
        # Remove spaces and convert to lowercase
        return interface.replace(" ", "").lower()

    def verify_trunk_vlan(self, task: Task, interface: str, vlan_id: str) -> bool:
        """Verify trunk allows the VLAN with comprehensive checking"""
        platform = task.host.platform
        
        try:
            # Method 1: Check switchport status
            if self._check_switchport_trunk(task, interface, vlan_id, platform):
                return True
            
            # Method 2: Check running configuration
            if self._check_trunk_config(task, interface, vlan_id, platform):
                return True
            
            return False
            
        except Exception as e:
            logger.error(f"Error checking trunk on {task.host}: {str(e)}")
            return False

    def _check_switchport_trunk(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check switchport trunk status"""
        try:
            command = f"show interfaces {interface} switchport"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if isinstance(result.result, str):
                # Parse raw output
                return self._parse_trunk_raw_output(result.result, vlan_id)
            
            if result.result and isinstance(result.result, list):
                sw_data = result.result[0]
                
                # Check if port is in trunk mode
                if sw_data.get('mode', '').lower() != 'trunk':
                    return False
                
                # Check allowed VLANs
                return self._check_allowed_vlans(sw_data, vlan_id)
                
        except Exception as e:
            logger.debug(f"Switchport trunk check failed: {str(e)}")
            
        return False

    def _parse_trunk_raw_output(self, output: str, vlan_id: str) -> bool:
        """Parse raw switchport output"""
        output_lower = output.lower()
        
        if "trunking" in output_lower:
            if "vlans allowed: all" in output_lower:
                return True
            if f"vlans allowed: {vlan_id}" in output_lower:
                return True
        
        return False

    def _check_allowed_vlans(self, switchport_data: Dict, vlan_id: str) -> bool:
        """Check if VLAN is in allowed VLAN list"""
        for field in ['trunking_vlans', 'vlans_allowed', 'allowed_vlans']:
            vlans = switchport_data.get(field, '')
            
            if vlans:
                if vlans.upper() == 'ALL':
                    return True
                if self._is_vlan_in_list(vlans, vlan_id):
                    return True
        
        return False

    def _check_trunk_config(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check trunk configuration in running config"""
        try:
            command = f"show running-config interface {interface}"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                enable=True
            )
            
            config = result.result.lower()
            
            # If trunk mode is configured but no allowed VLAN restrictions, assume all VLANs allowed
            if "switchport mode trunk" in config and "switchport trunk allowed vlan" not in config:
                return True
            
            # Check specific VLAN allowances
            if f"switchport trunk allowed vlan add {vlan_id}" in config:
                return True
            
            return False
            
        except Exception as e:
            logger.debug(f"Trunk config check failed: {str(e)}")
            
        return False

    def _is_vlan_in_list(self, vlan_str: str, target_vlan: str) -> bool:
        """Helper to safely parse VLAN lists (1,5,10-20,30)"""
        try:
            if not vlan_str:
                return False
                
            target_int = int(target_vlan)
            
            for part in str(vlan_str).split(','):
                part = part.strip()
                
                if '-' in part:
                    # Handle range (e.g., "10-20")
                    start, end = map(int, part.split('-'))
                    if start <= target_int <= end:
                        return True
                elif part.isdigit() and int(part) == target_int:
                    return True
                    
            return False
            
        except (ValueError, AttributeError) as e:
            logger.error(f"VLAN list parsing failed: {str(e)}")
            return False

    def trace_path_to_router(self, start_device: str) -> List[str]:
        """Trace path from edge switch to router using LLDP with improved logic"""
        logger.info("Starting path trace to router...")
        
        path = []
        current_device = start_device
        visited: Set[str] = set()
        
        # Get target router
        try:
            target_router = self.nr.inventory.hosts[start_device].data.get('router')
            if not target_router:
                logger.error(f"No router defined for {start_device}")
                return []
        except KeyError:
            logger.error(f"Device {start_device} not found in inventory")
            return []

        logger.info(f"Target router: {target_router}")

        while current_device and current_device not in visited and len(path) < self.max_hops:
            visited.add(current_device)
            path.append(current_device)
            
            logger.debug(f"Current device: {current_device}")
            logger.debug(f"Current path: {' -> '.join(path)}")
            
            # Check if we've reached the target router
            if current_device == target_router:
                logger.info(f"Reached target router: {current_device}")
                break
            
            # Get neighbors and find next hop
            next_hop = self._find_next_hop(current_device, target_router, visited)
            if not next_hop:
                logger.warning(f"No valid next hop found from {current_device}")
                break
                
            current_device = next_hop

        # Ensure router is in path
        if path and path[-1] != target_router:
            path.append(target_router)
            logger.debug(f"Added router {target_router} to path")

        logger.info(f"Final path: {' -> '.join(path)}")
        return path

    def _find_next_hop(self, current_device: str, target_router: str, visited: Set[str]) -> Optional[str]:
        """Find the next hop in the path"""
        try:
            neighbors_result = self.nr.filter(name=current_device).run(task=self.get_lldp_neighbors)
            neighbors = neighbors_result[current_device].result
            
            if not neighbors:
                logger.debug(f"No neighbors found for {current_device}")
                return None
            
            # Find unvisited neighbors
            possible_hops = []
            for neighbor in (neighbors if isinstance(neighbors, list) else [neighbors]):
                if isinstance(neighbor, dict):
                    neighbor_ip = self._extract_neighbor_ip(neighbor)
                    
                    if neighbor_ip and neighbor_ip not in visited:
                        # Try to resolve to inventory hostname
                        resolved_ip = self._resolve_neighbor_ip(neighbor_ip)
                        if resolved_ip:
                            possible_hops.append(resolved_ip)
            
            if not possible_hops:
                return None
            
            # Prioritize direct connection to router
            if target_router in possible_hops:
                return target_router
            
            # Prioritize devices that have the target router configured
            for hop in possible_hops:
                try:
                    if self.nr.inventory.hosts[hop].data.get('router') == target_router:
                        return hop
                except KeyError:
                    continue
            
            # Return first available hop
            return possible_hops[0]
            
        except Exception as e:
            logger.error(f"Error finding next hop from {current_device}: {str(e)}")
            return None

    def _extract_neighbor_ip(self, neighbor: Dict) -> Optional[str]:
        """Extract neighbor IP from LLDP data"""
        neighbor_ip = (neighbor.get('mgmt_address') or 
                      neighbor.get('neighbor') or 
                      neighbor.get('neighbor_name') or
                      neighbor.get('system_name'))
        
        if neighbor_ip and '.' not in neighbor_ip:
            # Handle hostname format
            neighbor_ip = neighbor_ip.split('.')[0]
        
        return neighbor_ip

    def _resolve_neighbor_ip(self, neighbor_ip: str) -> Optional[str]:
        """Resolve neighbor IP to inventory hostname"""
        # Direct match
        if neighbor_ip in self.nr.inventory.hosts:
            return neighbor_ip
        
        # Hostname match
        for hostname, host in self.nr.inventory.hosts.items():
            if (host.get('hostname', '') == neighbor_ip or 
                hostname.startswith(neighbor_ip)):
                return hostname
        
        return None

    def verify_vlan_path(self, initial_switch: str, target_port: str, vlan_id: str) -> Tuple[bool, str, List[str], Dict[str, DeviceResult]]:
        """Comprehensive VLAN path verification"""
        logger.info("Starting VLAN path verification")
        
        # Trace path
        path = self.trace_path_to_router(initial_switch)
        if not path:
            return False, "No path found to router", [], {}

        # Verify each device in path
        results = {}
        overall_success = True
        failure_reasons = []
        
        for i, device_ip in enumerate(path):
            logger.info(f"Verifying device {i+1}/{len(path)}: {device_ip}")
            
            result = DeviceResult(device_ip=device_ip, vlan_status="Unknown")
            
            # Check VLAN exists
            vlan_exists = self.nr.filter(name=device_ip).run(
                task=self.verify_vlan_exists,
                vlan_id=vlan_id
            )[device_ip].result
            
            if vlan_exists:
                result.vlan_status = "VLAN exists"
                logger.debug(f"VLAN {vlan_id} exists on {device_ip}")
            else:
                result.vlan_status = "VLAN missing"
                result.overall_status = VerificationStatus.FAIL
                overall_success = False
                failure_reasons.append(f"VLAN {vlan_id} missing on {device_ip}")
                logger.warning(f"VLAN {vlan_id} missing on {device_ip}")
            
            # First device: check access port
            if i == 0:
                access_ok = self.nr.filter(name=device_ip).run(
                    task=self.verify_access_vlan,
                    interface=target_port,
                    vlan_id=vlan_id
                )[device_ip].result
                
                if access_ok:
                    result.port_status = "Access port configured"
                    logger.debug(f"Access port {target_port} configured on {device_ip}")
                else:
                    result.port_status = f"Port {target_port} not in VLAN {vlan_id}"
                    result.overall_status = VerificationStatus.FAIL
                    overall_success = False
                    failure_reasons.append(f"Port {target_port} not in VLAN {vlan_id}")
                    logger.warning(f"Port {target_port} not in VLAN {vlan_id}")
            
            # Intermediate devices: check trunk ports
            elif i < len(path) - 1:
                next_device = path[i + 1]
                uplink_port = self.nr.filter(name=device_ip).run(
                    task=self.find_uplink_port,
                    neighbor_ip=next_device
                )[device_ip].result
                
                if uplink_port:
                    trunk_ok = self.nr.filter(name=device_ip).run(
                        task=self.verify_trunk_vlan,
                        interface=uplink_port,
                        vlan_id=vlan_id
                    )[device_ip].result
                    
                    if trunk_ok:
                        result.trunk_status = f"Trunk {uplink_port} allows VLAN"
                        logger.debug(f"Trunk {uplink_port} allows VLAN {vlan_id}")
                    else:
                        result.trunk_status = f"VLAN {vlan_id} blocked on {uplink_port}"
                        result.overall_status = VerificationStatus.FAIL
                        overall_success = False
                        failure_reasons.append(f"VLAN {vlan_id} blocked on {uplink_port}")
                        logger.warning(f"VLAN {vlan_id} blocked on {uplink_port}")
                else:
                    result.trunk_status = f"No uplink found to {next_device}"
                    result.overall_status = VerificationStatus.FAIL
                    overall_success = False
                    failure_reasons.append(f"No uplink found to {next_device}")
                    logger.warning(f"No uplink found to {next_device}")
            
            # Router endpoint
            else:
                result.role = "Router endpoint"
                logger.debug(f"Router endpoint: {device_ip}")
            
            # Set overall status if not already failed
            if result.overall_status == VerificationStatus.UNKNOWN:
                result.overall_status = VerificationStatus.PASS
            
            results[device_ip] = result

        # Generate summary message
        if overall_success:
            message = f"VLAN {vlan_id} path fully verified"
        else:
            message = f"VLAN path verification failed: {'; '.join(failure_reasons[:3])}"
        
        logger.info(f"Verification complete: {message}")
        return overall_success, message, path, results

    def visualize_path(self, path: List[str], verification_results: Dict[str, DeviceResult]):
        """Create enhanced visualization of the network path"""
        plt.ioff()
        fig, ax = plt.subplots(figsize=(18, 12))
        
        # Create graph
        G = nx.path_graph(path)
        
        # Position nodes
        pos = {node: (i * 3, 0) for i, node in enumerate(G.nodes())}
        
        # Prepare node colors and labels
        node_colors = []
        node_labels = {}
        status_labels = {}
        
        for node in G.nodes():
            result = verification_results.get(node)
            if not result:
                node_colors.append("gray")
                status_labels[node] = "No data"
                continue
            
            # Determine color based on status
            if result.overall_status == VerificationStatus.PASS:
                node_colors.append("lightgreen")
                status = "✓ PASS"
            elif result.overall_status == VerificationStatus.FAIL:
                node_colors.append("red")
                status = "✗ FAIL"
            else:
                node_colors.append("gray")
                status = "? UNKNOWN"
            
            # Create node label
            node_labels[node] = node
            
            # Create status label
            status_lines = [f"Status: {status}"]
            
            if result.vlan_status:
                status_lines.append(f"VLAN: {result.vlan_status}")
            
            if result.port_status:
                status_lines.append(f"Port: {result.port_status}")
            
            if result.trunk_status:
                status_lines.append(f"Trunk: {result.trunk_status}")
            
            if result.role:
                status_lines.append(f"Role: {result.role}")
            
            status_labels[node] = "\n".join(status_lines[:4])  # Limit to 4 lines
        
        # Draw network graph
        nx.draw_networkx_nodes(G, pos, node_color=node_colors, node_size=5000, 
                              edgecolors='black', linewidths=2)
        nx.draw_networkx_edges(G, pos, width=3, edge_color='steelblue', 
                              arrows=True, arrowstyle='-|>', arrowsize=30)
        
        # Add device labels (above nodes)
        name_pos = {k: (v[0], v[1] + 0.8) for k, v in pos.items()}
        nx.draw_networkx_labels(G, name_pos, labels=node_labels, font_size=10, 
                               font_weight="bold")
        
        # Add status labels (below nodes)
        status_pos = {k: (v[0], v[1] - 1.2) for k, v in pos.items()}
        nx.draw_networkx_labels(G, status_pos, labels=status_labels, font_size=8,
                               bbox=dict(facecolor='white', edgecolor='black',
                                       boxstyle='round,pad=0.5', alpha=0.9))
        
        # Add legend
        legend_elements = [
            plt.Line2D([0], [0], marker='o', color='w', label='Pass', 
                      markerfacecolor='lightgreen', markersize=15),
            plt.Line2D([0], [0], marker='o', color='w', label='Fail', 
                      markerfacecolor='red', markersize=15),
            plt.Line2D([0], [0], marker='o', color='w', label='Unknown', 
                      markerfacecolor='gray', markersize=15)
        ]
        
        plt.legend(handles=legend_elements, loc='upper right', fontsize=12, 
                  title="Verification Status", title_fontsize=14)
        
        plt.title("Network VLAN Path Verification Results", pad=40, fontsize=18, 
                 fontweight='bold')
        plt.axis('off')
        plt.tight_layout()
        plt.show(block=True)
        plt.ion()


def main():
    """Main function to run VLAN path verification"""
    # Configuration
    initial_switch = "172.17.57.243"
    target_port = "GigabitEthernet1/0/10"
    vlan_id = "5"
    
    # Create verifier instance
    verifier = NetworkVerifier(config_file="config.yaml")
    
    try:
        # Run verification
        success, message, path, results = verifier.verify_vlan_path(
            initial_switch, target_port, vlan_id
        )
        
        # Print results
        print("\n" + "="*60)
        print(f"VLAN PATH VERIFICATION {'SUCCEEDED' if success else 'FAILED'}")
        print("="*60)
        print(f"Initial Switch: {initial_switch}")
        print(f"Target Port: {target_port}")
        print(f"VLAN ID: {vlan_id}")
        print(f"Path: {' → '.join(path)}")
        print(f"Status: {message}")
        print("="*60)
        
        # Detailed results
        print("\nDETAILED RESULTS:")
        print("-" * 40)
        for device_ip, result in results.items():
            print(f"\nDevice: {device_ip}")
            print(f"  Overall Status: {result.overall_status.value.upper()}")
            print(f"  VLAN Status: {result.vlan_status}")
            if result.port_status:
                print(f"  Port Status: {result.port_status}")
            if result.trunk_status:
                print(f"  Trunk Status: {result.trunk_status}")
            if result.role:
                print(f"  Role: {result.role}")
        
        # Show visualization
        if path and results:
            print("\nGenerating network visualization...")
            verifier.visualize_path(path, results)
        
        return success
        
    except Exception as e:
        logger.error(f"Verification failed with error: {str(e)}")
        print(f"\nERROR: Verification failed - {str(e)}")
        return False
    
    finally:
        # Cleanup
        if hasattr(verifier, 'nr') and verifier.nr:
            verifier.nr.close_connections()


if __name__ == "__main__":
    import sys
    
    # Allow command line arguments
    if len(sys.argv) >= 4:
        initial_switch = sys.argv[1]
        target_port = sys.argv[2]
        vlan_id = sys.argv[3]
        
        verifier = NetworkVerifier()
        success, message, path, results = verifier.verify_vlan_path(
            initial_switch, target_port, vlan_id
        )
        
        if success:
            print(f"✓ VLAN {vlan_id} path verification successful")
            sys.exit(0)
        else:
            print(f"✗ VLAN {vlan_id} path verification failed: {message}")
            sys.exit(1)
    else:
        # Use default configuration
        success = main()
        sys.exit(0 if success else 1) message = walk_vlan_path(next_device, iface, vlan_id, target_router, visited)
from nornir import InitNornir
from nornir_netmiko import netmiko_send_command
from nornir.core.task import Task, Result
from typing import Dict, List, Tuple, Optional, Set
import networkx as nx
import matplotlib.pyplot as plt
import re
import logging
from dataclasses import dataclass
from enum import Enum

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class VerificationStatus(Enum):
    PASS = "pass"
    FAIL = "fail"
    UNKNOWN = "unknown"

@dataclass
class DeviceResult:
    device_ip: str
    vlan_status: str
    port_status: Optional[str] = None
    trunk_status: Optional[str] = None
    role: Optional[str] = None
    overall_status: VerificationStatus = VerificationStatus.UNKNOWN

class NetworkVerifier:
    def __init__(self, config_file: str = "config.yaml"):
        self.nr = InitNornir(config_file=config_file)
        self.max_hops = 15
        
    def get_lldp_neighbors(self, task: Task) -> List[Dict]:
        """Collect LLDP neighbor information in a vendor-neutral way"""
        platform = task.host.platform
        
        # Enhanced command mapping for different platforms
        command_map = {
            "aruba_cx": "show lldp neighbors detail",
            "cisco_ios": "show lldp neighbors detail",
            "cisco_xe": "show lldp neighbors detail",
            "hp_comware": "display lldp neighbor-information",
            "juniper": "show lldp neighbors detail"
        }
        
        command = command_map.get(platform, "show lldp neighbors detail")
        
        logger.debug(f"Running on {task.host}: {command}")
        
        try:
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            # Handle different result types
            if isinstance(result.result, str):
                logger.warning(f"TextFSM parsing failed for {task.host}, attempting manual parsing")
                return self._parse_lldp_manually(result.result, platform)
            elif isinstance(result.result, dict):
                return [result.result]
            elif isinstance(result.result, list):
                return result.result
            else:
                logger.warning(f"No LLDP neighbors found on {task.host}")
                return []
                
        except Exception as e:
            logger.error(f"Error getting LLDP neighbors on {task.host}: {str(e)}")
            return []

    def _parse_lldp_manually(self, output: str, platform: str) -> List[Dict]:
        """Manual parsing fallback for when TextFSM fails"""
        neighbors = []
        
        try:
            # Basic regex patterns for common LLDP output formats
            if platform == "cisco_ios":
                # Cisco IOS LLDP format
                pattern = r'Device ID: (\S+).*?Local Intf: (\S+).*?Port id: (\S+)'
                matches = re.findall(pattern, output, re.DOTALL)
                
                for match in matches:
                    neighbors.append({
                        'neighbor': match[0],
                        'local_interface': match[1],
                        'neighbor_port': match[2]
                    })
            
            # Add more platform-specific parsing as needed
            
        except Exception as e:
            logger.error(f"Manual LLDP parsing failed: {str(e)}")
            
        return neighbors

    def find_uplink_port(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find the local interface connected to a neighbor with improved error handling"""
        platform = task.host.platform
        
        try:
            # Try LLDP first (most reliable)
            lldp_result = self._find_port_via_lldp(task, neighbor_ip, platform)
            if lldp_result:
                return lldp_result
            
            # Fall back to CDP for Cisco devices
            if platform.startswith("cisco"):
                cdp_result = self._find_port_via_cdp(task, neighbor_ip)
                if cdp_result:
                    return cdp_result
                    
            # Last resort: MAC address table lookup
            mac_result = self._find_port_via_mac(task, neighbor_ip)
            if mac_result:
                return mac_result
                
        except Exception as e:
            logger.error(f"Error finding uplink port on {task.host}: {str(e)}")
        
        return None

    def _find_port_via_lldp(self, task: Task, neighbor_ip: str, platform: str) -> Optional[str]:
        """Find port using LLDP"""
        try:
            neighbors = self.get_lldp_neighbors(task)
            
            for neighbor in neighbors:
                # Check multiple possible neighbor identifier fields
                neighbor_id = (neighbor.get('neighbor') or 
                             neighbor.get('mgmt_address') or 
                             neighbor.get('system_name'))
                
                if neighbor_id and (neighbor_id == neighbor_ip or 
                                  neighbor_id.startswith(neighbor_ip.split('.')[0])):
                    return neighbor.get('local_interface')
                    
        except Exception as e:
            logger.debug(f"LLDP port lookup failed: {str(e)}")
            
        return None

    def _find_port_via_cdp(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find port using CDP (Cisco devices)"""
        try:
            command = "show cdp neighbors detail"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if result.result:
                for neighbor in (result.result if isinstance(result.result, list) else [result.result]):
                    if neighbor.get('mgmt_address') == neighbor_ip:
                        return neighbor.get('local_port')
                        
        except Exception as e:
            logger.debug(f"CDP port lookup failed: {str(e)}")
            
        return None

    def _find_port_via_mac(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find port using MAC address table (least reliable)"""
        try:
            # This would require ARP table lookup first, then MAC table
            # Implementation depends on specific requirements
            pass
        except Exception as e:
            logger.debug(f"MAC table port lookup failed: {str(e)}")
            
        return None

    def verify_vlan_exists(self, task: Task, vlan_id: str) -> bool:
        """Check if VLAN exists with enhanced platform support"""
        platform = task.host.platform
        
        command_map = {
            "aruba_cx": f"show vlan {vlan_id}",
            "cisco_ios": f"show vlan id {vlan_id}",
            "cisco_xe": f"show vlan id {vlan_id}",
            "hp_comware": f"display vlan {vlan_id}",
            "juniper": f"show vlans {vlan_id}"
        }
        
        command = command_map.get(platform, f"show vlan id {vlan_id}")
        
        try:
            logger.debug(f"Running on {task.host}: {command}")
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if isinstance(result.result, str):
                # Check for common error messages
                error_indicators = ["invalid", "not found", "does not exist", "error"]
                return not any(indicator in result.result.lower() for indicator in error_indicators)
            
            return bool(result.result)
            
        except Exception as e:
            logger.error(f"Error checking VLAN on {task.host}: {str(e)}")
            return False

    def verify_access_vlan(self, task: Task, interface: str, vlan_id: str) -> bool:
        """Verify access port VLAN configuration with better error handling"""
        platform = task.host.platform
        
        try:
            # Method 1: Check VLAN membership
            if self._check_vlan_membership(task, interface, vlan_id, platform):
                return True
            
            # Method 2: Check interface configuration
            if self._check_interface_config(task, interface, vlan_id, platform):
                return True
            
            logger.debug(f"Access VLAN {vlan_id} not found on {interface}")
            return False
            
        except Exception as e:
            logger.error(f"Error checking access port on {task.host}: {str(e)}")
            return False

    def _check_vlan_membership(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check VLAN membership tables"""
        try:
            command_map = {
                "aruba_cx": f"show vlan {vlan_id}",
                "cisco_ios": f"show vlan id {vlan_id}",
                "cisco_xe": f"show vlan id {vlan_id}",
            }
            
            command = command_map.get(platform, f"show vlan id {vlan_id}")
            
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if result.result:
                for vlan in (result.result if isinstance(result.result, list) else [result.result]):
                    interfaces = vlan.get('interfaces', [])
                    if isinstance(interfaces, str):
                        interfaces = [interfaces]
                    
                    # Normalize interface names for comparison
                    normalized_interfaces = [self._normalize_interface_name(intf) for intf in interfaces]
                    normalized_target = self._normalize_interface_name(interface)
                    
                    if normalized_target in normalized_interfaces:
                        return True
                        
        except Exception as e:
            logger.debug(f"VLAN membership check failed: {str(e)}")
            
        return False

    def _check_interface_config(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check interface running configuration"""
        try:
            command = f"show running-config interface {interface}"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=False,
                enable=True
            )
            
            config = result.result.lower()
            
            # Platform-specific config patterns
            patterns = {
                "aruba_cx": [f"vlan access {vlan_id}"],
                "cisco_ios": [f"switchport access vlan {vlan_id}"],
                "cisco_xe": [f"switchport access vlan {vlan_id}"],
            }
            
            check_patterns = patterns.get(platform, [f"switchport access vlan {vlan_id}"])
            
            return any(pattern in config for pattern in check_patterns)
            
        except Exception as e:
            logger.debug(f"Interface config check failed: {str(e)}")
            
        return False

    def _normalize_interface_name(self, interface: str) -> str:
        """Normalize interface names for comparison"""
        # Handle common abbreviations
        interface = interface.replace("GigabitEthernet", "Gi")
        interface = interface.replace("FastEthernet", "Fa")
        interface = interface.replace("TenGigabitEthernet", "Te")
        
        # Remove spaces and convert to lowercase
        return interface.replace(" ", "").lower()

    def verify_trunk_vlan(self, task: Task, interface: str, vlan_id: str) -> bool:
        """Verify trunk allows the VLAN with comprehensive checking"""
        platform = task.host.platform
        
        try:
            # Method 1: Check switchport status
            if self._check_switchport_trunk(task, interface, vlan_id, platform):
                return True
            
            # Method 2: Check running configuration
            if self._check_trunk_config(task, interface, vlan_id, platform):
                return True
            
            return False
            
        except Exception as e:
            logger.error(f"Error checking trunk on {task.host}: {str(e)}")
            return False

    def _check_switchport_trunk(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check switchport trunk status"""
        try:
            command = f"show interfaces {interface} switchport"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if isinstance(result.result, str):
                # Parse raw output
                return self._parse_trunk_raw_output(result.result, vlan_id)
            
            if result.result and isinstance(result.result, list):
                sw_data = result.result[0]
                
                # Check if port is in trunk mode
                if sw_data.get('mode', '').lower() != 'trunk':
                    return False
                
                # Check allowed VLANs
                return self._check_allowed_vlans(sw_data, vlan_id)
                
        except Exception as e:
            logger.debug(f"Switchport trunk check failed: {str(e)}")
            
        return False

    def _parse_trunk_raw_output(self, output: str, vlan_id: str) -> bool:
        """Parse raw switchport output"""
        output_lower = output.lower()
        
        if "trunking" in output_lower:
            if "vlans allowed: all" in output_lower:
                return True
            if f"vlans allowed: {vlan_id}" in output_lower:
                return True
        
        return False

    def _check_allowed_vlans(self, switchport_data: Dict, vlan_id: str) -> bool:
        """Check if VLAN is in allowed VLAN list"""
        for field in ['trunking_vlans', 'vlans_allowed', 'allowed_vlans']:
            vlans = switchport_data.get(field, '')
            
            if vlans:
                if vlans.upper() == 'ALL':
                    return True
                if self._is_vlan_in_list(vlans, vlan_id):
                    return True
        
        return False

    def _check_trunk_config(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check trunk configuration in running config"""
        try:
            command = f"show running-config interface {interface}"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                enable=True
            )
            
            config = result.result.lower()
            
            # If trunk mode is configured but no allowed VLAN restrictions, assume all VLANs allowed
            if "switchport mode trunk" in config and "switchport trunk allowed vlan" not in config:
                return True
            
            # Check specific VLAN allowances
            if f"switchport trunk allowed vlan add {vlan_id}" in config:
                return True
            
            return False
            
        except Exception as e:
            logger.debug(f"Trunk config check failed: {str(e)}")
            
        return False

    def _is_vlan_in_list(self, vlan_str: str, target_vlan: str) -> bool:
        """Helper to safely parse VLAN lists (1,5,10-20,30)"""
        try:
            if not vlan_str:
                return False
                
            target_int = int(target_vlan)
            
            for part in str(vlan_str).split(','):
                part = part.strip()
                
                if '-' in part:
                    # Handle range (e.g., "10-20")
                    start, end = map(int, part.split('-'))
                    if start <= target_int <= end:
                        return True
                elif part.isdigit() and int(part) == target_int:
                    return True
                    
            return False
            
        except (ValueError, AttributeError) as e:
            logger.error(f"VLAN list parsing failed: {str(e)}")
            return False

    def trace_path_to_router(self, start_device: str) -> List[str]:
        """Trace path from edge switch to router using LLDP with improved logic"""
        logger.info("Starting path trace to router...")
        
        path = []
        current_device = start_device
        visited: Set[str] = set()
        
        # Get target router
        try:
            target_router = self.nr.inventory.hosts[start_device].data.get('router')
            if not target_router:
                logger.error(f"No router defined for {start_device}")
                return []
        except KeyError:
            logger.error(f"Device {start_device} not found in inventory")
            return []

        logger.info(f"Target router: {target_router}")

        while current_device and current_device not in visited and len(path) < self.max_hops:
            visited.add(current_device)
            path.append(current_device)
            
            logger.debug(f"Current device: {current_device}")
            logger.debug(f"Current path: {' -> '.join(path)}")
            
            # Check if we've reached the target router
            if current_device == target_router:
                logger.info(f"Reached target router: {current_device}")
                break
            
            # Get neighbors and find next hop
            next_hop = self._find_next_hop(current_device, target_router, visited)
            if not next_hop:
                logger.warning(f"No valid next hop found from {current_device}")
                break
                
            current_device = next_hop

        # Ensure router is in path
        if path and path[-1] != target_router:
            path.append(target_router)
            logger.debug(f"Added router {target_router} to path")

        logger.info(f"Final path: {' -> '.join(path)}")
        return path

    def _find_next_hop(self, current_device: str, target_router: str, visited: Set[str]) -> Optional[str]:
        """Find the next hop in the path"""
        try:
            neighbors_result = self.nr.filter(name=current_device).run(task=self.get_lldp_neighbors)
            neighbors = neighbors_result[current_device].result
            
            if not neighbors:
                logger.debug(f"No neighbors found for {current_device}")
                return None
            
            # Find unvisited neighbors
            possible_hops = []
            for neighbor in (neighbors if isinstance(neighbors, list) else [neighbors]):
                if isinstance(neighbor, dict):
                    neighbor_ip = self._extract_neighbor_ip(neighbor)
                    
                    if neighbor_ip and neighbor_ip not in visited:
                        # Try to resolve to inventory hostname
                        resolved_ip = self._resolve_neighbor_ip(neighbor_ip)
                        if resolved_ip:
                            possible_hops.append(resolved_ip)
            
            if not possible_hops:
                return None
            
            # Prioritize direct connection to router
            if target_router in possible_hops:
                return target_router
            
            # Prioritize devices that have the target router configured
            for hop in possible_hops:
                try:
                    if self.nr.inventory.hosts[hop].data.get('router') == target_router:
                        return hop
                except KeyError:
                    continue
            
            # Return first available hop
            return possible_hops[0]
            
        except Exception as e:
            logger.error(f"Error finding next hop from {current_device}: {str(e)}")
            return None

    def _extract_neighbor_ip(self, neighbor: Dict) -> Optional[str]:
        """Extract neighbor IP from LLDP data"""
        neighbor_ip = (neighbor.get('mgmt_address') or 
                      neighbor.get('neighbor') or 
                      neighbor.get('neighbor_name') or
                      neighbor.get('system_name'))
        
        if neighbor_ip and '.' not in neighbor_ip:
            # Handle hostname format
            neighbor_ip = neighbor_ip.split('.')[0]
        
        return neighbor_ip

    def _resolve_neighbor_ip(self, neighbor_ip: str) -> Optional[str]:
        """Resolve neighbor IP to inventory hostname"""
        # Direct match
        if neighbor_ip in self.nr.inventory.hosts:
            return neighbor_ip
        
        # Hostname match
        for hostname, host in self.nr.inventory.hosts.items():
            if (host.get('hostname', '') == neighbor_ip or 
                hostname.startswith(neighbor_ip)):
                return hostname
        
        return None

    def verify_vlan_path(self, initial_switch: str, target_port: str, vlan_id: str) -> Tuple[bool, str, List[str], Dict[str, DeviceResult]]:
        """Comprehensive VLAN path verification"""
        logger.info("Starting VLAN path verification")
        
        # Trace path
        path = self.trace_path_to_router(initial_switch)
        if not path:
            return False, "No path found to router", [], {}

        # Verify each device in path
        results = {}
        overall_success = True
        failure_reasons = []
        
        for i, device_ip in enumerate(path):
            logger.info(f"Verifying device {i+1}/{len(path)}: {device_ip}")
            
            result = DeviceResult(device_ip=device_ip, vlan_status="Unknown")
            
            # Check VLAN exists
            vlan_exists = self.nr.filter(name=device_ip).run(
                task=self.verify_vlan_exists,
                vlan_id=vlan_id
            )[device_ip].result
            
            if vlan_exists:
                result.vlan_status = "VLAN exists"
                logger.debug(f"VLAN {vlan_id} exists on {device_ip}")
            else:
                result.vlan_status = "VLAN missing"
                result.overall_status = VerificationStatus.FAIL
                overall_success = False
                failure_reasons.append(f"VLAN {vlan_id} missing on {device_ip}")
                logger.warning(f"VLAN {vlan_id} missing on {device_ip}")
            
            # First device: check access port
            if i == 0:
                access_ok = self.nr.filter(name=device_ip).run(
                    task=self.verify_access_vlan,
                    interface=target_port,
                    vlan_id=vlan_id
                )[device_ip].result
                
                if access_ok:
                    result.port_status = "Access port configured"
                    logger.debug(f"Access port {target_port} configured on {device_ip}")
                else:
                    result.port_status = f"Port {target_port} not in VLAN {vlan_id}"
                    result.overall_status = VerificationStatus.FAIL
                    overall_success = False
                    failure_reasons.append(f"Port {target_port} not in VLAN {vlan_id}")
                    logger.warning(f"Port {target_port} not in VLAN {vlan_id}")
            
            # Intermediate devices: check trunk ports
            elif i < len(path) - 1:
                next_device = path[i + 1]
                uplink_port = self.nr.filter(name=device_ip).run(
                    task=self.find_uplink_port,
                    neighbor_ip=next_device
                )[device_ip].result
                
                if uplink_port:
                    trunk_ok = self.nr.filter(name=device_ip).run(
                        task=self.verify_trunk_vlan,
                        interface=uplink_port,
                        vlan_id=vlan_id
                    )[device_ip].result
                    
                    if trunk_ok:
                        result.trunk_status = f"Trunk {uplink_port} allows VLAN"
                        logger.debug(f"Trunk {uplink_port} allows VLAN {vlan_id}")
                    else:
                        result.trunk_status = f"VLAN {vlan_id} blocked on {uplink_port}"
                        result.overall_status = VerificationStatus.FAIL
                        overall_success = False
                        failure_reasons.append(f"VLAN {vlan_id} blocked on {uplink_port}")
                        logger.warning(f"VLAN {vlan_id} blocked on {uplink_port}")
                else:
                    result.trunk_status = f"No uplink found to {next_device}"
                    result.overall_status = VerificationStatus.FAIL
                    overall_success = False
                    failure_reasons.append(f"No uplink found to {next_device}")
                    logger.warning(f"No uplink found to {next_device}")
            
            # Router endpoint
            else:
                result.role = "Router endpoint"
                logger.debug(f"Router endpoint: {device_ip}")
            
            # Set overall status if not already failed
            if result.overall_status == VerificationStatus.UNKNOWN:
                result.overall_status = VerificationStatus.PASS
            
            results[device_ip] = result

        # Generate summary message
        if overall_success:
            message = f"VLAN {vlan_id} path fully verified"
        else:
            message = f"VLAN path verification failed: {'; '.join(failure_reasons[:3])}"
        
        logger.info(f"Verification complete: {message}")
        return overall_success, message, path, results

    def visualize_path(self, path: List[str], verification_results: Dict[str, DeviceResult]):
        """Create enhanced visualization of the network path"""
        plt.ioff()
        fig, ax = plt.subplots(figsize=(18, 12))
        
        # Create graph
        G = nx.path_graph(path)
        
        # Position nodes
        pos = {node: (i * 3, 0) for i, node in enumerate(G.nodes())}
        
        # Prepare node colors and labels
        node_colors = []
        node_labels = {}
        status_labels = {}
        
        for node in G.nodes():
            result = verification_results.get(node)
            if not result:
                node_colors.append("gray")
                status_labels[node] = "No data"
                continue
            
            # Determine color based on status
            if result.overall_status == VerificationStatus.PASS:
                node_colors.append("lightgreen")
                status = "✓ PASS"
            elif result.overall_status == VerificationStatus.FAIL:
                node_colors.append("red")
                status = "✗ FAIL"
            else:
                node_colors.append("gray")
                status = "? UNKNOWN"
            
            # Create node label
            node_labels[node] = node
            
            # Create status label
            status_lines = [f"Status: {status}"]
            
            if result.vlan_status:
                status_lines.append(f"VLAN: {result.vlan_status}")
            
            if result.port_status:
                status_lines.append(f"Port: {result.port_status}")
            
            if result.trunk_status:
                status_lines.append(f"Trunk: {result.trunk_status}")
            
            if result.role:
                status_lines.append(f"Role: {result.role}")
            
            status_labels[node] = "\n".join(status_lines[:4])  # Limit to 4 lines
        
        # Draw network graph
        nx.draw_networkx_nodes(G, pos, node_color=node_colors, node_size=5000, 
                              edgecolors='black', linewidths=2)
        nx.draw_networkx_edges(G, pos, width=3, edge_color='steelblue', 
                              arrows=True, arrowstyle='-|>', arrowsize=30)
        
        # Add device labels (above nodes)
        name_pos = {k: (v[0], v[1] + 0.8) for k, v in pos.items()}
        nx.draw_networkx_labels(G, name_pos, labels=node_labels, font_size=10, 
                               font_weight="bold")
        
        # Add status labels (below nodes)
        status_pos = {k: (v[0], v[1] - 1.2) for k, v in pos.items()}
        nx.draw_networkx_labels(G, status_pos, labels=status_labels, font_size=8,
                               bbox=dict(facecolor='white', edgecolor='black',
                                       boxstyle='round,pad=0.5', alpha=0.9))
        
        # Add legend
        legend_elements = [
            plt.Line2D([0], [0], marker='o', color='w', label='Pass', 
                      markerfacecolor='lightgreen', markersize=15),
            plt.Line2D([0], [0], marker='o', color='w', label='Fail', 
                      markerfacecolor='red', markersize=15),
            plt.Line2D([0], [0], marker='o', color='w', label='Unknown', 
                      markerfacecolor='gray', markersize=15)
        ]
        
        plt.legend(handles=legend_elements, loc='upper right', fontsize=12, 
                  title="Verification Status", title_fontsize=14)
        
        plt.title("Network VLAN Path Verification Results", pad=40, fontsize=18, 
                 fontweight='bold')
        plt.axis('off')
        plt.tight_layout()
        plt.show(block=True)
        plt.ion()


def main():
    """Main function to run VLAN path verification"""
    # Configuration
    initial_switch = "172.17.57.243"
    target_port = "GigabitEthernet1/0/10"
    vlan_id = "5"
    
    # Create verifier instance
    verifier = NetworkVerifier(config_file="config.yaml")
    
    try:
        # Run verification
        success, message, path, results = verifier.verify_vlan_path(
            initial_switch, target_port, vlan_id
        )
        
        # Print results
        print("\n" + "="*60)
        print(f"VLAN PATH VERIFICATION {'SUCCEEDED' if success else 'FAILED'}")
        print("="*60)
        print(f"Initial Switch: {initial_switch}")
        print(f"Target Port: {target_port}")
        print(f"VLAN ID: {vlan_id}")
        print(f"Path: {' → '.join(path)}")
        print(f"Status: {message}")
        print("="*60)
        
        # Detailed results
        print("\nDETAILED RESULTS:")
        print("-" * 40)
        for device_ip, result in results.items():
            print(f"\nDevice: {device_ip}")
            print(f"  Overall Status: {result.overall_status.value.upper()}")
            print(f"  VLAN Status: {result.vlan_status}")
            if result.port_status:
                print(f"  Port Status: {result.port_status}")
            if result.trunk_status:
                print(f"  Trunk Status: {result.trunk_status}")
            if result.role:
                print(f"  Role: {result.role}")
        
        # Show visualization
        if path and results:
            print("\nGenerating network visualization...")
            verifier.visualize_path(path, results)
        
        return success
        
    except Exception as e:
        logger.error(f"Verification failed with error: {str(e)}")
        print(f"\nERROR: Verification failed - {str(e)}")
        return False
    
    finally:
        # Cleanup
        if hasattr(verifier, 'nr') and verifier.nr:
            verifier.nr.close_connections()


if __name__ == "__main__":
    import sys
    
    # Allow command line arguments
    if len(sys.argv) >= 4:
        initial_switch = sys.argv[1]
        target_port = sys.argv[2]
        vlan_id = sys.argv[3]
        
        verifier = NetworkVerifier()
        success, message, path, results = verifier.verify_vlan_path(
            initial_switch, target_port, vlan_id
        )
        
        if success:
            print(f"✓ VLAN {vlan_id} path verification successful")
            sys.exit(0)
        else:
            print(f"✗ VLAN {vlan_id} path verification failed: {message}")
            sys.exit(1)
    else:
        # Use default configuration
        success = main()
        sys.exit(0 if success else 1)ss:
from nornir import InitNornir
from nornir_netmiko import netmiko_send_command
from nornir.core.task import Task, Result
from typing import Dict, List, Tuple, Optional, Set
import networkx as nx
import matplotlib.pyplot as plt
import re
import logging
from dataclasses import dataclass
from enum import Enum

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class VerificationStatus(Enum):
    PASS = "pass"
    FAIL = "fail"
    UNKNOWN = "unknown"

@dataclass
class DeviceResult:
    device_ip: str
    vlan_status: str
    port_status: Optional[str] = None
    trunk_status: Optional[str] = None
    role: Optional[str] = None
    overall_status: VerificationStatus = VerificationStatus.UNKNOWN

class NetworkVerifier:
    def __init__(self, config_file: str = "config.yaml"):
        self.nr = InitNornir(config_file=config_file)
        self.max_hops = 15
        
    def get_lldp_neighbors(self, task: Task) -> List[Dict]:
        """Collect LLDP neighbor information in a vendor-neutral way"""
        platform = task.host.platform
        
        # Enhanced command mapping for different platforms
        command_map = {
            "aruba_cx": "show lldp neighbors detail",
            "cisco_ios": "show lldp neighbors detail",
            "cisco_xe": "show lldp neighbors detail",
            "hp_comware": "display lldp neighbor-information",
            "juniper": "show lldp neighbors detail"
        }
        
        command = command_map.get(platform, "show lldp neighbors detail")
        
        logger.debug(f"Running on {task.host}: {command}")
        
        try:
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            # Handle different result types
            if isinstance(result.result, str):
                logger.warning(f"TextFSM parsing failed for {task.host}, attempting manual parsing")
                return self._parse_lldp_manually(result.result, platform)
            elif isinstance(result.result, dict):
                return [result.result]
            elif isinstance(result.result, list):
                return result.result
            else:
                logger.warning(f"No LLDP neighbors found on {task.host}")
                return []
                
        except Exception as e:
            logger.error(f"Error getting LLDP neighbors on {task.host}: {str(e)}")
            return []

    def _parse_lldp_manually(self, output: str, platform: str) -> List[Dict]:
        """Manual parsing fallback for when TextFSM fails"""
        neighbors = []
        
        try:
            # Basic regex patterns for common LLDP output formats
            if platform == "cisco_ios":
                # Cisco IOS LLDP format
                pattern = r'Device ID: (\S+).*?Local Intf: (\S+).*?Port id: (\S+)'
                matches = re.findall(pattern, output, re.DOTALL)
                
                for match in matches:
                    neighbors.append({
                        'neighbor': match[0],
                        'local_interface': match[1],
                        'neighbor_port': match[2]
                    })
            
            # Add more platform-specific parsing as needed
            
        except Exception as e:
            logger.error(f"Manual LLDP parsing failed: {str(e)}")
            
        return neighbors

    def find_uplink_port(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find the local interface connected to a neighbor with improved error handling"""
        platform = task.host.platform
        
        try:
            # Try LLDP first (most reliable)
            lldp_result = self._find_port_via_lldp(task, neighbor_ip, platform)
            if lldp_result:
                return lldp_result
            
            # Fall back to CDP for Cisco devices
            if platform.startswith("cisco"):
                cdp_result = self._find_port_via_cdp(task, neighbor_ip)
                if cdp_result:
                    return cdp_result
                    
            # Last resort: MAC address table lookup
            mac_result = self._find_port_via_mac(task, neighbor_ip)
            if mac_result:
                return mac_result
                
        except Exception as e:
            logger.error(f"Error finding uplink port on {task.host}: {str(e)}")
        
        return None

    def _find_port_via_lldp(self, task: Task, neighbor_ip: str, platform: str) -> Optional[str]:
        """Find port using LLDP"""
        try:
            neighbors = self.get_lldp_neighbors(task)
            
            for neighbor in neighbors:
                # Check multiple possible neighbor identifier fields
                neighbor_id = (neighbor.get('neighbor') or 
                             neighbor.get('mgmt_address') or 
                             neighbor.get('system_name'))
                
                if neighbor_id and (neighbor_id == neighbor_ip or 
                                  neighbor_id.startswith(neighbor_ip.split('.')[0])):
                    return neighbor.get('local_interface')
                    
        except Exception as e:
            logger.debug(f"LLDP port lookup failed: {str(e)}")
            
        return None

    def _find_port_via_cdp(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find port using CDP (Cisco devices)"""
        try:
            command = "show cdp neighbors detail"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if result.result:
                for neighbor in (result.result if isinstance(result.result, list) else [result.result]):
                    if neighbor.get('mgmt_address') == neighbor_ip:
                        return neighbor.get('local_port')
                        
        except Exception as e:
            logger.debug(f"CDP port lookup failed: {str(e)}")
            
        return None

    def _find_port_via_mac(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find port using MAC address table (least reliable)"""
        try:
            # This would require ARP table lookup first, then MAC table
            # Implementation depends on specific requirements
            pass
        except Exception as e:
            logger.debug(f"MAC table port lookup failed: {str(e)}")
            
        return None

    def verify_vlan_exists(self, task: Task, vlan_id: str) -> bool:
        """Check if VLAN exists with enhanced platform support"""
        platform = task.host.platform
        
        command_map = {
            "aruba_cx": f"show vlan {vlan_id}",
            "cisco_ios": f"show vlan id {vlan_id}",
            "cisco_xe": f"show vlan id {vlan_id}",
            "hp_comware": f"display vlan {vlan_id}",
            "juniper": f"show vlans {vlan_id}"
        }
        
        command = command_map.get(platform, f"show vlan id {vlan_id}")
        
        try:
            logger.debug(f"Running on {task.host}: {command}")
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if isinstance(result.result, str):
                # Check for common error messages
                error_indicators = ["invalid", "not found", "does not exist", "error"]
                return not any(indicator in result.result.lower() for indicator in error_indicators)
            
            return bool(result.result)
            
        except Exception as e:
            logger.error(f"Error checking VLAN on {task.host}: {str(e)}")
            return False

    def verify_access_vlan(self, task: Task, interface: str, vlan_id: str) -> bool:
        """Verify access port VLAN configuration with better error handling"""
        platform = task.host.platform
        
        try:
            # Method 1: Check VLAN membership
            if self._check_vlan_membership(task, interface, vlan_id, platform):
                return True
            
            # Method 2: Check interface configuration
            if self._check_interface_config(task, interface, vlan_id, platform):
                return True
            
            logger.debug(f"Access VLAN {vlan_id} not found on {interface}")
            return False
            
        except Exception as e:
            logger.error(f"Error checking access port on {task.host}: {str(e)}")
            return False

    def _check_vlan_membership(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check VLAN membership tables"""
        try:
            command_map = {
                "aruba_cx": f"show vlan {vlan_id}",
                "cisco_ios": f"show vlan id {vlan_id}",
                "cisco_xe": f"show vlan id {vlan_id}",
            }
            
            command = command_map.get(platform, f"show vlan id {vlan_id}")
            
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if result.result:
                for vlan in (result.result if isinstance(result.result, list) else [result.result]):
                    interfaces = vlan.get('interfaces', [])
                    if isinstance(interfaces, str):
                        interfaces = [interfaces]
                    
                    # Normalize interface names for comparison
                    normalized_interfaces = [self._normalize_interface_name(intf) for intf in interfaces]
                    normalized_target = self._normalize_interface_name(interface)
                    
                    if normalized_target in normalized_interfaces:
                        return True
                        
        except Exception as e:
            logger.debug(f"VLAN membership check failed: {str(e)}")
            
        return False

    def _check_interface_config(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check interface running configuration"""
        try:
            command = f"show running-config interface {interface}"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=False,
                enable=True
            )
            
            config = result.result.lower()
            
            # Platform-specific config patterns
            patterns = {
                "aruba_cx": [f"vlan access {vlan_id}"],
                "cisco_ios": [f"switchport access vlan {vlan_id}"],
                "cisco_xe": [f"switchport access vlan {vlan_id}"],
            }
            
            check_patterns = patterns.get(platform, [f"switchport access vlan {vlan_id}"])
            
            return any(pattern in config for pattern in check_patterns)
            
        except Exception as e:
            logger.debug(f"Interface config check failed: {str(e)}")
            
        return False

    def _normalize_interface_name(self, interface: str) -> str:
        """Normalize interface names for comparison"""
        # Handle common abbreviations
        interface = interface.replace("GigabitEthernet", "Gi")
        interface = interface.replace("FastEthernet", "Fa")
        interface = interface.replace("TenGigabitEthernet", "Te")
        
        # Remove spaces and convert to lowercase
        return interface.replace(" ", "").lower()

    def verify_trunk_vlan(self, task: Task, interface: str, vlan_id: str) -> bool:
        """Verify trunk allows the VLAN with comprehensive checking"""
        platform = task.host.platform
        
        try:
            # Method 1: Check switchport status
            if self._check_switchport_trunk(task, interface, vlan_id, platform):
                return True
            
            # Method 2: Check running configuration
            if self._check_trunk_config(task, interface, vlan_id, platform):
                return True
            
            return False
            
        except Exception as e:
            logger.error(f"Error checking trunk on {task.host}: {str(e)}")
            return False

    def _check_switchport_trunk(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check switchport trunk status"""
        try:
            command = f"show interfaces {interface} switchport"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if isinstance(result.result, str):
                # Parse raw output
                return self._parse_trunk_raw_output(result.result, vlan_id)
            
            if result.result and isinstance(result.result, list):
                sw_data = result.result[0]
                
                # Check if port is in trunk mode
                if sw_data.get('mode', '').lower() != 'trunk':
                    return False
                
                # Check allowed VLANs
                return self._check_allowed_vlans(sw_data, vlan_id)
                
        except Exception as e:
            logger.debug(f"Switchport trunk check failed: {str(e)}")
            
        return False

    def _parse_trunk_raw_output(self, output: str, vlan_id: str) -> bool:
        """Parse raw switchport output"""
        output_lower = output.lower()
        
        if "trunking" in output_lower:
            if "vlans allowed: all" in output_lower:
                return True
            if f"vlans allowed: {vlan_id}" in output_lower:
                return True
        
        return False

    def _check_allowed_vlans(self, switchport_data: Dict, vlan_id: str) -> bool:
        """Check if VLAN is in allowed VLAN list"""
        for field in ['trunking_vlans', 'vlans_allowed', 'allowed_vlans']:
            vlans = switchport_data.get(field, '')
            
            if vlans:
                if vlans.upper() == 'ALL':
                    return True
                if self._is_vlan_in_list(vlans, vlan_id):
                    return True
        
        return False

    def _check_trunk_config(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check trunk configuration in running config"""
        try:
            command = f"show running-config interface {interface}"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                enable=True
            )
            
            config = result.result.lower()
            
            # If trunk mode is configured but no allowed VLAN restrictions, assume all VLANs allowed
            if "switchport mode trunk" in config and "switchport trunk allowed vlan" not in config:
                return True
            
            # Check specific VLAN allowances
            if f"switchport trunk allowed vlan add {vlan_id}" in config:
                return True
            
            return False
            
        except Exception as e:
            logger.debug(f"Trunk config check failed: {str(e)}")
            
        return False

    def _is_vlan_in_list(self, vlan_str: str, target_vlan: str) -> bool:
        """Helper to safely parse VLAN lists (1,5,10-20,30)"""
        try:
            if not vlan_str:
                return False
                
            target_int = int(target_vlan)
            
            for part in str(vlan_str).split(','):
                part = part.strip()
                
                if '-' in part:
                    # Handle range (e.g., "10-20")
                    start, end = map(int, part.split('-'))
                    if start <= target_int <= end:
                        return True
                elif part.isdigit() and int(part) == target_int:
                    return True
                    
            return False
            
        except (ValueError, AttributeError) as e:
            logger.error(f"VLAN list parsing failed: {str(e)}")
            return False

    def trace_path_to_router(self, start_device: str) -> List[str]:
        """Trace path from edge switch to router using LLDP with improved logic"""
        logger.info("Starting path trace to router...")
        
        path = []
        current_device = start_device
        visited: Set[str] = set()
        
        # Get target router
        try:
            target_router = self.nr.inventory.hosts[start_device].data.get('router')
            if not target_router:
                logger.error(f"No router defined for {start_device}")
                return []
        except KeyError:
            logger.error(f"Device {start_device} not found in inventory")
            return []

        logger.info(f"Target router: {target_router}")

        while current_device and current_device not in visited and len(path) < self.max_hops:
            visited.add(current_device)
            path.append(current_device)
            
            logger.debug(f"Current device: {current_device}")
            logger.debug(f"Current path: {' -> '.join(path)}")
            
            # Check if we've reached the target router
            if current_device == target_router:
                logger.info(f"Reached target router: {current_device}")
                break
            
            # Get neighbors and find next hop
            next_hop = self._find_next_hop(current_device, target_router, visited)
            if not next_hop:
                logger.warning(f"No valid next hop found from {current_device}")
                break
                
            current_device = next_hop

        # Ensure router is in path
        if path and path[-1] != target_router:
            path.append(target_router)
            logger.debug(f"Added router {target_router} to path")

        logger.info(f"Final path: {' -> '.join(path)}")
        return path

    def _find_next_hop(self, current_device: str, target_router: str, visited: Set[str]) -> Optional[str]:
        """Find the next hop in the path"""
        try:
            neighbors_result = self.nr.filter(name=current_device).run(task=self.get_lldp_neighbors)
            neighbors = neighbors_result[current_device].result
            
            if not neighbors:
                logger.debug(f"No neighbors found for {current_device}")
                return None
            
            # Find unvisited neighbors
            possible_hops = []
            for neighbor in (neighbors if isinstance(neighbors, list) else [neighbors]):
                if isinstance(neighbor, dict):
                    neighbor_ip = self._extract_neighbor_ip(neighbor)
                    
                    if neighbor_ip and neighbor_ip not in visited:
                        # Try to resolve to inventory hostname
                        resolved_ip = self._resolve_neighbor_ip(neighbor_ip)
                        if resolved_ip:
                            possible_hops.append(resolved_ip)
            
            if not possible_hops:
                return None
            
            # Prioritize direct connection to router
            if target_router in possible_hops:
                return target_router
            
            # Prioritize devices that have the target router configured
            for hop in possible_hops:
                try:
                    if self.nr.inventory.hosts[hop].data.get('router') == target_router:
                        return hop
                except KeyError:
                    continue
            
            # Return first available hop
            return possible_hops[0]
            
        except Exception as e:
            logger.error(f"Error finding next hop from {current_device}: {str(e)}")
            return None

    def _extract_neighbor_ip(self, neighbor: Dict) -> Optional[str]:
        """Extract neighbor IP from LLDP data"""
        neighbor_ip = (neighbor.get('mgmt_address') or 
                      neighbor.get('neighbor') or 
                      neighbor.get('neighbor_name') or
                      neighbor.get('system_name'))
        
        if neighbor_ip and '.' not in neighbor_ip:
            # Handle hostname format
            neighbor_ip = neighbor_ip.split('.')[0]
        
        return neighbor_ip

    def _resolve_neighbor_ip(self, neighbor_ip: str) -> Optional[str]:
        """Resolve neighbor IP to inventory hostname"""
        # Direct match
        if neighbor_ip in self.nr.inventory.hosts:
            return neighbor_ip
        
        # Hostname match
        for hostname, host in self.nr.inventory.hosts.items():
            if (host.get('hostname', '') == neighbor_ip or 
                hostname.startswith(neighbor_ip)):
                return hostname
        
        return None

    def verify_vlan_path(self, initial_switch: str, target_port: str, vlan_id: str) -> Tuple[bool, str, List[str], Dict[str, DeviceResult]]:
        """Comprehensive VLAN path verification"""
        logger.info("Starting VLAN path verification")
        
        # Trace path
        path = self.trace_path_to_router(initial_switch)
        if not path:
            return False, "No path found to router", [], {}

        # Verify each device in path
        results = {}
        overall_success = True
        failure_reasons = []
        
        for i, device_ip in enumerate(path):
            logger.info(f"Verifying device {i+1}/{len(path)}: {device_ip}")
            
            result = DeviceResult(device_ip=device_ip, vlan_status="Unknown")
            
            # Check VLAN exists
            vlan_exists = self.nr.filter(name=device_ip).run(
                task=self.verify_vlan_exists,
                vlan_id=vlan_id
            )[device_ip].result
            
            if vlan_exists:
                result.vlan_status = "VLAN exists"
                logger.debug(f"VLAN {vlan_id} exists on {device_ip}")
            else:
                result.vlan_status = "VLAN missing"
                result.overall_status = VerificationStatus.FAIL
                overall_success = False
                failure_reasons.append(f"VLAN {vlan_id} missing on {device_ip}")
                logger.warning(f"VLAN {vlan_id} missing on {device_ip}")
            
            # First device: check access port
            if i == 0:
                access_ok = self.nr.filter(name=device_ip).run(
                    task=self.verify_access_vlan,
                    interface=target_port,
                    vlan_id=vlan_id
                )[device_ip].result
                
                if access_ok:
                    result.port_status = "Access port configured"
                    logger.debug(f"Access port {target_port} configured on {device_ip}")
                else:
                    result.port_status = f"Port {target_port} not in VLAN {vlan_id}"
                    result.overall_status = VerificationStatus.FAIL
                    overall_success = False
                    failure_reasons.append(f"Port {target_port} not in VLAN {vlan_id}")
                    logger.warning(f"Port {target_port} not in VLAN {vlan_id}")
            
            # Intermediate devices: check trunk ports
            elif i < len(path) - 1:
                next_device = path[i + 1]
                uplink_port = self.nr.filter(name=device_ip).run(
                    task=self.find_uplink_port,
                    neighbor_ip=next_device
                )[device_ip].result
                
                if uplink_port:
                    trunk_ok = self.nr.filter(name=device_ip).run(
                        task=self.verify_trunk_vlan,
                        interface=uplink_port,
                        vlan_id=vlan_id
                    )[device_ip].result
                    
                    if trunk_ok:
                        result.trunk_status = f"Trunk {uplink_port} allows VLAN"
                        logger.debug(f"Trunk {uplink_port} allows VLAN {vlan_id}")
                    else:
                        result.trunk_status = f"VLAN {vlan_id} blocked on {uplink_port}"
                        result.overall_status = VerificationStatus.FAIL
                        overall_success = False
                        failure_reasons.append(f"VLAN {vlan_id} blocked on {uplink_port}")
                        logger.warning(f"VLAN {vlan_id} blocked on {uplink_port}")
                else:
                    result.trunk_status = f"No uplink found to {next_device}"
                    result.overall_status = VerificationStatus.FAIL
                    overall_success = False
                    failure_reasons.append(f"No uplink found to {next_device}")
                    logger.warning(f"No uplink found to {next_device}")
            
            # Router endpoint
            else:
                result.role = "Router endpoint"
                logger.debug(f"Router endpoint: {device_ip}")
            
            # Set overall status if not already failed
            if result.overall_status == VerificationStatus.UNKNOWN:
                result.overall_status = VerificationStatus.PASS
            
            results[device_ip] = result

        # Generate summary message
        if overall_success:
            message = f"VLAN {vlan_id} path fully verified"
        else:
            message = f"VLAN path verification failed: {'; '.join(failure_reasons[:3])}"
        
        logger.info(f"Verification complete: {message}")
        return overall_success, message, path, results

    def visualize_path(self, path: List[str], verification_results: Dict[str, DeviceResult]):
        """Create enhanced visualization of the network path"""
        plt.ioff()
        fig, ax = plt.subplots(figsize=(18, 12))
        
        # Create graph
        G = nx.path_graph(path)
        
        # Position nodes
        pos = {node: (i * 3, 0) for i, node in enumerate(G.nodes())}
        
        # Prepare node colors and labels
        node_colors = []
        node_labels = {}
        status_labels = {}
        
        for node in G.nodes():
            result = verification_results.get(node)
            if not result:
                node_colors.append("gray")
                status_labels[node] = "No data"
                continue
            
            # Determine color based on status
            if result.overall_status == VerificationStatus.PASS:
                node_colors.append("lightgreen")
                status = "✓ PASS"
            elif result.overall_status == VerificationStatus.FAIL:
                node_colors.append("red")
                status = "✗ FAIL"
            else:
                node_colors.append("gray")
                status = "? UNKNOWN"
            
            # Create node label
            node_labels[node] = node
            
            # Create status label
            status_lines = [f"Status: {status}"]
            
            if result.vlan_status:
                status_lines.append(f"VLAN: {result.vlan_status}")
            
            if result.port_status:
                status_lines.append(f"Port: {result.port_status}")
            
            if result.trunk_status:
                status_lines.append(f"Trunk: {result.trunk_status}")
            
            if result.role:
                status_lines.append(f"Role: {result.role}")
            
            status_labels[node] = "\n".join(status_lines[:4])  # Limit to 4 lines
        
        # Draw network graph
        nx.draw_networkx_nodes(G, pos, node_color=node_colors, node_size=5000, 
                              edgecolors='black', linewidths=2)
        nx.draw_networkx_edges(G, pos, width=3, edge_color='steelblue', 
                              arrows=True, arrowstyle='-|>', arrowsize=30)
        
        # Add device labels (above nodes)
        name_pos = {k: (v[0], v[1] + 0.8) for k, v in pos.items()}
        nx.draw_networkx_labels(G, name_pos, labels=node_labels, font_size=10, 
                               font_weight="bold")
        
        # Add status labels (below nodes)
        status_pos = {k: (v[0], v[1] - 1.2) for k, v in pos.items()}
        nx.draw_networkx_labels(G, status_pos, labels=status_labels, font_size=8,
                               bbox=dict(facecolor='white', edgecolor='black',
                                       boxstyle='round,pad=0.5', alpha=0.9))
        
        # Add legend
        legend_elements = [
            plt.Line2D([0], [0], marker='o', color='w', label='Pass', 
                      markerfacecolor='lightgreen', markersize=15),
            plt.Line2D([0], [0], marker='o', color='w', label='Fail', 
                      markerfacecolor='red', markersize=15),
            plt.Line2D([0], [0], marker='o', color='w', label='Unknown', 
                      markerfacecolor='gray', markersize=15)
        ]
        
        plt.legend(handles=legend_elements, loc='upper right', fontsize=12, 
                  title="Verification Status", title_fontsize=14)
        
        plt.title("Network VLAN Path Verification Results", pad=40, fontsize=18, 
                 fontweight='bold')
        plt.axis('off')
        plt.tight_layout()
        plt.show(block=True)
        plt.ion()


def main():
    """Main function to run VLAN path verification"""
    # Configuration
    initial_switch = "172.17.57.243"
    target_port = "GigabitEthernet1/0/10"
    vlan_id = "5"
    
    # Create verifier instance
    verifier = NetworkVerifier(config_file="config.yaml")
    
    try:
        # Run verification
        success, message, path, results = verifier.verify_vlan_path(
            initial_switch, target_port, vlan_id
        )
        
        # Print results
        print("\n" + "="*60)
        print(f"VLAN PATH VERIFICATION {'SUCCEEDED' if success else 'FAILED'}")
        print("="*60)
        print(f"Initial Switch: {initial_switch}")
        print(f"Target Port: {target_port}")
        print(f"VLAN ID: {vlan_id}")
        print(f"Path: {' → '.join(path)}")
        print(f"Status: {message}")
        print("="*60)
        
        # Detailed results
        print("\nDETAILED RESULTS:")
        print("-" * 40)
        for device_ip, result in results.items():
            print(f"\nDevice: {device_ip}")
            print(f"  Overall Status: {result.overall_status.value.upper()}")
            print(f"  VLAN Status: {result.vlan_status}")
            if result.port_status:
                print(f"  Port Status: {result.port_status}")
            if result.trunk_status:
                print(f"  Trunk Status: {result.trunk_status}")
            if result.role:
                print(f"  Role: {result.role}")
        
        # Show visualization
        if path and results:
            print("\nGenerating network visualization...")
            verifier.visualize_path(path, results)
        
        return success
        
    except Exception as e:
        logger.error(f"Verification failed with error: {str(e)}")
        print(f"\nERROR: Verification failed - {str(e)}")
        return False
    
    finally:
        # Cleanup
        if hasattr(verifier, 'nr') and verifier.nr:
            verifier.nr.close_connections()


if __name__ == "__main__":
    import sys
    
    # Allow command line arguments
    if len(sys.argv) >= 4:
        initial_switch = sys.argv[1]
        target_port = sys.argv[2]
        vlan_id = sys.argv[3]
        
        verifier = NetworkVerifier()
        success, message, path, results = verifier.verify_vlan_path(
            initial_switch, target_port, vlan_id
        )
        
        if success:
            print(f"✓ VLAN {vlan_id} path verification successful")
            sys.exit(0)
        else:
            print(f"✗ VLAN {vlan_id} path verification failed: {message}")
            sys.exit(1)
    else:
        # Use default configuration
        success = main()
        sys.exit(0 if success else 1)rn True, message
from nornir import InitNornir
from nornir_netmiko import netmiko_send_command
from nornir.core.task import Task, Result
from typing import Dict, List, Tuple, Optional, Set
import networkx as nx
import matplotlib.pyplot as plt
import re
import logging
from dataclasses import dataclass
from enum import Enum

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class VerificationStatus(Enum):
    PASS = "pass"
    FAIL = "fail"
    UNKNOWN = "unknown"

@dataclass
class DeviceResult:
    device_ip: str
    vlan_status: str
    port_status: Optional[str] = None
    trunk_status: Optional[str] = None
    role: Optional[str] = None
    overall_status: VerificationStatus = VerificationStatus.UNKNOWN

class NetworkVerifier:
    def __init__(self, config_file: str = "config.yaml"):
        self.nr = InitNornir(config_file=config_file)
        self.max_hops = 15
        
    def get_lldp_neighbors(self, task: Task) -> List[Dict]:
        """Collect LLDP neighbor information in a vendor-neutral way"""
        platform = task.host.platform
        
        # Enhanced command mapping for different platforms
        command_map = {
            "aruba_cx": "show lldp neighbors detail",
            "cisco_ios": "show lldp neighbors detail",
            "cisco_xe": "show lldp neighbors detail",
            "hp_comware": "display lldp neighbor-information",
            "juniper": "show lldp neighbors detail"
        }
        
        command = command_map.get(platform, "show lldp neighbors detail")
        
        logger.debug(f"Running on {task.host}: {command}")
        
        try:
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            # Handle different result types
            if isinstance(result.result, str):
                logger.warning(f"TextFSM parsing failed for {task.host}, attempting manual parsing")
                return self._parse_lldp_manually(result.result, platform)
            elif isinstance(result.result, dict):
                return [result.result]
            elif isinstance(result.result, list):
                return result.result
            else:
                logger.warning(f"No LLDP neighbors found on {task.host}")
                return []
                
        except Exception as e:
            logger.error(f"Error getting LLDP neighbors on {task.host}: {str(e)}")
            return []

    def _parse_lldp_manually(self, output: str, platform: str) -> List[Dict]:
        """Manual parsing fallback for when TextFSM fails"""
        neighbors = []
        
        try:
            # Basic regex patterns for common LLDP output formats
            if platform == "cisco_ios":
                # Cisco IOS LLDP format
                pattern = r'Device ID: (\S+).*?Local Intf: (\S+).*?Port id: (\S+)'
                matches = re.findall(pattern, output, re.DOTALL)
                
                for match in matches:
                    neighbors.append({
                        'neighbor': match[0],
                        'local_interface': match[1],
                        'neighbor_port': match[2]
                    })
            
            # Add more platform-specific parsing as needed
            
        except Exception as e:
            logger.error(f"Manual LLDP parsing failed: {str(e)}")
            
        return neighbors

    def find_uplink_port(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find the local interface connected to a neighbor with improved error handling"""
        platform = task.host.platform
        
        try:
            # Try LLDP first (most reliable)
            lldp_result = self._find_port_via_lldp(task, neighbor_ip, platform)
            if lldp_result:
                return lldp_result
            
            # Fall back to CDP for Cisco devices
            if platform.startswith("cisco"):
                cdp_result = self._find_port_via_cdp(task, neighbor_ip)
                if cdp_result:
                    return cdp_result
                    
            # Last resort: MAC address table lookup
            mac_result = self._find_port_via_mac(task, neighbor_ip)
            if mac_result:
                return mac_result
                
        except Exception as e:
            logger.error(f"Error finding uplink port on {task.host}: {str(e)}")
        
        return None

    def _find_port_via_lldp(self, task: Task, neighbor_ip: str, platform: str) -> Optional[str]:
        """Find port using LLDP"""
        try:
            neighbors = self.get_lldp_neighbors(task)
            
            for neighbor in neighbors:
                # Check multiple possible neighbor identifier fields
                neighbor_id = (neighbor.get('neighbor') or 
                             neighbor.get('mgmt_address') or 
                             neighbor.get('system_name'))
                
                if neighbor_id and (neighbor_id == neighbor_ip or 
                                  neighbor_id.startswith(neighbor_ip.split('.')[0])):
                    return neighbor.get('local_interface')
                    
        except Exception as e:
            logger.debug(f"LLDP port lookup failed: {str(e)}")
            
        return None

    def _find_port_via_cdp(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find port using CDP (Cisco devices)"""
        try:
            command = "show cdp neighbors detail"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if result.result:
                for neighbor in (result.result if isinstance(result.result, list) else [result.result]):
                    if neighbor.get('mgmt_address') == neighbor_ip:
                        return neighbor.get('local_port')
                        
        except Exception as e:
            logger.debug(f"CDP port lookup failed: {str(e)}")
            
        return None

    def _find_port_via_mac(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find port using MAC address table (least reliable)"""
        try:
            # This would require ARP table lookup first, then MAC table
            # Implementation depends on specific requirements
            pass
        except Exception as e:
            logger.debug(f"MAC table port lookup failed: {str(e)}")
            
        return None

    def verify_vlan_exists(self, task: Task, vlan_id: str) -> bool:
        """Check if VLAN exists with enhanced platform support"""
        platform = task.host.platform
        
        command_map = {
            "aruba_cx": f"show vlan {vlan_id}",
            "cisco_ios": f"show vlan id {vlan_id}",
            "cisco_xe": f"show vlan id {vlan_id}",
            "hp_comware": f"display vlan {vlan_id}",
            "juniper": f"show vlans {vlan_id}"
        }
        
        command = command_map.get(platform, f"show vlan id {vlan_id}")
        
        try:
            logger.debug(f"Running on {task.host}: {command}")
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if isinstance(result.result, str):
                # Check for common error messages
                error_indicators = ["invalid", "not found", "does not exist", "error"]
                return not any(indicator in result.result.lower() for indicator in error_indicators)
            
            return bool(result.result)
            
        except Exception as e:
            logger.error(f"Error checking VLAN on {task.host}: {str(e)}")
            return False

    def verify_access_vlan(self, task: Task, interface: str, vlan_id: str) -> bool:
        """Verify access port VLAN configuration with better error handling"""
        platform = task.host.platform
        
        try:
            # Method 1: Check VLAN membership
            if self._check_vlan_membership(task, interface, vlan_id, platform):
                return True
            
            # Method 2: Check interface configuration
            if self._check_interface_config(task, interface, vlan_id, platform):
                return True
            
            logger.debug(f"Access VLAN {vlan_id} not found on {interface}")
            return False
            
        except Exception as e:
            logger.error(f"Error checking access port on {task.host}: {str(e)}")
            return False

    def _check_vlan_membership(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check VLAN membership tables"""
        try:
            command_map = {
                "aruba_cx": f"show vlan {vlan_id}",
                "cisco_ios": f"show vlan id {vlan_id}",
                "cisco_xe": f"show vlan id {vlan_id}",
            }
            
            command = command_map.get(platform, f"show vlan id {vlan_id}")
            
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if result.result:
                for vlan in (result.result if isinstance(result.result, list) else [result.result]):
                    interfaces = vlan.get('interfaces', [])
                    if isinstance(interfaces, str):
                        interfaces = [interfaces]
                    
                    # Normalize interface names for comparison
                    normalized_interfaces = [self._normalize_interface_name(intf) for intf in interfaces]
                    normalized_target = self._normalize_interface_name(interface)
                    
                    if normalized_target in normalized_interfaces:
                        return True
                        
        except Exception as e:
            logger.debug(f"VLAN membership check failed: {str(e)}")
            
        return False

    def _check_interface_config(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check interface running configuration"""
        try:
            command = f"show running-config interface {interface}"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=False,
                enable=True
            )
            
            config = result.result.lower()
            
            # Platform-specific config patterns
            patterns = {
                "aruba_cx": [f"vlan access {vlan_id}"],
                "cisco_ios": [f"switchport access vlan {vlan_id}"],
                "cisco_xe": [f"switchport access vlan {vlan_id}"],
            }
            
            check_patterns = patterns.get(platform, [f"switchport access vlan {vlan_id}"])
            
            return any(pattern in config for pattern in check_patterns)
            
        except Exception as e:
            logger.debug(f"Interface config check failed: {str(e)}")
            
        return False

    def _normalize_interface_name(self, interface: str) -> str:
        """Normalize interface names for comparison"""
        # Handle common abbreviations
        interface = interface.replace("GigabitEthernet", "Gi")
        interface = interface.replace("FastEthernet", "Fa")
        interface = interface.replace("TenGigabitEthernet", "Te")
        
        # Remove spaces and convert to lowercase
        return interface.replace(" ", "").lower()

    def verify_trunk_vlan(self, task: Task, interface: str, vlan_id: str) -> bool:
        """Verify trunk allows the VLAN with comprehensive checking"""
        platform = task.host.platform
        
        try:
            # Method 1: Check switchport status
            if self._check_switchport_trunk(task, interface, vlan_id, platform):
                return True
            
            # Method 2: Check running configuration
            if self._check_trunk_config(task, interface, vlan_id, platform):
                return True
            
            return False
            
        except Exception as e:
            logger.error(f"Error checking trunk on {task.host}: {str(e)}")
            return False

    def _check_switchport_trunk(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check switchport trunk status"""
        try:
            command = f"show interfaces {interface} switchport"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if isinstance(result.result, str):
                # Parse raw output
                return self._parse_trunk_raw_output(result.result, vlan_id)
            
            if result.result and isinstance(result.result, list):
                sw_data = result.result[0]
                
                # Check if port is in trunk mode
                if sw_data.get('mode', '').lower() != 'trunk':
                    return False
                
                # Check allowed VLANs
                return self._check_allowed_vlans(sw_data, vlan_id)
                
        except Exception as e:
            logger.debug(f"Switchport trunk check failed: {str(e)}")
            
        return False

    def _parse_trunk_raw_output(self, output: str, vlan_id: str) -> bool:
        """Parse raw switchport output"""
        output_lower = output.lower()
        
        if "trunking" in output_lower:
            if "vlans allowed: all" in output_lower:
                return True
            if f"vlans allowed: {vlan_id}" in output_lower:
                return True
        
        return False

    def _check_allowed_vlans(self, switchport_data: Dict, vlan_id: str) -> bool:
        """Check if VLAN is in allowed VLAN list"""
        for field in ['trunking_vlans', 'vlans_allowed', 'allowed_vlans']:
            vlans = switchport_data.get(field, '')
            
            if vlans:
                if vlans.upper() == 'ALL':
                    return True
                if self._is_vlan_in_list(vlans, vlan_id):
                    return True
        
        return False

    def _check_trunk_config(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check trunk configuration in running config"""
        try:
            command = f"show running-config interface {interface}"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                enable=True
            )
            
            config = result.result.lower()
            
            # If trunk mode is configured but no allowed VLAN restrictions, assume all VLANs allowed
            if "switchport mode trunk" in config and "switchport trunk allowed vlan" not in config:
                return True
            
            # Check specific VLAN allowances
            if f"switchport trunk allowed vlan add {vlan_id}" in config:
                return True
            
            return False
            
        except Exception as e:
            logger.debug(f"Trunk config check failed: {str(e)}")
            
        return False

    def _is_vlan_in_list(self, vlan_str: str, target_vlan: str) -> bool:
        """Helper to safely parse VLAN lists (1,5,10-20,30)"""
        try:
            if not vlan_str:
                return False
                
            target_int = int(target_vlan)
            
            for part in str(vlan_str).split(','):
                part = part.strip()
                
                if '-' in part:
                    # Handle range (e.g., "10-20")
                    start, end = map(int, part.split('-'))
                    if start <= target_int <= end:
                        return True
                elif part.isdigit() and int(part) == target_int:
                    return True
                    
            return False
            
        except (ValueError, AttributeError) as e:
            logger.error(f"VLAN list parsing failed: {str(e)}")
            return False

    def trace_path_to_router(self, start_device: str) -> List[str]:
        """Trace path from edge switch to router using LLDP with improved logic"""
        logger.info("Starting path trace to router...")
        
        path = []
        current_device = start_device
        visited: Set[str] = set()
        
        # Get target router
        try:
            target_router = self.nr.inventory.hosts[start_device].data.get('router')
            if not target_router:
                logger.error(f"No router defined for {start_device}")
                return []
        except KeyError:
            logger.error(f"Device {start_device} not found in inventory")
            return []

        logger.info(f"Target router: {target_router}")

        while current_device and current_device not in visited and len(path) < self.max_hops:
            visited.add(current_device)
            path.append(current_device)
            
            logger.debug(f"Current device: {current_device}")
            logger.debug(f"Current path: {' -> '.join(path)}")
            
            # Check if we've reached the target router
            if current_device == target_router:
                logger.info(f"Reached target router: {current_device}")
                break
            
            # Get neighbors and find next hop
            next_hop = self._find_next_hop(current_device, target_router, visited)
            if not next_hop:
                logger.warning(f"No valid next hop found from {current_device}")
                break
                
            current_device = next_hop

        # Ensure router is in path
        if path and path[-1] != target_router:
            path.append(target_router)
            logger.debug(f"Added router {target_router} to path")

        logger.info(f"Final path: {' -> '.join(path)}")
        return path

    def _find_next_hop(self, current_device: str, target_router: str, visited: Set[str]) -> Optional[str]:
        """Find the next hop in the path"""
        try:
            neighbors_result = self.nr.filter(name=current_device).run(task=self.get_lldp_neighbors)
            neighbors = neighbors_result[current_device].result
            
            if not neighbors:
                logger.debug(f"No neighbors found for {current_device}")
                return None
            
            # Find unvisited neighbors
            possible_hops = []
            for neighbor in (neighbors if isinstance(neighbors, list) else [neighbors]):
                if isinstance(neighbor, dict):
                    neighbor_ip = self._extract_neighbor_ip(neighbor)
                    
                    if neighbor_ip and neighbor_ip not in visited:
                        # Try to resolve to inventory hostname
                        resolved_ip = self._resolve_neighbor_ip(neighbor_ip)
                        if resolved_ip:
                            possible_hops.append(resolved_ip)
            
            if not possible_hops:
                return None
            
            # Prioritize direct connection to router
            if target_router in possible_hops:
                return target_router
            
            # Prioritize devices that have the target router configured
            for hop in possible_hops:
                try:
                    if self.nr.inventory.hosts[hop].data.get('router') == target_router:
                        return hop
                except KeyError:
                    continue
            
            # Return first available hop
            return possible_hops[0]
            
        except Exception as e:
            logger.error(f"Error finding next hop from {current_device}: {str(e)}")
            return None

    def _extract_neighbor_ip(self, neighbor: Dict) -> Optional[str]:
        """Extract neighbor IP from LLDP data"""
        neighbor_ip = (neighbor.get('mgmt_address') or 
                      neighbor.get('neighbor') or 
                      neighbor.get('neighbor_name') or
                      neighbor.get('system_name'))
        
        if neighbor_ip and '.' not in neighbor_ip:
            # Handle hostname format
            neighbor_ip = neighbor_ip.split('.')[0]
        
        return neighbor_ip

    def _resolve_neighbor_ip(self, neighbor_ip: str) -> Optional[str]:
        """Resolve neighbor IP to inventory hostname"""
        # Direct match
        if neighbor_ip in self.nr.inventory.hosts:
            return neighbor_ip
        
        # Hostname match
        for hostname, host in self.nr.inventory.hosts.items():
            if (host.get('hostname', '') == neighbor_ip or 
                hostname.startswith(neighbor_ip)):
                return hostname
        
        return None

    def verify_vlan_path(self, initial_switch: str, target_port: str, vlan_id: str) -> Tuple[bool, str, List[str], Dict[str, DeviceResult]]:
        """Comprehensive VLAN path verification"""
        logger.info("Starting VLAN path verification")
        
        # Trace path
        path = self.trace_path_to_router(initial_switch)
        if not path:
            return False, "No path found to router", [], {}

        # Verify each device in path
        results = {}
        overall_success = True
        failure_reasons = []
        
        for i, device_ip in enumerate(path):
            logger.info(f"Verifying device {i+1}/{len(path)}: {device_ip}")
            
            result = DeviceResult(device_ip=device_ip, vlan_status="Unknown")
            
            # Check VLAN exists
            vlan_exists = self.nr.filter(name=device_ip).run(
                task=self.verify_vlan_exists,
                vlan_id=vlan_id
            )[device_ip].result
            
            if vlan_exists:
                result.vlan_status = "VLAN exists"
                logger.debug(f"VLAN {vlan_id} exists on {device_ip}")
            else:
                result.vlan_status = "VLAN missing"
                result.overall_status = VerificationStatus.FAIL
                overall_success = False
                failure_reasons.append(f"VLAN {vlan_id} missing on {device_ip}")
                logger.warning(f"VLAN {vlan_id} missing on {device_ip}")
            
            # First device: check access port
            if i == 0:
                access_ok = self.nr.filter(name=device_ip).run(
                    task=self.verify_access_vlan,
                    interface=target_port,
                    vlan_id=vlan_id
                )[device_ip].result
                
                if access_ok:
                    result.port_status = "Access port configured"
                    logger.debug(f"Access port {target_port} configured on {device_ip}")
                else:
                    result.port_status = f"Port {target_port} not in VLAN {vlan_id}"
                    result.overall_status = VerificationStatus.FAIL
                    overall_success = False
                    failure_reasons.append(f"Port {target_port} not in VLAN {vlan_id}")
                    logger.warning(f"Port {target_port} not in VLAN {vlan_id}")
            
            # Intermediate devices: check trunk ports
            elif i < len(path) - 1:
                next_device = path[i + 1]
                uplink_port = self.nr.filter(name=device_ip).run(
                    task=self.find_uplink_port,
                    neighbor_ip=next_device
                )[device_ip].result
                
                if uplink_port:
                    trunk_ok = self.nr.filter(name=device_ip).run(
                        task=self.verify_trunk_vlan,
                        interface=uplink_port,
                        vlan_id=vlan_id
                    )[device_ip].result
                    
                    if trunk_ok:
                        result.trunk_status = f"Trunk {uplink_port} allows VLAN"
                        logger.debug(f"Trunk {uplink_port} allows VLAN {vlan_id}")
                    else:
                        result.trunk_status = f"VLAN {vlan_id} blocked on {uplink_port}"
                        result.overall_status = VerificationStatus.FAIL
                        overall_success = False
                        failure_reasons.append(f"VLAN {vlan_id} blocked on {uplink_port}")
                        logger.warning(f"VLAN {vlan_id} blocked on {uplink_port}")
                else:
                    result.trunk_status = f"No uplink found to {next_device}"
                    result.overall_status = VerificationStatus.FAIL
                    overall_success = False
                    failure_reasons.append(f"No uplink found to {next_device}")
                    logger.warning(f"No uplink found to {next_device}")
            
            # Router endpoint
            else:
                result.role = "Router endpoint"
                logger.debug(f"Router endpoint: {device_ip}")
            
            # Set overall status if not already failed
            if result.overall_status == VerificationStatus.UNKNOWN:
                result.overall_status = VerificationStatus.PASS
            
            results[device_ip] = result

        # Generate summary message
        if overall_success:
            message = f"VLAN {vlan_id} path fully verified"
        else:
            message = f"VLAN path verification failed: {'; '.join(failure_reasons[:3])}"
        
        logger.info(f"Verification complete: {message}")
        return overall_success, message, path, results

    def visualize_path(self, path: List[str], verification_results: Dict[str, DeviceResult]):
        """Create enhanced visualization of the network path"""
        plt.ioff()
        fig, ax = plt.subplots(figsize=(18, 12))
        
        # Create graph
        G = nx.path_graph(path)
        
        # Position nodes
        pos = {node: (i * 3, 0) for i, node in enumerate(G.nodes())}
        
        # Prepare node colors and labels
        node_colors = []
        node_labels = {}
        status_labels = {}
        
        for node in G.nodes():
            result = verification_results.get(node)
            if not result:
                node_colors.append("gray")
                status_labels[node] = "No data"
                continue
            
            # Determine color based on status
            if result.overall_status == VerificationStatus.PASS:
                node_colors.append("lightgreen")
                status = "✓ PASS"
            elif result.overall_status == VerificationStatus.FAIL:
                node_colors.append("red")
                status = "✗ FAIL"
            else:
                node_colors.append("gray")
                status = "? UNKNOWN"
            
            # Create node label
            node_labels[node] = node
            
            # Create status label
            status_lines = [f"Status: {status}"]
            
            if result.vlan_status:
                status_lines.append(f"VLAN: {result.vlan_status}")
            
            if result.port_status:
                status_lines.append(f"Port: {result.port_status}")
            
            if result.trunk_status:
                status_lines.append(f"Trunk: {result.trunk_status}")
            
            if result.role:
                status_lines.append(f"Role: {result.role}")
            
            status_labels[node] = "\n".join(status_lines[:4])  # Limit to 4 lines
        
        # Draw network graph
        nx.draw_networkx_nodes(G, pos, node_color=node_colors, node_size=5000, 
                              edgecolors='black', linewidths=2)
        nx.draw_networkx_edges(G, pos, width=3, edge_color='steelblue', 
                              arrows=True, arrowstyle='-|>', arrowsize=30)
        
        # Add device labels (above nodes)
        name_pos = {k: (v[0], v[1] + 0.8) for k, v in pos.items()}
        nx.draw_networkx_labels(G, name_pos, labels=node_labels, font_size=10, 
                               font_weight="bold")
        
        # Add status labels (below nodes)
        status_pos = {k: (v[0], v[1] - 1.2) for k, v in pos.items()}
        nx.draw_networkx_labels(G, status_pos, labels=status_labels, font_size=8,
                               bbox=dict(facecolor='white', edgecolor='black',
                                       boxstyle='round,pad=0.5', alpha=0.9))
        
        # Add legend
        legend_elements = [
            plt.Line2D([0], [0], marker='o', color='w', label='Pass', 
                      markerfacecolor='lightgreen', markersize=15),
            plt.Line2D([0], [0], marker='o', color='w', label='Fail', 
                      markerfacecolor='red', markersize=15),
            plt.Line2D([0], [0], marker='o', color='w', label='Unknown', 
                      markerfacecolor='gray', markersize=15)
        ]
        
        plt.legend(handles=legend_elements, loc='upper right', fontsize=12, 
                  title="Verification Status", title_fontsize=14)
        
        plt.title("Network VLAN Path Verification Results", pad=40, fontsize=18, 
                 fontweight='bold')
        plt.axis('off')
        plt.tight_layout()
        plt.show(block=True)
        plt.ion()


def main():
    """Main function to run VLAN path verification"""
    # Configuration
    initial_switch = "172.17.57.243"
    target_port = "GigabitEthernet1/0/10"
    vlan_id = "5"
    
    # Create verifier instance
    verifier = NetworkVerifier(config_file="config.yaml")
    
    try:
        # Run verification
        success, message, path, results = verifier.verify_vlan_path(
            initial_switch, target_port, vlan_id
        )
        
        # Print results
        print("\n" + "="*60)
        print(f"VLAN PATH VERIFICATION {'SUCCEEDED' if success else 'FAILED'}")
        print("="*60)
        print(f"Initial Switch: {initial_switch}")
        print(f"Target Port: {target_port}")
        print(f"VLAN ID: {vlan_id}")
        print(f"Path: {' → '.join(path)}")
        print(f"Status: {message}")
        print("="*60)
        
        # Detailed results
        print("\nDETAILED RESULTS:")
        print("-" * 40)
        for device_ip, result in results.items():
            print(f"\nDevice: {device_ip}")
            print(f"  Overall Status: {result.overall_status.value.upper()}")
            print(f"  VLAN Status: {result.vlan_status}")
            if result.port_status:
                print(f"  Port Status: {result.port_status}")
            if result.trunk_status:
                print(f"  Trunk Status: {result.trunk_status}")
            if result.role:
                print(f"  Role: {result.role}")
        
        # Show visualization
        if path and results:
            print("\nGenerating network visualization...")
            verifier.visualize_path(path, results)
        
        return success
        
    except Exception as e:
        logger.error(f"Verification failed with error: {str(e)}")
        print(f"\nERROR: Verification failed - {str(e)}")
        return False
    
    finally:
        # Cleanup
        if hasattr(verifier, 'nr') and verifier.nr:
            verifier.nr.close_connections()


if __name__ == "__main__":
    import sys
    
    # Allow command line arguments
    if len(sys.argv) >= 4:
        initial_switch = sys.argv[1]
        target_port = sys.argv[2]
        vlan_id = sys.argv[3]
        
        verifier = NetworkVerifier()
        success, message, path, results = verifier.verify_vlan_path(
            initial_switch, target_port, vlan_id
        )
        
        if success:
            print(f"✓ VLAN {vlan_id} path verification successful")
            sys.exit(0)
        else:
            print(f"✗ VLAN {vlan_id} path verification failed: {message}")
            sys.exit(1)
    else:
        # Use default configuration
        success = main()
        sys.exit(0 if success else 1)
from nornir import InitNornir
from nornir_netmiko import netmiko_send_command
from nornir.core.task import Task, Result
from typing import Dict, List, Tuple, Optional, Set
import networkx as nx
import matplotlib.pyplot as plt
import re
import logging
from dataclasses import dataclass
from enum import Enum

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class VerificationStatus(Enum):
    PASS = "pass"
    FAIL = "fail"
    UNKNOWN = "unknown"

@dataclass
class DeviceResult:
    device_ip: str
    vlan_status: str
    port_status: Optional[str] = None
    trunk_status: Optional[str] = None
    role: Optional[str] = None
    overall_status: VerificationStatus = VerificationStatus.UNKNOWN

class NetworkVerifier:
    def __init__(self, config_file: str = "config.yaml"):
        self.nr = InitNornir(config_file=config_file)
        self.max_hops = 15
        
    def get_lldp_neighbors(self, task: Task) -> List[Dict]:
        """Collect LLDP neighbor information in a vendor-neutral way"""
        platform = task.host.platform
        
        # Enhanced command mapping for different platforms
        command_map = {
            "aruba_cx": "show lldp neighbors detail",
            "cisco_ios": "show lldp neighbors detail",
            "cisco_xe": "show lldp neighbors detail",
            "hp_comware": "display lldp neighbor-information",
            "juniper": "show lldp neighbors detail"
        }
        
        command = command_map.get(platform, "show lldp neighbors detail")
        
        logger.debug(f"Running on {task.host}: {command}")
        
        try:
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            # Handle different result types
            if isinstance(result.result, str):
                logger.warning(f"TextFSM parsing failed for {task.host}, attempting manual parsing")
                return self._parse_lldp_manually(result.result, platform)
            elif isinstance(result.result, dict):
                return [result.result]
            elif isinstance(result.result, list):
                return result.result
            else:
                logger.warning(f"No LLDP neighbors found on {task.host}")
                return []
                
        except Exception as e:
            logger.error(f"Error getting LLDP neighbors on {task.host}: {str(e)}")
            return []

    def _parse_lldp_manually(self, output: str, platform: str) -> List[Dict]:
        """Manual parsing fallback for when TextFSM fails"""
        neighbors = []
        
        try:
            # Basic regex patterns for common LLDP output formats
            if platform == "cisco_ios":
                # Cisco IOS LLDP format
                pattern = r'Device ID: (\S+).*?Local Intf: (\S+).*?Port id: (\S+)'
                matches = re.findall(pattern, output, re.DOTALL)
                
                for match in matches:
                    neighbors.append({
                        'neighbor': match[0],
                        'local_interface': match[1],
                        'neighbor_port': match[2]
                    })
            
            # Add more platform-specific parsing as needed
            
        except Exception as e:
            logger.error(f"Manual LLDP parsing failed: {str(e)}")
            
        return neighbors

    def find_uplink_port(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find the local interface connected to a neighbor with improved error handling"""
        platform = task.host.platform
        
        try:
            # Try LLDP first (most reliable)
            lldp_result = self._find_port_via_lldp(task, neighbor_ip, platform)
            if lldp_result:
                return lldp_result
            
            # Fall back to CDP for Cisco devices
            if platform.startswith("cisco"):
                cdp_result = self._find_port_via_cdp(task, neighbor_ip)
                if cdp_result:
                    return cdp_result
                    
            # Last resort: MAC address table lookup
            mac_result = self._find_port_via_mac(task, neighbor_ip)
            if mac_result:
                return mac_result
                
        except Exception as e:
            logger.error(f"Error finding uplink port on {task.host}: {str(e)}")
        
        return None

    def _find_port_via_lldp(self, task: Task, neighbor_ip: str, platform: str) -> Optional[str]:
        """Find port using LLDP"""
        try:
            neighbors = self.get_lldp_neighbors(task)
            
            for neighbor in neighbors:
                # Check multiple possible neighbor identifier fields
                neighbor_id = (neighbor.get('neighbor') or 
                             neighbor.get('mgmt_address') or 
                             neighbor.get('system_name'))
                
                if neighbor_id and (neighbor_id == neighbor_ip or 
                                  neighbor_id.startswith(neighbor_ip.split('.')[0])):
                    return neighbor.get('local_interface')
                    
        except Exception as e:
            logger.debug(f"LLDP port lookup failed: {str(e)}")
            
        return None

    def _find_port_via_cdp(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find port using CDP (Cisco devices)"""
        try:
            command = "show cdp neighbors detail"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if result.result:
                for neighbor in (result.result if isinstance(result.result, list) else [result.result]):
                    if neighbor.get('mgmt_address') == neighbor_ip:
                        return neighbor.get('local_port')
                        
        except Exception as e:
            logger.debug(f"CDP port lookup failed: {str(e)}")
            
        return None

    def _find_port_via_mac(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find port using MAC address table (least reliable)"""
        try:
            # This would require ARP table lookup first, then MAC table
            # Implementation depends on specific requirements
            pass
        except Exception as e:
            logger.debug(f"MAC table port lookup failed: {str(e)}")
            
        return None

    def verify_vlan_exists(self, task: Task, vlan_id: str) -> bool:
        """Check if VLAN exists with enhanced platform support"""
        platform = task.host.platform
        
        command_map = {
            "aruba_cx": f"show vlan {vlan_id}",
            "cisco_ios": f"show vlan id {vlan_id}",
            "cisco_xe": f"show vlan id {vlan_id}",
            "hp_comware": f"display vlan {vlan_id}",
            "juniper": f"show vlans {vlan_id}"
        }
        
        command = command_map.get(platform, f"show vlan id {vlan_id}")
        
        try:
            logger.debug(f"Running on {task.host}: {command}")
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if isinstance(result.result, str):
                # Check for common error messages
                error_indicators = ["invalid", "not found", "does not exist", "error"]
                return not any(indicator in result.result.lower() for indicator in error_indicators)
            
            return bool(result.result)
            
        except Exception as e:
            logger.error(f"Error checking VLAN on {task.host}: {str(e)}")
            return False

    def verify_access_vlan(self, task: Task, interface: str, vlan_id: str) -> bool:
        """Verify access port VLAN configuration with better error handling"""
        platform = task.host.platform
        
        try:
            # Method 1: Check VLAN membership
            if self._check_vlan_membership(task, interface, vlan_id, platform):
                return True
            
            # Method 2: Check interface configuration
            if self._check_interface_config(task, interface, vlan_id, platform):
                return True
            
            logger.debug(f"Access VLAN {vlan_id} not found on {interface}")
            return False
            
        except Exception as e:
            logger.error(f"Error checking access port on {task.host}: {str(e)}")
            return False

    def _check_vlan_membership(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check VLAN membership tables"""
        try:
            command_map = {
                "aruba_cx": f"show vlan {vlan_id}",
                "cisco_ios": f"show vlan id {vlan_id}",
                "cisco_xe": f"show vlan id {vlan_id}",
            }
            
            command = command_map.get(platform, f"show vlan id {vlan_id}")
            
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if result.result:
                for vlan in (result.result if isinstance(result.result, list) else [result.result]):
                    interfaces = vlan.get('interfaces', [])
                    if isinstance(interfaces, str):
                        interfaces = [interfaces]
                    
                    # Normalize interface names for comparison
                    normalized_interfaces = [self._normalize_interface_name(intf) for intf in interfaces]
                    normalized_target = self._normalize_interface_name(interface)
                    
                    if normalized_target in normalized_interfaces:
                        return True
                        
        except Exception as e:
            logger.debug(f"VLAN membership check failed: {str(e)}")
            
        return False

    def _check_interface_config(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check interface running configuration"""
        try:
            command = f"show running-config interface {interface}"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=False,
                enable=True
            )
            
            config = result.result.lower()
            
            # Platform-specific config patterns
            patterns = {
                "aruba_cx": [f"vlan access {vlan_id}"],
                "cisco_ios": [f"switchport access vlan {vlan_id}"],
                "cisco_xe": [f"switchport access vlan {vlan_id}"],
            }
            
            check_patterns = patterns.get(platform, [f"switchport access vlan {vlan_id}"])
            
            return any(pattern in config for pattern in check_patterns)
            
        except Exception as e:
            logger.debug(f"Interface config check failed: {str(e)}")
            
        return False

    def _normalize_interface_name(self, interface: str) -> str:
        """Normalize interface names for comparison"""
        # Handle common abbreviations
        interface = interface.replace("GigabitEthernet", "Gi")
        interface = interface.replace("FastEthernet", "Fa")
        interface = interface.replace("TenGigabitEthernet", "Te")
        
        # Remove spaces and convert to lowercase
        return interface.replace(" ", "").lower()

    def verify_trunk_vlan(self, task: Task, interface: str, vlan_id: str) -> bool:
        """Verify trunk allows the VLAN with comprehensive checking"""
        platform = task.host.platform
        
        try:
            # Method 1: Check switchport status
            if self._check_switchport_trunk(task, interface, vlan_id, platform):
                return True
            
            # Method 2: Check running configuration
            if self._check_trunk_config(task, interface, vlan_id, platform):
                return True
            
            return False
            
        except Exception as e:
            logger.error(f"Error checking trunk on {task.host}: {str(e)}")
            return False

    def _check_switchport_trunk(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check switchport trunk status"""
        try:
            command = f"show interfaces {interface} switchport"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if isinstance(result.result, str):
                # Parse raw output
                return self._parse_trunk_raw_output(result.result, vlan_id)
            
            if result.result and isinstance(result.result, list):
                sw_data = result.result[0]
                
                # Check if port is in trunk mode
                if sw_data.get('mode', '').lower() != 'trunk':
                    return False
                
                # Check allowed VLANs
                return self._check_allowed_vlans(sw_data, vlan_id)
                
        except Exception as e:
            logger.debug(f"Switchport trunk check failed: {str(e)}")
            
        return False

    def _parse_trunk_raw_output(self, output: str, vlan_id: str) -> bool:
        """Parse raw switchport output"""
        output_lower = output.lower()
        
        if "trunking" in output_lower:
            if "vlans allowed: all" in output_lower:
                return True
            if f"vlans allowed: {vlan_id}" in output_lower:
                return True
        
        return False

    def _check_allowed_vlans(self, switchport_data: Dict, vlan_id: str) -> bool:
        """Check if VLAN is in allowed VLAN list"""
        for field in ['trunking_vlans', 'vlans_allowed', 'allowed_vlans']:
            vlans = switchport_data.get(field, '')
            
            if vlans:
                if vlans.upper() == 'ALL':
                    return True
                if self._is_vlan_in_list(vlans, vlan_id):
                    return True
        
        return False

    def _check_trunk_config(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check trunk configuration in running config"""
        try:
            command = f"show running-config interface {interface}"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                enable=True
            )
            
            config = result.result.lower()
            
            # If trunk mode is configured but no allowed VLAN restrictions, assume all VLANs allowed
            if "switchport mode trunk" in config and "switchport trunk allowed vlan" not in config:
                return True
            
            # Check specific VLAN allowances
            if f"switchport trunk allowed vlan add {vlan_id}" in config:
                return True
            
            return False
            
        except Exception as e:
            logger.debug(f"Trunk config check failed: {str(e)}")
            
        return False

    def _is_vlan_in_list(self, vlan_str: str, target_vlan: str) -> bool:
        """Helper to safely parse VLAN lists (1,5,10-20,30)"""
        try:
            if not vlan_str:
                return False
                
            target_int = int(target_vlan)
            
            for part in str(vlan_str).split(','):
                part = part.strip()
                
                if '-' in part:
                    # Handle range (e.g., "10-20")
                    start, end = map(int, part.split('-'))
                    if start <= target_int <= end:
                        return True
                elif part.isdigit() and int(part) == target_int:
                    return True
                    
            return False
            
        except (ValueError, AttributeError) as e:
            logger.error(f"VLAN list parsing failed: {str(e)}")
            return False

    def trace_path_to_router(self, start_device: str) -> List[str]:
        """Trace path from edge switch to router using LLDP with improved logic"""
        logger.info("Starting path trace to router...")
        
        path = []
        current_device = start_device
        visited: Set[str] = set()
        
        # Get target router
        try:
            target_router = self.nr.inventory.hosts[start_device].data.get('router')
            if not target_router:
                logger.error(f"No router defined for {start_device}")
                return []
        except KeyError:
            logger.error(f"Device {start_device} not found in inventory")
            return []

        logger.info(f"Target router: {target_router}")

        while current_device and current_device not in visited and len(path) < self.max_hops:
            visited.add(current_device)
            path.append(current_device)
            
            logger.debug(f"Current device: {current_device}")
            logger.debug(f"Current path: {' -> '.join(path)}")
            
            # Check if we've reached the target router
            if current_device == target_router:
                logger.info(f"Reached target router: {current_device}")
                break
            
            # Get neighbors and find next hop
            next_hop = self._find_next_hop(current_device, target_router, visited)
            if not next_hop:
                logger.warning(f"No valid next hop found from {current_device}")
                break
                
            current_device = next_hop

        # Ensure router is in path
        if path and path[-1] != target_router:
            path.append(target_router)
            logger.debug(f"Added router {target_router} to path")

        logger.info(f"Final path: {' -> '.join(path)}")
        return path

    def _find_next_hop(self, current_device: str, target_router: str, visited: Set[str]) -> Optional[str]:
        """Find the next hop in the path"""
        try:
            neighbors_result = self.nr.filter(name=current_device).run(task=self.get_lldp_neighbors)
            neighbors = neighbors_result[current_device].result
            
            if not neighbors:
                logger.debug(f"No neighbors found for {current_device}")
                return None
            
            # Find unvisited neighbors
            possible_hops = []
            for neighbor in (neighbors if isinstance(neighbors, list) else [neighbors]):
                if isinstance(neighbor, dict):
                    neighbor_ip = self._extract_neighbor_ip(neighbor)
                    
                    if neighbor_ip and neighbor_ip not in visited:
                        # Try to resolve to inventory hostname
                        resolved_ip = self._resolve_neighbor_ip(neighbor_ip)
                        if resolved_ip:
                            possible_hops.append(resolved_ip)
            
            if not possible_hops:
                return None
            
            # Prioritize direct connection to router
            if target_router in possible_hops:
                return target_router
            
            # Prioritize devices that have the target router configured
            for hop in possible_hops:
                try:
                    if self.nr.inventory.hosts[hop].data.get('router') == target_router:
                        return hop
                except KeyError:
                    continue
            
            # Return first available hop
            return possible_hops[0]
            
        except Exception as e:
            logger.error(f"Error finding next hop from {current_device}: {str(e)}")
            return None

    def _extract_neighbor_ip(self, neighbor: Dict) -> Optional[str]:
        """Extract neighbor IP from LLDP data"""
        neighbor_ip = (neighbor.get('mgmt_address') or 
                      neighbor.get('neighbor') or 
                      neighbor.get('neighbor_name') or
                      neighbor.get('system_name'))
        
        if neighbor_ip and '.' not in neighbor_ip:
            # Handle hostname format
            neighbor_ip = neighbor_ip.split('.')[0]
        
        return neighbor_ip

    def _resolve_neighbor_ip(self, neighbor_ip: str) -> Optional[str]:
        """Resolve neighbor IP to inventory hostname"""
        # Direct match
        if neighbor_ip in self.nr.inventory.hosts:
            return neighbor_ip
        
        # Hostname match
        for hostname, host in self.nr.inventory.hosts.items():
            if (host.get('hostname', '') == neighbor_ip or 
                hostname.startswith(neighbor_ip)):
                return hostname
        
        return None

    def verify_vlan_path(self, initial_switch: str, target_port: str, vlan_id: str) -> Tuple[bool, str, List[str], Dict[str, DeviceResult]]:
        """Comprehensive VLAN path verification"""
        logger.info("Starting VLAN path verification")
        
        # Trace path
        path = self.trace_path_to_router(initial_switch)
        if not path:
            return False, "No path found to router", [], {}

        # Verify each device in path
        results = {}
        overall_success = True
        failure_reasons = []
        
        for i, device_ip in enumerate(path):
            logger.info(f"Verifying device {i+1}/{len(path)}: {device_ip}")
            
            result = DeviceResult(device_ip=device_ip, vlan_status="Unknown")
            
            # Check VLAN exists
            vlan_exists = self.nr.filter(name=device_ip).run(
                task=self.verify_vlan_exists,
                vlan_id=vlan_id
            )[device_ip].result
            
            if vlan_exists:
                result.vlan_status = "VLAN exists"
                logger.debug(f"VLAN {vlan_id} exists on {device_ip}")
            else:
                result.vlan_status = "VLAN missing"
                result.overall_status = VerificationStatus.FAIL
                overall_success = False
                failure_reasons.append(f"VLAN {vlan_id} missing on {device_ip}")
                logger.warning(f"VLAN {vlan_id} missing on {device_ip}")
            
            # First device: check access port
            if i == 0:
                access_ok = self.nr.filter(name=device_ip).run(
                    task=self.verify_access_vlan,
                    interface=target_port,
                    vlan_id=vlan_id
                )[device_ip].result
                
                if access_ok:
                    result.port_status = "Access port configured"
                    logger.debug(f"Access port {target_port} configured on {device_ip}")
                else:
                    result.port_status = f"Port {target_port} not in VLAN {vlan_id}"
                    result.overall_status = VerificationStatus.FAIL
                    overall_success = False
                    failure_reasons.append(f"Port {target_port} not in VLAN {vlan_id}")
                    logger.warning(f"Port {target_port} not in VLAN {vlan_id}")
            
            # Intermediate devices: check trunk ports
            elif i < len(path) - 1:
                next_device = path[i + 1]
                uplink_port = self.nr.filter(name=device_ip).run(
                    task=self.find_uplink_port,
                    neighbor_ip=next_device
                )[device_ip].result
                
                if uplink_port:
                    trunk_ok = self.nr.filter(name=device_ip).run(
                        task=self.verify_trunk_vlan,
                        interface=uplink_port,
                        vlan_id=vlan_id
                    )[device_ip].result
                    
                    if trunk_ok:
                        result.trunk_status = f"Trunk {uplink_port} allows VLAN"
                        logger.debug(f"Trunk {uplink_port} allows VLAN {vlan_id}")
                    else:
                        result.trunk_status = f"VLAN {vlan_id} blocked on {uplink_port}"
                        result.overall_status = VerificationStatus.FAIL
                        overall_success = False
                        failure_reasons.append(f"VLAN {vlan_id} blocked on {uplink_port}")
                        logger.warning(f"VLAN {vlan_id} blocked on {uplink_port}")
                else:
                    result.trunk_status = f"No uplink found to {next_device}"
                    result.overall_status = VerificationStatus.FAIL
                    overall_success = False
                    failure_reasons.append(f"No uplink found to {next_device}")
                    logger.warning(f"No uplink found to {next_device}")
            
            # Router endpoint
            else:
                result.role = "Router endpoint"
                logger.debug(f"Router endpoint: {device_ip}")
            
            # Set overall status if not already failed
            if result.overall_status == VerificationStatus.UNKNOWN:
                result.overall_status = VerificationStatus.PASS
            
            results[device_ip] = result

        # Generate summary message
        if overall_success:
            message = f"VLAN {vlan_id} path fully verified"
        else:
            message = f"VLAN path verification failed: {'; '.join(failure_reasons[:3])}"
        
        logger.info(f"Verification complete: {message}")
        return overall_success, message, path, results

    def visualize_path(self, path: List[str], verification_results: Dict[str, DeviceResult]):
        """Create enhanced visualization of the network path"""
        plt.ioff()
        fig, ax = plt.subplots(figsize=(18, 12))
        
        # Create graph
        G = nx.path_graph(path)
        
        # Position nodes
        pos = {node: (i * 3, 0) for i, node in enumerate(G.nodes())}
        
        # Prepare node colors and labels
        node_colors = []
        node_labels = {}
        status_labels = {}
        
        for node in G.nodes():
            result = verification_results.get(node)
            if not result:
                node_colors.append("gray")
                status_labels[node] = "No data"
                continue
            
            # Determine color based on status
            if result.overall_status == VerificationStatus.PASS:
                node_colors.append("lightgreen")
                status = "✓ PASS"
            elif result.overall_status == VerificationStatus.FAIL:
                node_colors.append("red")
                status = "✗ FAIL"
            else:
                node_colors.append("gray")
                status = "? UNKNOWN"
            
            # Create node label
            node_labels[node] = node
            
            # Create status label
            status_lines = [f"Status: {status}"]
            
            if result.vlan_status:
                status_lines.append(f"VLAN: {result.vlan_status}")
            
            if result.port_status:
                status_lines.append(f"Port: {result.port_status}")
            
            if result.trunk_status:
                status_lines.append(f"Trunk: {result.trunk_status}")
            
            if result.role:
                status_lines.append(f"Role: {result.role}")
            
            status_labels[node] = "\n".join(status_lines[:4])  # Limit to 4 lines
        
        # Draw network graph
        nx.draw_networkx_nodes(G, pos, node_color=node_colors, node_size=5000, 
                              edgecolors='black', linewidths=2)
        nx.draw_networkx_edges(G, pos, width=3, edge_color='steelblue', 
                              arrows=True, arrowstyle='-|>', arrowsize=30)
        
        # Add device labels (above nodes)
        name_pos = {k: (v[0], v[1] + 0.8) for k, v in pos.items()}
        nx.draw_networkx_labels(G, name_pos, labels=node_labels, font_size=10, 
                               font_weight="bold")
        
        # Add status labels (below nodes)
        status_pos = {k: (v[0], v[1] - 1.2) for k, v in pos.items()}
        nx.draw_networkx_labels(G, status_pos, labels=status_labels, font_size=8,
                               bbox=dict(facecolor='white', edgecolor='black',
                                       boxstyle='round,pad=0.5', alpha=0.9))
        
        # Add legend
        legend_elements = [
            plt.Line2D([0], [0], marker='o', color='w', label='Pass', 
                      markerfacecolor='lightgreen', markersize=15),
            plt.Line2D([0], [0], marker='o', color='w', label='Fail', 
                      markerfacecolor='red', markersize=15),
            plt.Line2D([0], [0], marker='o', color='w', label='Unknown', 
                      markerfacecolor='gray', markersize=15)
        ]
        
        plt.legend(handles=legend_elements, loc='upper right', fontsize=12, 
                  title="Verification Status", title_fontsize=14)
        
        plt.title("Network VLAN Path Verification Results", pad=40, fontsize=18, 
                 fontweight='bold')
        plt.axis('off')
        plt.tight_layout()
        plt.show(block=True)
        plt.ion()


def main():
    """Main function to run VLAN path verification"""
    # Configuration
    initial_switch = "172.17.57.243"
    target_port = "GigabitEthernet1/0/10"
    vlan_id = "5"
    
    # Create verifier instance
    verifier = NetworkVerifier(config_file="config.yaml")
    
    try:
        # Run verification
        success, message, path, results = verifier.verify_vlan_path(
            initial_switch, target_port, vlan_id
        )
        
        # Print results
        print("\n" + "="*60)
        print(f"VLAN PATH VERIFICATION {'SUCCEEDED' if success else 'FAILED'}")
        print("="*60)
        print(f"Initial Switch: {initial_switch}")
        print(f"Target Port: {target_port}")
        print(f"VLAN ID: {vlan_id}")
        print(f"Path: {' → '.join(path)}")
        print(f"Status: {message}")
        print("="*60)
        
        # Detailed results
        print("\nDETAILED RESULTS:")
        print("-" * 40)
        for device_ip, result in results.items():
            print(f"\nDevice: {device_ip}")
            print(f"  Overall Status: {result.overall_status.value.upper()}")
            print(f"  VLAN Status: {result.vlan_status}")
            if result.port_status:
                print(f"  Port Status: {result.port_status}")
            if result.trunk_status:
                print(f"  Trunk Status: {result.trunk_status}")
            if result.role:
                print(f"  Role: {result.role}")
        
        # Show visualization
        if path and results:
            print("\nGenerating network visualization...")
            verifier.visualize_path(path, results)
        
        return success
        
    except Exception as e:
        logger.error(f"Verification failed with error: {str(e)}")
        print(f"\nERROR: Verification failed - {str(e)}")
        return False
    
    finally:
        # Cleanup
        if hasattr(verifier, 'nr') and verifier.nr:
            verifier.nr.close_connections()


if __name__ == "__main__":
    import sys
    
    # Allow command line arguments
    if len(sys.argv) >= 4:
        initial_switch = sys.argv[1]
        target_port = sys.argv[2]
        vlan_id = sys.argv[3]
        
        verifier = NetworkVerifier()
        success, message, path, results = verifier.verify_vlan_path(
            initial_switch, target_port, vlan_id
        )
        
        if success:
            print(f"✓ VLAN {vlan_id} path verification successful")
            sys.exit(0)
        else:
            print(f"✗ VLAN {vlan_id} path verification failed: {message}")
            sys.exit(1)
    else:
        # Use default configuration
        success = main()
        sys.exit(0 if success else 1)ath found from {current_device} to {target_router} carrying VLAN {vlan_id}"
from nornir import InitNornir
from nornir_netmiko import netmiko_send_command
from nornir.core.task import Task, Result
from typing import Dict, List, Tuple, Optional, Set
import networkx as nx
import matplotlib.pyplot as plt
import re
import logging
from dataclasses import dataclass
from enum import Enum

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class VerificationStatus(Enum):
    PASS = "pass"
    FAIL = "fail"
    UNKNOWN = "unknown"

@dataclass
class DeviceResult:
    device_ip: str
    vlan_status: str
    port_status: Optional[str] = None
    trunk_status: Optional[str] = None
    role: Optional[str] = None
    overall_status: VerificationStatus = VerificationStatus.UNKNOWN

class NetworkVerifier:
    def __init__(self, config_file: str = "config.yaml"):
        self.nr = InitNornir(config_file=config_file)
        self.max_hops = 15
        
    def get_lldp_neighbors(self, task: Task) -> List[Dict]:
        """Collect LLDP neighbor information in a vendor-neutral way"""
        platform = task.host.platform
        
        # Enhanced command mapping for different platforms
        command_map = {
            "aruba_cx": "show lldp neighbors detail",
            "cisco_ios": "show lldp neighbors detail",
            "cisco_xe": "show lldp neighbors detail",
            "hp_comware": "display lldp neighbor-information",
            "juniper": "show lldp neighbors detail"
        }
        
        command = command_map.get(platform, "show lldp neighbors detail")
        
        logger.debug(f"Running on {task.host}: {command}")
        
        try:
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            # Handle different result types
            if isinstance(result.result, str):
                logger.warning(f"TextFSM parsing failed for {task.host}, attempting manual parsing")
                return self._parse_lldp_manually(result.result, platform)
            elif isinstance(result.result, dict):
                return [result.result]
            elif isinstance(result.result, list):
                return result.result
            else:
                logger.warning(f"No LLDP neighbors found on {task.host}")
                return []
                
        except Exception as e:
            logger.error(f"Error getting LLDP neighbors on {task.host}: {str(e)}")
            return []

    def _parse_lldp_manually(self, output: str, platform: str) -> List[Dict]:
        """Manual parsing fallback for when TextFSM fails"""
        neighbors = []
        
        try:
            # Basic regex patterns for common LLDP output formats
            if platform == "cisco_ios":
                # Cisco IOS LLDP format
                pattern = r'Device ID: (\S+).*?Local Intf: (\S+).*?Port id: (\S+)'
                matches = re.findall(pattern, output, re.DOTALL)
                
                for match in matches:
                    neighbors.append({
                        'neighbor': match[0],
                        'local_interface': match[1],
                        'neighbor_port': match[2]
                    })
            
            # Add more platform-specific parsing as needed
            
        except Exception as e:
            logger.error(f"Manual LLDP parsing failed: {str(e)}")
            
        return neighbors

    def find_uplink_port(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find the local interface connected to a neighbor with improved error handling"""
        platform = task.host.platform
        
        try:
            # Try LLDP first (most reliable)
            lldp_result = self._find_port_via_lldp(task, neighbor_ip, platform)
            if lldp_result:
                return lldp_result
            
            # Fall back to CDP for Cisco devices
            if platform.startswith("cisco"):
                cdp_result = self._find_port_via_cdp(task, neighbor_ip)
                if cdp_result:
                    return cdp_result
                    
            # Last resort: MAC address table lookup
            mac_result = self._find_port_via_mac(task, neighbor_ip)
            if mac_result:
                return mac_result
                
        except Exception as e:
            logger.error(f"Error finding uplink port on {task.host}: {str(e)}")
        
        return None

    def _find_port_via_lldp(self, task: Task, neighbor_ip: str, platform: str) -> Optional[str]:
        """Find port using LLDP"""
        try:
            neighbors = self.get_lldp_neighbors(task)
            
            for neighbor in neighbors:
                # Check multiple possible neighbor identifier fields
                neighbor_id = (neighbor.get('neighbor') or 
                             neighbor.get('mgmt_address') or 
                             neighbor.get('system_name'))
                
                if neighbor_id and (neighbor_id == neighbor_ip or 
                                  neighbor_id.startswith(neighbor_ip.split('.')[0])):
                    return neighbor.get('local_interface')
                    
        except Exception as e:
            logger.debug(f"LLDP port lookup failed: {str(e)}")
            
        return None

    def _find_port_via_cdp(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find port using CDP (Cisco devices)"""
        try:
            command = "show cdp neighbors detail"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if result.result:
                for neighbor in (result.result if isinstance(result.result, list) else [result.result]):
                    if neighbor.get('mgmt_address') == neighbor_ip:
                        return neighbor.get('local_port')
                        
        except Exception as e:
            logger.debug(f"CDP port lookup failed: {str(e)}")
            
        return None

    def _find_port_via_mac(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find port using MAC address table (least reliable)"""
        try:
            # This would require ARP table lookup first, then MAC table
            # Implementation depends on specific requirements
            pass
        except Exception as e:
            logger.debug(f"MAC table port lookup failed: {str(e)}")
            
        return None

    def verify_vlan_exists(self, task: Task, vlan_id: str) -> bool:
        """Check if VLAN exists with enhanced platform support"""
        platform = task.host.platform
        
        command_map = {
            "aruba_cx": f"show vlan {vlan_id}",
            "cisco_ios": f"show vlan id {vlan_id}",
            "cisco_xe": f"show vlan id {vlan_id}",
            "hp_comware": f"display vlan {vlan_id}",
            "juniper": f"show vlans {vlan_id}"
        }
        
        command = command_map.get(platform, f"show vlan id {vlan_id}")
        
        try:
            logger.debug(f"Running on {task.host}: {command}")
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if isinstance(result.result, str):
                # Check for common error messages
                error_indicators = ["invalid", "not found", "does not exist", "error"]
                return not any(indicator in result.result.lower() for indicator in error_indicators)
            
            return bool(result.result)
            
        except Exception as e:
            logger.error(f"Error checking VLAN on {task.host}: {str(e)}")
            return False

    def verify_access_vlan(self, task: Task, interface: str, vlan_id: str) -> bool:
        """Verify access port VLAN configuration with better error handling"""
        platform = task.host.platform
        
        try:
            # Method 1: Check VLAN membership
            if self._check_vlan_membership(task, interface, vlan_id, platform):
                return True
            
            # Method 2: Check interface configuration
            if self._check_interface_config(task, interface, vlan_id, platform):
                return True
            
            logger.debug(f"Access VLAN {vlan_id} not found on {interface}")
            return False
            
        except Exception as e:
            logger.error(f"Error checking access port on {task.host}: {str(e)}")
            return False

    def _check_vlan_membership(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check VLAN membership tables"""
        try:
            command_map = {
                "aruba_cx": f"show vlan {vlan_id}",
                "cisco_ios": f"show vlan id {vlan_id}",
                "cisco_xe": f"show vlan id {vlan_id}",
            }
            
            command = command_map.get(platform, f"show vlan id {vlan_id}")
            
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if result.result:
                for vlan in (result.result if isinstance(result.result, list) else [result.result]):
                    interfaces = vlan.get('interfaces', [])
                    if isinstance(interfaces, str):
                        interfaces = [interfaces]
                    
                    # Normalize interface names for comparison
                    normalized_interfaces = [self._normalize_interface_name(intf) for intf in interfaces]
                    normalized_target = self._normalize_interface_name(interface)
                    
                    if normalized_target in normalized_interfaces:
                        return True
                        
        except Exception as e:
            logger.debug(f"VLAN membership check failed: {str(e)}")
            
        return False

    def _check_interface_config(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check interface running configuration"""
        try:
            command = f"show running-config interface {interface}"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=False,
                enable=True
            )
            
            config = result.result.lower()
            
            # Platform-specific config patterns
            patterns = {
                "aruba_cx": [f"vlan access {vlan_id}"],
                "cisco_ios": [f"switchport access vlan {vlan_id}"],
                "cisco_xe": [f"switchport access vlan {vlan_id}"],
            }
            
            check_patterns = patterns.get(platform, [f"switchport access vlan {vlan_id}"])
            
            return any(pattern in config for pattern in check_patterns)
            
        except Exception as e:
            logger.debug(f"Interface config check failed: {str(e)}")
            
        return False

    def _normalize_interface_name(self, interface: str) -> str:
        """Normalize interface names for comparison"""
        # Handle common abbreviations
        interface = interface.replace("GigabitEthernet", "Gi")
        interface = interface.replace("FastEthernet", "Fa")
        interface = interface.replace("TenGigabitEthernet", "Te")
        
        # Remove spaces and convert to lowercase
        return interface.replace(" ", "").lower()

    def verify_trunk_vlan(self, task: Task, interface: str, vlan_id: str) -> bool:
        """Verify trunk allows the VLAN with comprehensive checking"""
        platform = task.host.platform
        
        try:
            # Method 1: Check switchport status
            if self._check_switchport_trunk(task, interface, vlan_id, platform):
                return True
            
            # Method 2: Check running configuration
            if self._check_trunk_config(task, interface, vlan_id, platform):
                return True
            
            return False
            
        except Exception as e:
            logger.error(f"Error checking trunk on {task.host}: {str(e)}")
            return False

    def _check_switchport_trunk(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check switchport trunk status"""
        try:
            command = f"show interfaces {interface} switchport"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if isinstance(result.result, str):
                # Parse raw output
                return self._parse_trunk_raw_output(result.result, vlan_id)
            
            if result.result and isinstance(result.result, list):
                sw_data = result.result[0]
                
                # Check if port is in trunk mode
                if sw_data.get('mode', '').lower() != 'trunk':
                    return False
                
                # Check allowed VLANs
                return self._check_allowed_vlans(sw_data, vlan_id)
                
        except Exception as e:
            logger.debug(f"Switchport trunk check failed: {str(e)}")
            
        return False

    def _parse_trunk_raw_output(self, output: str, vlan_id: str) -> bool:
        """Parse raw switchport output"""
        output_lower = output.lower()
        
        if "trunking" in output_lower:
            if "vlans allowed: all" in output_lower:
                return True
            if f"vlans allowed: {vlan_id}" in output_lower:
                return True
        
        return False

    def _check_allowed_vlans(self, switchport_data: Dict, vlan_id: str) -> bool:
        """Check if VLAN is in allowed VLAN list"""
        for field in ['trunking_vlans', 'vlans_allowed', 'allowed_vlans']:
            vlans = switchport_data.get(field, '')
            
            if vlans:
                if vlans.upper() == 'ALL':
                    return True
                if self._is_vlan_in_list(vlans, vlan_id):
                    return True
        
        return False

    def _check_trunk_config(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check trunk configuration in running config"""
        try:
            command = f"show running-config interface {interface}"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                enable=True
            )
            
            config = result.result.lower()
            
            # If trunk mode is configured but no allowed VLAN restrictions, assume all VLANs allowed
            if "switchport mode trunk" in config and "switchport trunk allowed vlan" not in config:
                return True
            
            # Check specific VLAN allowances
            if f"switchport trunk allowed vlan add {vlan_id}" in config:
                return True
            
            return False
            
        except Exception as e:
            logger.debug(f"Trunk config check failed: {str(e)}")
            
        return False

    def _is_vlan_in_list(self, vlan_str: str, target_vlan: str) -> bool:
        """Helper to safely parse VLAN lists (1,5,10-20,30)"""
        try:
            if not vlan_str:
                return False
                
            target_int = int(target_vlan)
            
            for part in str(vlan_str).split(','):
                part = part.strip()
                
                if '-' in part:
                    # Handle range (e.g., "10-20")
                    start, end = map(int, part.split('-'))
                    if start <= target_int <= end:
                        return True
                elif part.isdigit() and int(part) == target_int:
                    return True
                    
            return False
            
        except (ValueError, AttributeError) as e:
            logger.error(f"VLAN list parsing failed: {str(e)}")
            return False

    def trace_path_to_router(self, start_device: str) -> List[str]:
        """Trace path from edge switch to router using LLDP with improved logic"""
        logger.info("Starting path trace to router...")
        
        path = []
        current_device = start_device
        visited: Set[str] = set()
        
        # Get target router
        try:
            target_router = self.nr.inventory.hosts[start_device].data.get('router')
            if not target_router:
                logger.error(f"No router defined for {start_device}")
                return []
        except KeyError:
            logger.error(f"Device {start_device} not found in inventory")
            return []

        logger.info(f"Target router: {target_router}")

        while current_device and current_device not in visited and len(path) < self.max_hops:
            visited.add(current_device)
            path.append(current_device)
            
            logger.debug(f"Current device: {current_device}")
            logger.debug(f"Current path: {' -> '.join(path)}")
            
            # Check if we've reached the target router
            if current_device == target_router:
                logger.info(f"Reached target router: {current_device}")
                break
            
            # Get neighbors and find next hop
            next_hop = self._find_next_hop(current_device, target_router, visited)
            if not next_hop:
                logger.warning(f"No valid next hop found from {current_device}")
                break
                
            current_device = next_hop

        # Ensure router is in path
        if path and path[-1] != target_router:
            path.append(target_router)
            logger.debug(f"Added router {target_router} to path")

        logger.info(f"Final path: {' -> '.join(path)}")
        return path

    def _find_next_hop(self, current_device: str, target_router: str, visited: Set[str]) -> Optional[str]:
        """Find the next hop in the path"""
        try:
            neighbors_result = self.nr.filter(name=current_device).run(task=self.get_lldp_neighbors)
            neighbors = neighbors_result[current_device].result
            
            if not neighbors:
                logger.debug(f"No neighbors found for {current_device}")
                return None
            
            # Find unvisited neighbors
            possible_hops = []
            for neighbor in (neighbors if isinstance(neighbors, list) else [neighbors]):
                if isinstance(neighbor, dict):
                    neighbor_ip = self._extract_neighbor_ip(neighbor)
                    
                    if neighbor_ip and neighbor_ip not in visited:
                        # Try to resolve to inventory hostname
                        resolved_ip = self._resolve_neighbor_ip(neighbor_ip)
                        if resolved_ip:
                            possible_hops.append(resolved_ip)
            
            if not possible_hops:
                return None
            
            # Prioritize direct connection to router
            if target_router in possible_hops:
                return target_router
            
            # Prioritize devices that have the target router configured
            for hop in possible_hops:
                try:
                    if self.nr.inventory.hosts[hop].data.get('router') == target_router:
                        return hop
                except KeyError:
                    continue
            
            # Return first available hop
            return possible_hops[0]
            
        except Exception as e:
            logger.error(f"Error finding next hop from {current_device}: {str(e)}")
            return None

    def _extract_neighbor_ip(self, neighbor: Dict) -> Optional[str]:
        """Extract neighbor IP from LLDP data"""
        neighbor_ip = (neighbor.get('mgmt_address') or 
                      neighbor.get('neighbor') or 
                      neighbor.get('neighbor_name') or
                      neighbor.get('system_name'))
        
        if neighbor_ip and '.' not in neighbor_ip:
            # Handle hostname format
            neighbor_ip = neighbor_ip.split('.')[0]
        
        return neighbor_ip

    def _resolve_neighbor_ip(self, neighbor_ip: str) -> Optional[str]:
        """Resolve neighbor IP to inventory hostname"""
        # Direct match
        if neighbor_ip in self.nr.inventory.hosts:
            return neighbor_ip
        
        # Hostname match
        for hostname, host in self.nr.inventory.hosts.items():
            if (host.get('hostname', '') == neighbor_ip or 
                hostname.startswith(neighbor_ip)):
                return hostname
        
        return None

    def verify_vlan_path(self, initial_switch: str, target_port: str, vlan_id: str) -> Tuple[bool, str, List[str], Dict[str, DeviceResult]]:
        """Comprehensive VLAN path verification"""
        logger.info("Starting VLAN path verification")
        
        # Trace path
        path = self.trace_path_to_router(initial_switch)
        if not path:
            return False, "No path found to router", [], {}

        # Verify each device in path
        results = {}
        overall_success = True
        failure_reasons = []
        
        for i, device_ip in enumerate(path):
            logger.info(f"Verifying device {i+1}/{len(path)}: {device_ip}")
            
            result = DeviceResult(device_ip=device_ip, vlan_status="Unknown")
            
            # Check VLAN exists
            vlan_exists = self.nr.filter(name=device_ip).run(
                task=self.verify_vlan_exists,
                vlan_id=vlan_id
            )[device_ip].result
            
            if vlan_exists:
                result.vlan_status = "VLAN exists"
                logger.debug(f"VLAN {vlan_id} exists on {device_ip}")
            else:
                result.vlan_status = "VLAN missing"
                result.overall_status = VerificationStatus.FAIL
                overall_success = False
                failure_reasons.append(f"VLAN {vlan_id} missing on {device_ip}")
                logger.warning(f"VLAN {vlan_id} missing on {device_ip}")
            
            # First device: check access port
            if i == 0:
                access_ok = self.nr.filter(name=device_ip).run(
                    task=self.verify_access_vlan,
                    interface=target_port,
                    vlan_id=vlan_id
                )[device_ip].result
                
                if access_ok:
                    result.port_status = "Access port configured"
                    logger.debug(f"Access port {target_port} configured on {device_ip}")
                else:
                    result.port_status = f"Port {target_port} not in VLAN {vlan_id}"
                    result.overall_status = VerificationStatus.FAIL
                    overall_success = False
                    failure_reasons.append(f"Port {target_port} not in VLAN {vlan_id}")
                    logger.warning(f"Port {target_port} not in VLAN {vlan_id}")
            
            # Intermediate devices: check trunk ports
            elif i < len(path) - 1:
                next_device = path[i + 1]
                uplink_port = self.nr.filter(name=device_ip).run(
                    task=self.find_uplink_port,
                    neighbor_ip=next_device
                )[device_ip].result
                
                if uplink_port:
                    trunk_ok = self.nr.filter(name=device_ip).run(
                        task=self.verify_trunk_vlan,
                        interface=uplink_port,
                        vlan_id=vlan_id
                    )[device_ip].result
                    
                    if trunk_ok:
                        result.trunk_status = f"Trunk {uplink_port} allows VLAN"
                        logger.debug(f"Trunk {uplink_port} allows VLAN {vlan_id}")
                    else:
                        result.trunk_status = f"VLAN {vlan_id} blocked on {uplink_port}"
                        result.overall_status = VerificationStatus.FAIL
                        overall_success = False
                        failure_reasons.append(f"VLAN {vlan_id} blocked on {uplink_port}")
                        logger.warning(f"VLAN {vlan_id} blocked on {uplink_port}")
                else:
                    result.trunk_status = f"No uplink found to {next_device}"
                    result.overall_status = VerificationStatus.FAIL
                    overall_success = False
                    failure_reasons.append(f"No uplink found to {next_device}")
                    logger.warning(f"No uplink found to {next_device}")
            
            # Router endpoint
            else:
                result.role = "Router endpoint"
                logger.debug(f"Router endpoint: {device_ip}")
            
            # Set overall status if not already failed
            if result.overall_status == VerificationStatus.UNKNOWN:
                result.overall_status = VerificationStatus.PASS
            
            results[device_ip] = result

        # Generate summary message
        if overall_success:
            message = f"VLAN {vlan_id} path fully verified"
        else:
            message = f"VLAN path verification failed: {'; '.join(failure_reasons[:3])}"
        
        logger.info(f"Verification complete: {message}")
        return overall_success, message, path, results

    def visualize_path(self, path: List[str], verification_results: Dict[str, DeviceResult]):
        """Create enhanced visualization of the network path"""
        plt.ioff()
        fig, ax = plt.subplots(figsize=(18, 12))
        
        # Create graph
        G = nx.path_graph(path)
        
        # Position nodes
        pos = {node: (i * 3, 0) for i, node in enumerate(G.nodes())}
        
        # Prepare node colors and labels
        node_colors = []
        node_labels = {}
        status_labels = {}
        
        for node in G.nodes():
            result = verification_results.get(node)
            if not result:
                node_colors.append("gray")
                status_labels[node] = "No data"
                continue
            
            # Determine color based on status
            if result.overall_status == VerificationStatus.PASS:
                node_colors.append("lightgreen")
                status = "✓ PASS"
            elif result.overall_status == VerificationStatus.FAIL:
                node_colors.append("red")
                status = "✗ FAIL"
            else:
                node_colors.append("gray")
                status = "? UNKNOWN"
            
            # Create node label
            node_labels[node] = node
            
            # Create status label
            status_lines = [f"Status: {status}"]
            
            if result.vlan_status:
                status_lines.append(f"VLAN: {result.vlan_status}")
            
            if result.port_status:
                status_lines.append(f"Port: {result.port_status}")
            
            if result.trunk_status:
                status_lines.append(f"Trunk: {result.trunk_status}")
            
            if result.role:
                status_lines.append(f"Role: {result.role}")
            
            status_labels[node] = "\n".join(status_lines[:4])  # Limit to 4 lines
        
        # Draw network graph
        nx.draw_networkx_nodes(G, pos, node_color=node_colors, node_size=5000, 
                              edgecolors='black', linewidths=2)
        nx.draw_networkx_edges(G, pos, width=3, edge_color='steelblue', 
                              arrows=True, arrowstyle='-|>', arrowsize=30)
        
        # Add device labels (above nodes)
        name_pos = {k: (v[0], v[1] + 0.8) for k, v in pos.items()}
        nx.draw_networkx_labels(G, name_pos, labels=node_labels, font_size=10, 
                               font_weight="bold")
        
        # Add status labels (below nodes)
        status_pos = {k: (v[0], v[1] - 1.2) for k, v in pos.items()}
        nx.draw_networkx_labels(G, status_pos, labels=status_labels, font_size=8,
                               bbox=dict(facecolor='white', edgecolor='black',
                                       boxstyle='round,pad=0.5', alpha=0.9))
        
        # Add legend
        legend_elements = [
            plt.Line2D([0], [0], marker='o', color='w', label='Pass', 
                      markerfacecolor='lightgreen', markersize=15),
            plt.Line2D([0], [0], marker='o', color='w', label='Fail', 
                      markerfacecolor='red', markersize=15),
            plt.Line2D([0], [0], marker='o', color='w', label='Unknown', 
                      markerfacecolor='gray', markersize=15)
        ]
        
        plt.legend(handles=legend_elements, loc='upper right', fontsize=12, 
                  title="Verification Status", title_fontsize=14)
        
        plt.title("Network VLAN Path Verification Results", pad=40, fontsize=18, 
                 fontweight='bold')
        plt.axis('off')
        plt.tight_layout()
        plt.show(block=True)
        plt.ion()


def main():
    """Main function to run VLAN path verification"""
    # Configuration
    initial_switch = "172.17.57.243"
    target_port = "GigabitEthernet1/0/10"
    vlan_id = "5"
    
    # Create verifier instance
    verifier = NetworkVerifier(config_file="config.yaml")
    
    try:
        # Run verification
        success, message, path, results = verifier.verify_vlan_path(
            initial_switch, target_port, vlan_id
        )
        
        # Print results
        print("\n" + "="*60)
        print(f"VLAN PATH VERIFICATION {'SUCCEEDED' if success else 'FAILED'}")
        print("="*60)
        print(f"Initial Switch: {initial_switch}")
        print(f"Target Port: {target_port}")
        print(f"VLAN ID: {vlan_id}")
        print(f"Path: {' → '.join(path)}")
        print(f"Status: {message}")
        print("="*60)
        
        # Detailed results
        print("\nDETAILED RESULTS:")
        print("-" * 40)
        for device_ip, result in results.items():
            print(f"\nDevice: {device_ip}")
            print(f"  Overall Status: {result.overall_status.value.upper()}")
            print(f"  VLAN Status: {result.vlan_status}")
            if result.port_status:
                print(f"  Port Status: {result.port_status}")
            if result.trunk_status:
                print(f"  Trunk Status: {result.trunk_status}")
            if result.role:
                print(f"  Role: {result.role}")
        
        # Show visualization
        if path and results:
            print("\nGenerating network visualization...")
            verifier.visualize_path(path, results)
        
        return success
        
    except Exception as e:
        logger.error(f"Verification failed with error: {str(e)}")
        print(f"\nERROR: Verification failed - {str(e)}")
        return False
    
    finally:
        # Cleanup
        if hasattr(verifier, 'nr') and verifier.nr:
            verifier.nr.close_connections()


if __name__ == "__main__":
    import sys
    
    # Allow command line arguments
    if len(sys.argv) >= 4:
        initial_switch = sys.argv[1]
        target_port = sys.argv[2]
        vlan_id = sys.argv[3]
        
        verifier = NetworkVerifier()
        success, message, path, results = verifier.verify_vlan_path(
            initial_switch, target_port, vlan_id
        )
        
        if success:
            print(f"✓ VLAN {vlan_id} path verification successful")
            sys.exit(0)
        else:
            print(f"✗ VLAN {vlan_id} path verification failed: {message}")
            sys.exit(1)
    else:
        # Use default configuration
        success = main()
        sys.exit(0 if success else 1)
from nornir import InitNornir
from nornir_netmiko import netmiko_send_command
from nornir.core.task import Task, Result
from typing import Dict, List, Tuple, Optional, Set
import networkx as nx
import matplotlib.pyplot as plt
import re
import logging
from dataclasses import dataclass
from enum import Enum

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class VerificationStatus(Enum):
    PASS = "pass"
    FAIL = "fail"
    UNKNOWN = "unknown"

@dataclass
class DeviceResult:
    device_ip: str
    vlan_status: str
    port_status: Optional[str] = None
    trunk_status: Optional[str] = None
    role: Optional[str] = None
    overall_status: VerificationStatus = VerificationStatus.UNKNOWN

class NetworkVerifier:
    def __init__(self, config_file: str = "config.yaml"):
        self.nr = InitNornir(config_file=config_file)
        self.max_hops = 15
        
    def get_lldp_neighbors(self, task: Task) -> List[Dict]:
        """Collect LLDP neighbor information in a vendor-neutral way"""
        platform = task.host.platform
        
        # Enhanced command mapping for different platforms
        command_map = {
            "aruba_cx": "show lldp neighbors detail",
            "cisco_ios": "show lldp neighbors detail",
            "cisco_xe": "show lldp neighbors detail",
            "hp_comware": "display lldp neighbor-information",
            "juniper": "show lldp neighbors detail"
        }
        
        command = command_map.get(platform, "show lldp neighbors detail")
        
        logger.debug(f"Running on {task.host}: {command}")
        
        try:
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            # Handle different result types
            if isinstance(result.result, str):
                logger.warning(f"TextFSM parsing failed for {task.host}, attempting manual parsing")
                return self._parse_lldp_manually(result.result, platform)
            elif isinstance(result.result, dict):
                return [result.result]
            elif isinstance(result.result, list):
                return result.result
            else:
                logger.warning(f"No LLDP neighbors found on {task.host}")
                return []
                
        except Exception as e:
            logger.error(f"Error getting LLDP neighbors on {task.host}: {str(e)}")
            return []

    def _parse_lldp_manually(self, output: str, platform: str) -> List[Dict]:
        """Manual parsing fallback for when TextFSM fails"""
        neighbors = []
        
        try:
            # Basic regex patterns for common LLDP output formats
            if platform == "cisco_ios":
                # Cisco IOS LLDP format
                pattern = r'Device ID: (\S+).*?Local Intf: (\S+).*?Port id: (\S+)'
                matches = re.findall(pattern, output, re.DOTALL)
                
                for match in matches:
                    neighbors.append({
                        'neighbor': match[0],
                        'local_interface': match[1],
                        'neighbor_port': match[2]
                    })
            
            # Add more platform-specific parsing as needed
            
        except Exception as e:
            logger.error(f"Manual LLDP parsing failed: {str(e)}")
            
        return neighbors

    def find_uplink_port(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find the local interface connected to a neighbor with improved error handling"""
        platform = task.host.platform
        
        try:
            # Try LLDP first (most reliable)
            lldp_result = self._find_port_via_lldp(task, neighbor_ip, platform)
            if lldp_result:
                return lldp_result
            
            # Fall back to CDP for Cisco devices
            if platform.startswith("cisco"):
                cdp_result = self._find_port_via_cdp(task, neighbor_ip)
                if cdp_result:
                    return cdp_result
                    
            # Last resort: MAC address table lookup
            mac_result = self._find_port_via_mac(task, neighbor_ip)
            if mac_result:
                return mac_result
                
        except Exception as e:
            logger.error(f"Error finding uplink port on {task.host}: {str(e)}")
        
        return None

    def _find_port_via_lldp(self, task: Task, neighbor_ip: str, platform: str) -> Optional[str]:
        """Find port using LLDP"""
        try:
            neighbors = self.get_lldp_neighbors(task)
            
            for neighbor in neighbors:
                # Check multiple possible neighbor identifier fields
                neighbor_id = (neighbor.get('neighbor') or 
                             neighbor.get('mgmt_address') or 
                             neighbor.get('system_name'))
                
                if neighbor_id and (neighbor_id == neighbor_ip or 
                                  neighbor_id.startswith(neighbor_ip.split('.')[0])):
                    return neighbor.get('local_interface')
                    
        except Exception as e:
            logger.debug(f"LLDP port lookup failed: {str(e)}")
            
        return None

    def _find_port_via_cdp(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find port using CDP (Cisco devices)"""
        try:
            command = "show cdp neighbors detail"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if result.result:
                for neighbor in (result.result if isinstance(result.result, list) else [result.result]):
                    if neighbor.get('mgmt_address') == neighbor_ip:
                        return neighbor.get('local_port')
                        
        except Exception as e:
            logger.debug(f"CDP port lookup failed: {str(e)}")
            
        return None

    def _find_port_via_mac(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find port using MAC address table (least reliable)"""
        try:
            # This would require ARP table lookup first, then MAC table
            # Implementation depends on specific requirements
            pass
        except Exception as e:
            logger.debug(f"MAC table port lookup failed: {str(e)}")
            
        return None

    def verify_vlan_exists(self, task: Task, vlan_id: str) -> bool:
        """Check if VLAN exists with enhanced platform support"""
        platform = task.host.platform
        
        command_map = {
            "aruba_cx": f"show vlan {vlan_id}",
            "cisco_ios": f"show vlan id {vlan_id}",
            "cisco_xe": f"show vlan id {vlan_id}",
            "hp_comware": f"display vlan {vlan_id}",
            "juniper": f"show vlans {vlan_id}"
        }
        
        command = command_map.get(platform, f"show vlan id {vlan_id}")
        
        try:
            logger.debug(f"Running on {task.host}: {command}")
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if isinstance(result.result, str):
                # Check for common error messages
                error_indicators = ["invalid", "not found", "does not exist", "error"]
                return not any(indicator in result.result.lower() for indicator in error_indicators)
            
            return bool(result.result)
            
        except Exception as e:
            logger.error(f"Error checking VLAN on {task.host}: {str(e)}")
            return False

    def verify_access_vlan(self, task: Task, interface: str, vlan_id: str) -> bool:
        """Verify access port VLAN configuration with better error handling"""
        platform = task.host.platform
        
        try:
            # Method 1: Check VLAN membership
            if self._check_vlan_membership(task, interface, vlan_id, platform):
                return True
            
            # Method 2: Check interface configuration
            if self._check_interface_config(task, interface, vlan_id, platform):
                return True
            
            logger.debug(f"Access VLAN {vlan_id} not found on {interface}")
            return False
            
        except Exception as e:
            logger.error(f"Error checking access port on {task.host}: {str(e)}")
            return False

    def _check_vlan_membership(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check VLAN membership tables"""
        try:
            command_map = {
                "aruba_cx": f"show vlan {vlan_id}",
                "cisco_ios": f"show vlan id {vlan_id}",
                "cisco_xe": f"show vlan id {vlan_id}",
            }
            
            command = command_map.get(platform, f"show vlan id {vlan_id}")
            
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if result.result:
                for vlan in (result.result if isinstance(result.result, list) else [result.result]):
                    interfaces = vlan.get('interfaces', [])
                    if isinstance(interfaces, str):
                        interfaces = [interfaces]
                    
                    # Normalize interface names for comparison
                    normalized_interfaces = [self._normalize_interface_name(intf) for intf in interfaces]
                    normalized_target = self._normalize_interface_name(interface)
                    
                    if normalized_target in normalized_interfaces:
                        return True
                        
        except Exception as e:
            logger.debug(f"VLAN membership check failed: {str(e)}")
            
        return False

    def _check_interface_config(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check interface running configuration"""
        try:
            command = f"show running-config interface {interface}"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=False,
                enable=True
            )
            
            config = result.result.lower()
            
            # Platform-specific config patterns
            patterns = {
                "aruba_cx": [f"vlan access {vlan_id}"],
                "cisco_ios": [f"switchport access vlan {vlan_id}"],
                "cisco_xe": [f"switchport access vlan {vlan_id}"],
            }
            
            check_patterns = patterns.get(platform, [f"switchport access vlan {vlan_id}"])
            
            return any(pattern in config for pattern in check_patterns)
            
        except Exception as e:
            logger.debug(f"Interface config check failed: {str(e)}")
            
        return False

    def _normalize_interface_name(self, interface: str) -> str:
        """Normalize interface names for comparison"""
        # Handle common abbreviations
        interface = interface.replace("GigabitEthernet", "Gi")
        interface = interface.replace("FastEthernet", "Fa")
        interface = interface.replace("TenGigabitEthernet", "Te")
        
        # Remove spaces and convert to lowercase
        return interface.replace(" ", "").lower()

    def verify_trunk_vlan(self, task: Task, interface: str, vlan_id: str) -> bool:
        """Verify trunk allows the VLAN with comprehensive checking"""
        platform = task.host.platform
        
        try:
            # Method 1: Check switchport status
            if self._check_switchport_trunk(task, interface, vlan_id, platform):
                return True
            
            # Method 2: Check running configuration
            if self._check_trunk_config(task, interface, vlan_id, platform):
                return True
            
            return False
            
        except Exception as e:
            logger.error(f"Error checking trunk on {task.host}: {str(e)}")
            return False

    def _check_switchport_trunk(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check switchport trunk status"""
        try:
            command = f"show interfaces {interface} switchport"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if isinstance(result.result, str):
                # Parse raw output
                return self._parse_trunk_raw_output(result.result, vlan_id)
            
            if result.result and isinstance(result.result, list):
                sw_data = result.result[0]
                
                # Check if port is in trunk mode
                if sw_data.get('mode', '').lower() != 'trunk':
                    return False
                
                # Check allowed VLANs
                return self._check_allowed_vlans(sw_data, vlan_id)
                
        except Exception as e:
            logger.debug(f"Switchport trunk check failed: {str(e)}")
            
        return False

    def _parse_trunk_raw_output(self, output: str, vlan_id: str) -> bool:
        """Parse raw switchport output"""
        output_lower = output.lower()
        
        if "trunking" in output_lower:
            if "vlans allowed: all" in output_lower:
                return True
            if f"vlans allowed: {vlan_id}" in output_lower:
                return True
        
        return False

    def _check_allowed_vlans(self, switchport_data: Dict, vlan_id: str) -> bool:
        """Check if VLAN is in allowed VLAN list"""
        for field in ['trunking_vlans', 'vlans_allowed', 'allowed_vlans']:
            vlans = switchport_data.get(field, '')
            
            if vlans:
                if vlans.upper() == 'ALL':
                    return True
                if self._is_vlan_in_list(vlans, vlan_id):
                    return True
        
        return False

    def _check_trunk_config(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check trunk configuration in running config"""
        try:
            command = f"show running-config interface {interface}"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                enable=True
            )
            
            config = result.result.lower()
            
            # If trunk mode is configured but no allowed VLAN restrictions, assume all VLANs allowed
            if "switchport mode trunk" in config and "switchport trunk allowed vlan" not in config:
                return True
            
            # Check specific VLAN allowances
            if f"switchport trunk allowed vlan add {vlan_id}" in config:
                return True
            
            return False
            
        except Exception as e:
            logger.debug(f"Trunk config check failed: {str(e)}")
            
        return False

    def _is_vlan_in_list(self, vlan_str: str, target_vlan: str) -> bool:
        """Helper to safely parse VLAN lists (1,5,10-20,30)"""
        try:
            if not vlan_str:
                return False
                
            target_int = int(target_vlan)
            
            for part in str(vlan_str).split(','):
                part = part.strip()
                
                if '-' in part:
                    # Handle range (e.g., "10-20")
                    start, end = map(int, part.split('-'))
                    if start <= target_int <= end:
                        return True
                elif part.isdigit() and int(part) == target_int:
                    return True
                    
            return False
            
        except (ValueError, AttributeError) as e:
            logger.error(f"VLAN list parsing failed: {str(e)}")
            return False

    def trace_path_to_router(self, start_device: str) -> List[str]:
        """Trace path from edge switch to router using LLDP with improved logic"""
        logger.info("Starting path trace to router...")
        
        path = []
        current_device = start_device
        visited: Set[str] = set()
        
        # Get target router
        try:
            target_router = self.nr.inventory.hosts[start_device].data.get('router')
            if not target_router:
                logger.error(f"No router defined for {start_device}")
                return []
        except KeyError:
            logger.error(f"Device {start_device} not found in inventory")
            return []

        logger.info(f"Target router: {target_router}")

        while current_device and current_device not in visited and len(path) < self.max_hops:
            visited.add(current_device)
            path.append(current_device)
            
            logger.debug(f"Current device: {current_device}")
            logger.debug(f"Current path: {' -> '.join(path)}")
            
            # Check if we've reached the target router
            if current_device == target_router:
                logger.info(f"Reached target router: {current_device}")
                break
            
            # Get neighbors and find next hop
            next_hop = self._find_next_hop(current_device, target_router, visited)
            if not next_hop:
                logger.warning(f"No valid next hop found from {current_device}")
                break
                
            current_device = next_hop

        # Ensure router is in path
        if path and path[-1] != target_router:
            path.append(target_router)
            logger.debug(f"Added router {target_router} to path")

        logger.info(f"Final path: {' -> '.join(path)}")
        return path

    def _find_next_hop(self, current_device: str, target_router: str, visited: Set[str]) -> Optional[str]:
        """Find the next hop in the path"""
        try:
            neighbors_result = self.nr.filter(name=current_device).run(task=self.get_lldp_neighbors)
            neighbors = neighbors_result[current_device].result
            
            if not neighbors:
                logger.debug(f"No neighbors found for {current_device}")
                return None
            
            # Find unvisited neighbors
            possible_hops = []
            for neighbor in (neighbors if isinstance(neighbors, list) else [neighbors]):
                if isinstance(neighbor, dict):
                    neighbor_ip = self._extract_neighbor_ip(neighbor)
                    
                    if neighbor_ip and neighbor_ip not in visited:
                        # Try to resolve to inventory hostname
                        resolved_ip = self._resolve_neighbor_ip(neighbor_ip)
                        if resolved_ip:
                            possible_hops.append(resolved_ip)
            
            if not possible_hops:
                return None
            
            # Prioritize direct connection to router
            if target_router in possible_hops:
                return target_router
            
            # Prioritize devices that have the target router configured
            for hop in possible_hops:
                try:
                    if self.nr.inventory.hosts[hop].data.get('router') == target_router:
                        return hop
                except KeyError:
                    continue
            
            # Return first available hop
            return possible_hops[0]
            
        except Exception as e:
            logger.error(f"Error finding next hop from {current_device}: {str(e)}")
            return None

    def _extract_neighbor_ip(self, neighbor: Dict) -> Optional[str]:
        """Extract neighbor IP from LLDP data"""
        neighbor_ip = (neighbor.get('mgmt_address') or 
                      neighbor.get('neighbor') or 
                      neighbor.get('neighbor_name') or
                      neighbor.get('system_name'))
        
        if neighbor_ip and '.' not in neighbor_ip:
            # Handle hostname format
            neighbor_ip = neighbor_ip.split('.')[0]
        
        return neighbor_ip

    def _resolve_neighbor_ip(self, neighbor_ip: str) -> Optional[str]:
        """Resolve neighbor IP to inventory hostname"""
        # Direct match
        if neighbor_ip in self.nr.inventory.hosts:
            return neighbor_ip
        
        # Hostname match
        for hostname, host in self.nr.inventory.hosts.items():
            if (host.get('hostname', '') == neighbor_ip or 
                hostname.startswith(neighbor_ip)):
                return hostname
        
        return None

    def verify_vlan_path(self, initial_switch: str, target_port: str, vlan_id: str) -> Tuple[bool, str, List[str], Dict[str, DeviceResult]]:
        """Comprehensive VLAN path verification"""
        logger.info("Starting VLAN path verification")
        
        # Trace path
        path = self.trace_path_to_router(initial_switch)
        if not path:
            return False, "No path found to router", [], {}

        # Verify each device in path
        results = {}
        overall_success = True
        failure_reasons = []
        
        for i, device_ip in enumerate(path):
            logger.info(f"Verifying device {i+1}/{len(path)}: {device_ip}")
            
            result = DeviceResult(device_ip=device_ip, vlan_status="Unknown")
            
            # Check VLAN exists
            vlan_exists = self.nr.filter(name=device_ip).run(
                task=self.verify_vlan_exists,
                vlan_id=vlan_id
            )[device_ip].result
            
            if vlan_exists:
                result.vlan_status = "VLAN exists"
                logger.debug(f"VLAN {vlan_id} exists on {device_ip}")
            else:
                result.vlan_status = "VLAN missing"
                result.overall_status = VerificationStatus.FAIL
                overall_success = False
                failure_reasons.append(f"VLAN {vlan_id} missing on {device_ip}")
                logger.warning(f"VLAN {vlan_id} missing on {device_ip}")
            
            # First device: check access port
            if i == 0:
                access_ok = self.nr.filter(name=device_ip).run(
                    task=self.verify_access_vlan,
                    interface=target_port,
                    vlan_id=vlan_id
                )[device_ip].result
                
                if access_ok:
                    result.port_status = "Access port configured"
                    logger.debug(f"Access port {target_port} configured on {device_ip}")
                else:
                    result.port_status = f"Port {target_port} not in VLAN {vlan_id}"
                    result.overall_status = VerificationStatus.FAIL
                    overall_success = False
                    failure_reasons.append(f"Port {target_port} not in VLAN {vlan_id}")
                    logger.warning(f"Port {target_port} not in VLAN {vlan_id}")
            
            # Intermediate devices: check trunk ports
            elif i < len(path) - 1:
                next_device = path[i + 1]
                uplink_port = self.nr.filter(name=device_ip).run(
                    task=self.find_uplink_port,
                    neighbor_ip=next_device
                )[device_ip].result
                
                if uplink_port:
                    trunk_ok = self.nr.filter(name=device_ip).run(
                        task=self.verify_trunk_vlan,
                        interface=uplink_port,
                        vlan_id=vlan_id
                    )[device_ip].result
                    
                    if trunk_ok:
                        result.trunk_status = f"Trunk {uplink_port} allows VLAN"
                        logger.debug(f"Trunk {uplink_port} allows VLAN {vlan_id}")
                    else:
                        result.trunk_status = f"VLAN {vlan_id} blocked on {uplink_port}"
                        result.overall_status = VerificationStatus.FAIL
                        overall_success = False
                        failure_reasons.append(f"VLAN {vlan_id} blocked on {uplink_port}")
                        logger.warning(f"VLAN {vlan_id} blocked on {uplink_port}")
                else:
                    result.trunk_status = f"No uplink found to {next_device}"
                    result.overall_status = VerificationStatus.FAIL
                    overall_success = False
                    failure_reasons.append(f"No uplink found to {next_device}")
                    logger.warning(f"No uplink found to {next_device}")
            
            # Router endpoint
            else:
                result.role = "Router endpoint"
                logger.debug(f"Router endpoint: {device_ip}")
            
            # Set overall status if not already failed
            if result.overall_status == VerificationStatus.UNKNOWN:
                result.overall_status = VerificationStatus.PASS
            
            results[device_ip] = result

        # Generate summary message
        if overall_success:
            message = f"VLAN {vlan_id} path fully verified"
        else:
            message = f"VLAN path verification failed: {'; '.join(failure_reasons[:3])}"
        
        logger.info(f"Verification complete: {message}")
        return overall_success, message, path, results

    def visualize_path(self, path: List[str], verification_results: Dict[str, DeviceResult]):
        """Create enhanced visualization of the network path"""
        plt.ioff()
        fig, ax = plt.subplots(figsize=(18, 12))
        
        # Create graph
        G = nx.path_graph(path)
        
        # Position nodes
        pos = {node: (i * 3, 0) for i, node in enumerate(G.nodes())}
        
        # Prepare node colors and labels
        node_colors = []
        node_labels = {}
        status_labels = {}
        
        for node in G.nodes():
            result = verification_results.get(node)
            if not result:
                node_colors.append("gray")
                status_labels[node] = "No data"
                continue
            
            # Determine color based on status
            if result.overall_status == VerificationStatus.PASS:
                node_colors.append("lightgreen")
                status = "✓ PASS"
            elif result.overall_status == VerificationStatus.FAIL:
                node_colors.append("red")
                status = "✗ FAIL"
            else:
                node_colors.append("gray")
                status = "? UNKNOWN"
            
            # Create node label
            node_labels[node] = node
            
            # Create status label
            status_lines = [f"Status: {status}"]
            
            if result.vlan_status:
                status_lines.append(f"VLAN: {result.vlan_status}")
            
            if result.port_status:
                status_lines.append(f"Port: {result.port_status}")
            
            if result.trunk_status:
                status_lines.append(f"Trunk: {result.trunk_status}")
            
            if result.role:
                status_lines.append(f"Role: {result.role}")
            
            status_labels[node] = "\n".join(status_lines[:4])  # Limit to 4 lines
        
        # Draw network graph
        nx.draw_networkx_nodes(G, pos, node_color=node_colors, node_size=5000, 
                              edgecolors='black', linewidths=2)
        nx.draw_networkx_edges(G, pos, width=3, edge_color='steelblue', 
                              arrows=True, arrowstyle='-|>', arrowsize=30)
        
        # Add device labels (above nodes)
        name_pos = {k: (v[0], v[1] + 0.8) for k, v in pos.items()}
        nx.draw_networkx_labels(G, name_pos, labels=node_labels, font_size=10, 
                               font_weight="bold")
        
        # Add status labels (below nodes)
        status_pos = {k: (v[0], v[1] - 1.2) for k, v in pos.items()}
        nx.draw_networkx_labels(G, status_pos, labels=status_labels, font_size=8,
                               bbox=dict(facecolor='white', edgecolor='black',
                                       boxstyle='round,pad=0.5', alpha=0.9))
        
        # Add legend
        legend_elements = [
            plt.Line2D([0], [0], marker='o', color='w', label='Pass', 
                      markerfacecolor='lightgreen', markersize=15),
            plt.Line2D([0], [0], marker='o', color='w', label='Fail', 
                      markerfacecolor='red', markersize=15),
            plt.Line2D([0], [0], marker='o', color='w', label='Unknown', 
                      markerfacecolor='gray', markersize=15)
        ]
        
        plt.legend(handles=legend_elements, loc='upper right', fontsize=12, 
                  title="Verification Status", title_fontsize=14)
        
        plt.title("Network VLAN Path Verification Results", pad=40, fontsize=18, 
                 fontweight='bold')
        plt.axis('off')
        plt.tight_layout()
        plt.show(block=True)
        plt.ion()


def main():
    """Main function to run VLAN path verification"""
    # Configuration
    initial_switch = "172.17.57.243"
    target_port = "GigabitEthernet1/0/10"
    vlan_id = "5"
    
    # Create verifier instance
    verifier = NetworkVerifier(config_file="config.yaml")
    
    try:
        # Run verification
        success, message, path, results = verifier.verify_vlan_path(
            initial_switch, target_port, vlan_id
        )
        
        # Print results
        print("\n" + "="*60)
        print(f"VLAN PATH VERIFICATION {'SUCCEEDED' if success else 'FAILED'}")
        print("="*60)
        print(f"Initial Switch: {initial_switch}")
        print(f"Target Port: {target_port}")
        print(f"VLAN ID: {vlan_id}")
        print(f"Path: {' → '.join(path)}")
        print(f"Status: {message}")
        print("="*60)
        
        # Detailed results
        print("\nDETAILED RESULTS:")
        print("-" * 40)
        for device_ip, result in results.items():
            print(f"\nDevice: {device_ip}")
            print(f"  Overall Status: {result.overall_status.value.upper()}")
            print(f"  VLAN Status: {result.vlan_status}")
            if result.port_status:
                print(f"  Port Status: {result.port_status}")
            if result.trunk_status:
                print(f"  Trunk Status: {result.trunk_status}")
            if result.role:
                print(f"  Role: {result.role}")
        
        # Show visualization
        if path and results:
            print("\nGenerating network visualization...")
            verifier.visualize_path(path, results)
        
        return success
        
    except Exception as e:
        logger.error(f"Verification failed with error: {str(e)}")
        print(f"\nERROR: Verification failed - {str(e)}")
        return False
    
    finally:
        # Cleanup
        if hasattr(verifier, 'nr') and verifier.nr:
            verifier.nr.close_connections()


if __name__ == "__main__":
    import sys
    
    # Allow command line arguments
    if len(sys.argv) >= 4:
        initial_switch = sys.argv[1]
        target_port = sys.argv[2]
        vlan_id = sys.argv[3]
        
        verifier = NetworkVerifier()
        success, message, path, results = verifier.verify_vlan_path(
            initial_switch, target_port, vlan_id
        )
        
        if success:
            print(f"✓ VLAN {vlan_id} path verification successful")
            sys.exit(0)
        else:
            print(f"✗ VLAN {vlan_id} path verification failed: {message}")
            sys.exit(1)
    else:
        # Use default configuration
        success = main()
        sys.exit(0 if success else 1)
from nornir import InitNornir
from nornir_netmiko import netmiko_send_command
from nornir.core.task import Task, Result
from typing import Dict, List, Tuple, Optional, Set
import networkx as nx
import matplotlib.pyplot as plt
import re
import logging
from dataclasses import dataclass
from enum import Enum

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class VerificationStatus(Enum):
    PASS = "pass"
    FAIL = "fail"
    UNKNOWN = "unknown"

@dataclass
class DeviceResult:
    device_ip: str
    vlan_status: str
    port_status: Optional[str] = None
    trunk_status: Optional[str] = None
    role: Optional[str] = None
    overall_status: VerificationStatus = VerificationStatus.UNKNOWN

class NetworkVerifier:
    def __init__(self, config_file: str = "config.yaml"):
        self.nr = InitNornir(config_file=config_file)
        self.max_hops = 15
        
    def get_lldp_neighbors(self, task: Task) -> List[Dict]:
        """Collect LLDP neighbor information in a vendor-neutral way"""
        platform = task.host.platform
        
        # Enhanced command mapping for different platforms
        command_map = {
            "aruba_cx": "show lldp neighbors detail",
            "cisco_ios": "show lldp neighbors detail",
            "cisco_xe": "show lldp neighbors detail",
            "hp_comware": "display lldp neighbor-information",
            "juniper": "show lldp neighbors detail"
        }
        
        command = command_map.get(platform, "show lldp neighbors detail")
        
        logger.debug(f"Running on {task.host}: {command}")
        
        try:
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            # Handle different result types
            if isinstance(result.result, str):
                logger.warning(f"TextFSM parsing failed for {task.host}, attempting manual parsing")
                return self._parse_lldp_manually(result.result, platform)
            elif isinstance(result.result, dict):
                return [result.result]
            elif isinstance(result.result, list):
                return result.result
            else:
                logger.warning(f"No LLDP neighbors found on {task.host}")
                return []
                
        except Exception as e:
            logger.error(f"Error getting LLDP neighbors on {task.host}: {str(e)}")
            return []

    def _parse_lldp_manually(self, output: str, platform: str) -> List[Dict]:
        """Manual parsing fallback for when TextFSM fails"""
        neighbors = []
        
        try:
            # Basic regex patterns for common LLDP output formats
            if platform == "cisco_ios":
                # Cisco IOS LLDP format
                pattern = r'Device ID: (\S+).*?Local Intf: (\S+).*?Port id: (\S+)'
                matches = re.findall(pattern, output, re.DOTALL)
                
                for match in matches:
                    neighbors.append({
                        'neighbor': match[0],
                        'local_interface': match[1],
                        'neighbor_port': match[2]
                    })
            
            # Add more platform-specific parsing as needed
            
        except Exception as e:
            logger.error(f"Manual LLDP parsing failed: {str(e)}")
            
        return neighbors

    def find_uplink_port(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find the local interface connected to a neighbor with improved error handling"""
        platform = task.host.platform
        
        try:
            # Try LLDP first (most reliable)
            lldp_result = self._find_port_via_lldp(task, neighbor_ip, platform)
            if lldp_result:
                return lldp_result
            
            # Fall back to CDP for Cisco devices
            if platform.startswith("cisco"):
                cdp_result = self._find_port_via_cdp(task, neighbor_ip)
                if cdp_result:
                    return cdp_result
                    
            # Last resort: MAC address table lookup
            mac_result = self._find_port_via_mac(task, neighbor_ip)
            if mac_result:
                return mac_result
                
        except Exception as e:
            logger.error(f"Error finding uplink port on {task.host}: {str(e)}")
        
        return None

    def _find_port_via_lldp(self, task: Task, neighbor_ip: str, platform: str) -> Optional[str]:
        """Find port using LLDP"""
        try:
            neighbors = self.get_lldp_neighbors(task)
            
            for neighbor in neighbors:
                # Check multiple possible neighbor identifier fields
                neighbor_id = (neighbor.get('neighbor') or 
                             neighbor.get('mgmt_address') or 
                             neighbor.get('system_name'))
                
                if neighbor_id and (neighbor_id == neighbor_ip or 
                                  neighbor_id.startswith(neighbor_ip.split('.')[0])):
                    return neighbor.get('local_interface')
                    
        except Exception as e:
            logger.debug(f"LLDP port lookup failed: {str(e)}")
            
        return None

    def _find_port_via_cdp(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find port using CDP (Cisco devices)"""
        try:
            command = "show cdp neighbors detail"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if result.result:
                for neighbor in (result.result if isinstance(result.result, list) else [result.result]):
                    if neighbor.get('mgmt_address') == neighbor_ip:
                        return neighbor.get('local_port')
                        
        except Exception as e:
            logger.debug(f"CDP port lookup failed: {str(e)}")
            
        return None

    def _find_port_via_mac(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find port using MAC address table (least reliable)"""
        try:
            # This would require ARP table lookup first, then MAC table
            # Implementation depends on specific requirements
            pass
        except Exception as e:
            logger.debug(f"MAC table port lookup failed: {str(e)}")
            
        return None

    def verify_vlan_exists(self, task: Task, vlan_id: str) -> bool:
        """Check if VLAN exists with enhanced platform support"""
        platform = task.host.platform
        
        command_map = {
            "aruba_cx": f"show vlan {vlan_id}",
            "cisco_ios": f"show vlan id {vlan_id}",
            "cisco_xe": f"show vlan id {vlan_id}",
            "hp_comware": f"display vlan {vlan_id}",
            "juniper": f"show vlans {vlan_id}"
        }
        
        command = command_map.get(platform, f"show vlan id {vlan_id}")
        
        try:
            logger.debug(f"Running on {task.host}: {command}")
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if isinstance(result.result, str):
                # Check for common error messages
                error_indicators = ["invalid", "not found", "does not exist", "error"]
                return not any(indicator in result.result.lower() for indicator in error_indicators)
            
            return bool(result.result)
            
        except Exception as e:
            logger.error(f"Error checking VLAN on {task.host}: {str(e)}")
            return False

    def verify_access_vlan(self, task: Task, interface: str, vlan_id: str) -> bool:
        """Verify access port VLAN configuration with better error handling"""
        platform = task.host.platform
        
        try:
            # Method 1: Check VLAN membership
            if self._check_vlan_membership(task, interface, vlan_id, platform):
                return True
            
            # Method 2: Check interface configuration
            if self._check_interface_config(task, interface, vlan_id, platform):
                return True
            
            logger.debug(f"Access VLAN {vlan_id} not found on {interface}")
            return False
            
        except Exception as e:
            logger.error(f"Error checking access port on {task.host}: {str(e)}")
            return False

    def _check_vlan_membership(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check VLAN membership tables"""
        try:
            command_map = {
                "aruba_cx": f"show vlan {vlan_id}",
                "cisco_ios": f"show vlan id {vlan_id}",
                "cisco_xe": f"show vlan id {vlan_id}",
            }
            
            command = command_map.get(platform, f"show vlan id {vlan_id}")
            
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if result.result:
                for vlan in (result.result if isinstance(result.result, list) else [result.result]):
                    interfaces = vlan.get('interfaces', [])
                    if isinstance(interfaces, str):
                        interfaces = [interfaces]
                    
                    # Normalize interface names for comparison
                    normalized_interfaces = [self._normalize_interface_name(intf) for intf in interfaces]
                    normalized_target = self._normalize_interface_name(interface)
                    
                    if normalized_target in normalized_interfaces:
                        return True
                        
        except Exception as e:
            logger.debug(f"VLAN membership check failed: {str(e)}")
            
        return False

    def _check_interface_config(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check interface running configuration"""
        try:
            command = f"show running-config interface {interface}"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=False,
                enable=True
            )
            
            config = result.result.lower()
            
            # Platform-specific config patterns
            patterns = {
                "aruba_cx": [f"vlan access {vlan_id}"],
                "cisco_ios": [f"switchport access vlan {vlan_id}"],
                "cisco_xe": [f"switchport access vlan {vlan_id}"],
            }
            
            check_patterns = patterns.get(platform, [f"switchport access vlan {vlan_id}"])
            
            return any(pattern in config for pattern in check_patterns)
            
        except Exception as e:
            logger.debug(f"Interface config check failed: {str(e)}")
            
        return False

    def _normalize_interface_name(self, interface: str) -> str:
        """Normalize interface names for comparison"""
        # Handle common abbreviations
        interface = interface.replace("GigabitEthernet", "Gi")
        interface = interface.replace("FastEthernet", "Fa")
        interface = interface.replace("TenGigabitEthernet", "Te")
        
        # Remove spaces and convert to lowercase
        return interface.replace(" ", "").lower()

    def verify_trunk_vlan(self, task: Task, interface: str, vlan_id: str) -> bool:
        """Verify trunk allows the VLAN with comprehensive checking"""
        platform = task.host.platform
        
        try:
            # Method 1: Check switchport status
            if self._check_switchport_trunk(task, interface, vlan_id, platform):
                return True
            
            # Method 2: Check running configuration
            if self._check_trunk_config(task, interface, vlan_id, platform):
                return True
            
            return False
            
        except Exception as e:
            logger.error(f"Error checking trunk on {task.host}: {str(e)}")
            return False

    def _check_switchport_trunk(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check switchport trunk status"""
        try:
            command = f"show interfaces {interface} switchport"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if isinstance(result.result, str):
                # Parse raw output
                return self._parse_trunk_raw_output(result.result, vlan_id)
            
            if result.result and isinstance(result.result, list):
                sw_data = result.result[0]
                
                # Check if port is in trunk mode
                if sw_data.get('mode', '').lower() != 'trunk':
                    return False
                
                # Check allowed VLANs
                return self._check_allowed_vlans(sw_data, vlan_id)
                
        except Exception as e:
            logger.debug(f"Switchport trunk check failed: {str(e)}")
            
        return False

    def _parse_trunk_raw_output(self, output: str, vlan_id: str) -> bool:
        """Parse raw switchport output"""
        output_lower = output.lower()
        
        if "trunking" in output_lower:
            if "vlans allowed: all" in output_lower:
                return True
            if f"vlans allowed: {vlan_id}" in output_lower:
                return True
        
        return False

    def _check_allowed_vlans(self, switchport_data: Dict, vlan_id: str) -> bool:
        """Check if VLAN is in allowed VLAN list"""
        for field in ['trunking_vlans', 'vlans_allowed', 'allowed_vlans']:
            vlans = switchport_data.get(field, '')
            
            if vlans:
                if vlans.upper() == 'ALL':
                    return True
                if self._is_vlan_in_list(vlans, vlan_id):
                    return True
        
        return False

    def _check_trunk_config(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check trunk configuration in running config"""
        try:
            command = f"show running-config interface {interface}"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                enable=True
            )
            
            config = result.result.lower()
            
            # If trunk mode is configured but no allowed VLAN restrictions, assume all VLANs allowed
            if "switchport mode trunk" in config and "switchport trunk allowed vlan" not in config:
                return True
            
            # Check specific VLAN allowances
            if f"switchport trunk allowed vlan add {vlan_id}" in config:
                return True
            
            return False
            
        except Exception as e:
            logger.debug(f"Trunk config check failed: {str(e)}")
            
        return False

    def _is_vlan_in_list(self, vlan_str: str, target_vlan: str) -> bool:
        """Helper to safely parse VLAN lists (1,5,10-20,30)"""
        try:
            if not vlan_str:
                return False
                
            target_int = int(target_vlan)
            
            for part in str(vlan_str).split(','):
                part = part.strip()
                
                if '-' in part:
                    # Handle range (e.g., "10-20")
                    start, end = map(int, part.split('-'))
                    if start <= target_int <= end:
                        return True
                elif part.isdigit() and int(part) == target_int:
                    return True
                    
            return False
            
        except (ValueError, AttributeError) as e:
            logger.error(f"VLAN list parsing failed: {str(e)}")
            return False

    def trace_path_to_router(self, start_device: str) -> List[str]:
        """Trace path from edge switch to router using LLDP with improved logic"""
        logger.info("Starting path trace to router...")
        
        path = []
        current_device = start_device
        visited: Set[str] = set()
        
        # Get target router
        try:
            target_router = self.nr.inventory.hosts[start_device].data.get('router')
            if not target_router:
                logger.error(f"No router defined for {start_device}")
                return []
        except KeyError:
            logger.error(f"Device {start_device} not found in inventory")
            return []

        logger.info(f"Target router: {target_router}")

        while current_device and current_device not in visited and len(path) < self.max_hops:
            visited.add(current_device)
            path.append(current_device)
            
            logger.debug(f"Current device: {current_device}")
            logger.debug(f"Current path: {' -> '.join(path)}")
            
            # Check if we've reached the target router
            if current_device == target_router:
                logger.info(f"Reached target router: {current_device}")
                break
            
            # Get neighbors and find next hop
            next_hop = self._find_next_hop(current_device, target_router, visited)
            if not next_hop:
                logger.warning(f"No valid next hop found from {current_device}")
                break
                
            current_device = next_hop

        # Ensure router is in path
        if path and path[-1] != target_router:
            path.append(target_router)
            logger.debug(f"Added router {target_router} to path")

        logger.info(f"Final path: {' -> '.join(path)}")
        return path

    def _find_next_hop(self, current_device: str, target_router: str, visited: Set[str]) -> Optional[str]:
        """Find the next hop in the path"""
        try:
            neighbors_result = self.nr.filter(name=current_device).run(task=self.get_lldp_neighbors)
            neighbors = neighbors_result[current_device].result
            
            if not neighbors:
                logger.debug(f"No neighbors found for {current_device}")
                return None
            
            # Find unvisited neighbors
            possible_hops = []
            for neighbor in (neighbors if isinstance(neighbors, list) else [neighbors]):
                if isinstance(neighbor, dict):
                    neighbor_ip = self._extract_neighbor_ip(neighbor)
                    
                    if neighbor_ip and neighbor_ip not in visited:
                        # Try to resolve to inventory hostname
                        resolved_ip = self._resolve_neighbor_ip(neighbor_ip)
                        if resolved_ip:
                            possible_hops.append(resolved_ip)
            
            if not possible_hops:
                return None
            
            # Prioritize direct connection to router
            if target_router in possible_hops:
                return target_router
            
            # Prioritize devices that have the target router configured
            for hop in possible_hops:
                try:
                    if self.nr.inventory.hosts[hop].data.get('router') == target_router:
                        return hop
                except KeyError:
                    continue
            
            # Return first available hop
            return possible_hops[0]
            
        except Exception as e:
            logger.error(f"Error finding next hop from {current_device}: {str(e)}")
            return None

    def _extract_neighbor_ip(self, neighbor: Dict) -> Optional[str]:
        """Extract neighbor IP from LLDP data"""
        neighbor_ip = (neighbor.get('mgmt_address') or 
                      neighbor.get('neighbor') or 
                      neighbor.get('neighbor_name') or
                      neighbor.get('system_name'))
        
        if neighbor_ip and '.' not in neighbor_ip:
            # Handle hostname format
            neighbor_ip = neighbor_ip.split('.')[0]
        
        return neighbor_ip

    def _resolve_neighbor_ip(self, neighbor_ip: str) -> Optional[str]:
        """Resolve neighbor IP to inventory hostname"""
        # Direct match
        if neighbor_ip in self.nr.inventory.hosts:
            return neighbor_ip
        
        # Hostname match
        for hostname, host in self.nr.inventory.hosts.items():
            if (host.get('hostname', '') == neighbor_ip or 
                hostname.startswith(neighbor_ip)):
                return hostname
        
        return None

    def verify_vlan_path(self, initial_switch: str, target_port: str, vlan_id: str) -> Tuple[bool, str, List[str], Dict[str, DeviceResult]]:
        """Comprehensive VLAN path verification"""
        logger.info("Starting VLAN path verification")
        
        # Trace path
        path = self.trace_path_to_router(initial_switch)
        if not path:
            return False, "No path found to router", [], {}

        # Verify each device in path
        results = {}
        overall_success = True
        failure_reasons = []
        
        for i, device_ip in enumerate(path):
            logger.info(f"Verifying device {i+1}/{len(path)}: {device_ip}")
            
            result = DeviceResult(device_ip=device_ip, vlan_status="Unknown")
            
            # Check VLAN exists
            vlan_exists = self.nr.filter(name=device_ip).run(
                task=self.verify_vlan_exists,
                vlan_id=vlan_id
            )[device_ip].result
            
            if vlan_exists:
                result.vlan_status = "VLAN exists"
                logger.debug(f"VLAN {vlan_id} exists on {device_ip}")
            else:
                result.vlan_status = "VLAN missing"
                result.overall_status = VerificationStatus.FAIL
                overall_success = False
                failure_reasons.append(f"VLAN {vlan_id} missing on {device_ip}")
                logger.warning(f"VLAN {vlan_id} missing on {device_ip}")
            
            # First device: check access port
            if i == 0:
                access_ok = self.nr.filter(name=device_ip).run(
                    task=self.verify_access_vlan,
                    interface=target_port,
                    vlan_id=vlan_id
                )[device_ip].result
                
                if access_ok:
                    result.port_status = "Access port configured"
                    logger.debug(f"Access port {target_port} configured on {device_ip}")
                else:
                    result.port_status = f"Port {target_port} not in VLAN {vlan_id}"
                    result.overall_status = VerificationStatus.FAIL
                    overall_success = False
                    failure_reasons.append(f"Port {target_port} not in VLAN {vlan_id}")
                    logger.warning(f"Port {target_port} not in VLAN {vlan_id}")
            
            # Intermediate devices: check trunk ports
            elif i < len(path) - 1:
                next_device = path[i + 1]
                uplink_port = self.nr.filter(name=device_ip).run(
                    task=self.find_uplink_port,
                    neighbor_ip=next_device
                )[device_ip].result
                
                if uplink_port:
                    trunk_ok = self.nr.filter(name=device_ip).run(
                        task=self.verify_trunk_vlan,
                        interface=uplink_port,
                        vlan_id=vlan_id
                    )[device_ip].result
                    
                    if trunk_ok:
                        result.trunk_status = f"Trunk {uplink_port} allows VLAN"
                        logger.debug(f"Trunk {uplink_port} allows VLAN {vlan_id}")
                    else:
                        result.trunk_status = f"VLAN {vlan_id} blocked on {uplink_port}"
                        result.overall_status = VerificationStatus.FAIL
                        overall_success = False
                        failure_reasons.append(f"VLAN {vlan_id} blocked on {uplink_port}")
                        logger.warning(f"VLAN {vlan_id} blocked on {uplink_port}")
                else:
                    result.trunk_status = f"No uplink found to {next_device}"
                    result.overall_status = VerificationStatus.FAIL
                    overall_success = False
                    failure_reasons.append(f"No uplink found to {next_device}")
                    logger.warning(f"No uplink found to {next_device}")
            
            # Router endpoint
            else:
                result.role = "Router endpoint"
                logger.debug(f"Router endpoint: {device_ip}")
            
            # Set overall status if not already failed
            if result.overall_status == VerificationStatus.UNKNOWN:
                result.overall_status = VerificationStatus.PASS
            
            results[device_ip] = result

        # Generate summary message
        if overall_success:
            message = f"VLAN {vlan_id} path fully verified"
        else:
            message = f"VLAN path verification failed: {'; '.join(failure_reasons[:3])}"
        
        logger.info(f"Verification complete: {message}")
        return overall_success, message, path, results

    def visualize_path(self, path: List[str], verification_results: Dict[str, DeviceResult]):
        """Create enhanced visualization of the network path"""
        plt.ioff()
        fig, ax = plt.subplots(figsize=(18, 12))
        
        # Create graph
        G = nx.path_graph(path)
        
        # Position nodes
        pos = {node: (i * 3, 0) for i, node in enumerate(G.nodes())}
        
        # Prepare node colors and labels
        node_colors = []
        node_labels = {}
        status_labels = {}
        
        for node in G.nodes():
            result = verification_results.get(node)
            if not result:
                node_colors.append("gray")
                status_labels[node] = "No data"
                continue
            
            # Determine color based on status
            if result.overall_status == VerificationStatus.PASS:
                node_colors.append("lightgreen")
                status = "✓ PASS"
            elif result.overall_status == VerificationStatus.FAIL:
                node_colors.append("red")
                status = "✗ FAIL"
            else:
                node_colors.append("gray")
                status = "? UNKNOWN"
            
            # Create node label
            node_labels[node] = node
            
            # Create status label
            status_lines = [f"Status: {status}"]
            
            if result.vlan_status:
                status_lines.append(f"VLAN: {result.vlan_status}")
            
            if result.port_status:
                status_lines.append(f"Port: {result.port_status}")
            
            if result.trunk_status:
                status_lines.append(f"Trunk: {result.trunk_status}")
            
            if result.role:
                status_lines.append(f"Role: {result.role}")
            
            status_labels[node] = "\n".join(status_lines[:4])  # Limit to 4 lines
        
        # Draw network graph
        nx.draw_networkx_nodes(G, pos, node_color=node_colors, node_size=5000, 
                              edgecolors='black', linewidths=2)
        nx.draw_networkx_edges(G, pos, width=3, edge_color='steelblue', 
                              arrows=True, arrowstyle='-|>', arrowsize=30)
        
        # Add device labels (above nodes)
        name_pos = {k: (v[0], v[1] + 0.8) for k, v in pos.items()}
        nx.draw_networkx_labels(G, name_pos, labels=node_labels, font_size=10, 
                               font_weight="bold")
        
        # Add status labels (below nodes)
        status_pos = {k: (v[0], v[1] - 1.2) for k, v in pos.items()}
        nx.draw_networkx_labels(G, status_pos, labels=status_labels, font_size=8,
                               bbox=dict(facecolor='white', edgecolor='black',
                                       boxstyle='round,pad=0.5', alpha=0.9))
        
        # Add legend
        legend_elements = [
            plt.Line2D([0], [0], marker='o', color='w', label='Pass', 
                      markerfacecolor='lightgreen', markersize=15),
            plt.Line2D([0], [0], marker='o', color='w', label='Fail', 
                      markerfacecolor='red', markersize=15),
            plt.Line2D([0], [0], marker='o', color='w', label='Unknown', 
                      markerfacecolor='gray', markersize=15)
        ]
        
        plt.legend(handles=legend_elements, loc='upper right', fontsize=12, 
                  title="Verification Status", title_fontsize=14)
        
        plt.title("Network VLAN Path Verification Results", pad=40, fontsize=18, 
                 fontweight='bold')
        plt.axis('off')
        plt.tight_layout()
        plt.show(block=True)
        plt.ion()


def main():
    """Main function to run VLAN path verification"""
    # Configuration
    initial_switch = "172.17.57.243"
    target_port = "GigabitEthernet1/0/10"
    vlan_id = "5"
    
    # Create verifier instance
    verifier = NetworkVerifier(config_file="config.yaml")
    
    try:
        # Run verification
        success, message, path, results = verifier.verify_vlan_path(
            initial_switch, target_port, vlan_id
        )
        
        # Print results
        print("\n" + "="*60)
        print(f"VLAN PATH VERIFICATION {'SUCCEEDED' if success else 'FAILED'}")
        print("="*60)
        print(f"Initial Switch: {initial_switch}")
        print(f"Target Port: {target_port}")
        print(f"VLAN ID: {vlan_id}")
        print(f"Path: {' → '.join(path)}")
        print(f"Status: {message}")
        print("="*60)
        
        # Detailed results
        print("\nDETAILED RESULTS:")
        print("-" * 40)
        for device_ip, result in results.items():
            print(f"\nDevice: {device_ip}")
            print(f"  Overall Status: {result.overall_status.value.upper()}")
            print(f"  VLAN Status: {result.vlan_status}")
            if result.port_status:
                print(f"  Port Status: {result.port_status}")
            if result.trunk_status:
                print(f"  Trunk Status: {result.trunk_status}")
            if result.role:
                print(f"  Role: {result.role}")
        
        # Show visualization
        if path and results:
            print("\nGenerating network visualization...")
            verifier.visualize_path(path, results)
        
        return success
        
    except Exception as e:
        logger.error(f"Verification failed with error: {str(e)}")
        print(f"\nERROR: Verification failed - {str(e)}")
        return False
    
    finally:
        # Cleanup
        if hasattr(verifier, 'nr') and verifier.nr:
            verifier.nr.close_connections()


if __name__ == "__main__":
    import sys
    
    # Allow command line arguments
    if len(sys.argv) >= 4:
        initial_switch = sys.argv[1]
        target_port = sys.argv[2]
        vlan_id = sys.argv[3]
        
        verifier = NetworkVerifier()
        success, message, path, results = verifier.verify_vlan_path(
            initial_switch, target_port, vlan_id
        )
        
        if success:
            print(f"✓ VLAN {vlan_id} path verification successful")
            sys.exit(0)
        else:
            print(f"✗ VLAN {vlan_id} path verification failed: {message}")
            sys.exit(1)
    else:
        # Use default configuration
        success = main()
        sys.exit(0 if success else 1)ese values
from nornir import InitNornir
from nornir_netmiko import netmiko_send_command
from nornir.core.task import Task, Result
from typing import Dict, List, Tuple, Optional, Set
import networkx as nx
import matplotlib.pyplot as plt
import re
import logging
from dataclasses import dataclass
from enum import Enum

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class VerificationStatus(Enum):
    PASS = "pass"
    FAIL = "fail"
    UNKNOWN = "unknown"

@dataclass
class DeviceResult:
    device_ip: str
    vlan_status: str
    port_status: Optional[str] = None
    trunk_status: Optional[str] = None
    role: Optional[str] = None
    overall_status: VerificationStatus = VerificationStatus.UNKNOWN

class NetworkVerifier:
    def __init__(self, config_file: str = "config.yaml"):
        self.nr = InitNornir(config_file=config_file)
        self.max_hops = 15
        
    def get_lldp_neighbors(self, task: Task) -> List[Dict]:
        """Collect LLDP neighbor information in a vendor-neutral way"""
        platform = task.host.platform
        
        # Enhanced command mapping for different platforms
        command_map = {
            "aruba_cx": "show lldp neighbors detail",
            "cisco_ios": "show lldp neighbors detail",
            "cisco_xe": "show lldp neighbors detail",
            "hp_comware": "display lldp neighbor-information",
            "juniper": "show lldp neighbors detail"
        }
        
        command = command_map.get(platform, "show lldp neighbors detail")
        
        logger.debug(f"Running on {task.host}: {command}")
        
        try:
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            # Handle different result types
            if isinstance(result.result, str):
                logger.warning(f"TextFSM parsing failed for {task.host}, attempting manual parsing")
                return self._parse_lldp_manually(result.result, platform)
            elif isinstance(result.result, dict):
                return [result.result]
            elif isinstance(result.result, list):
                return result.result
            else:
                logger.warning(f"No LLDP neighbors found on {task.host}")
                return []
                
        except Exception as e:
            logger.error(f"Error getting LLDP neighbors on {task.host}: {str(e)}")
            return []

    def _parse_lldp_manually(self, output: str, platform: str) -> List[Dict]:
        """Manual parsing fallback for when TextFSM fails"""
        neighbors = []
        
        try:
            # Basic regex patterns for common LLDP output formats
            if platform == "cisco_ios":
                # Cisco IOS LLDP format
                pattern = r'Device ID: (\S+).*?Local Intf: (\S+).*?Port id: (\S+)'
                matches = re.findall(pattern, output, re.DOTALL)
                
                for match in matches:
                    neighbors.append({
                        'neighbor': match[0],
                        'local_interface': match[1],
                        'neighbor_port': match[2]
                    })
            
            # Add more platform-specific parsing as needed
            
        except Exception as e:
            logger.error(f"Manual LLDP parsing failed: {str(e)}")
            
        return neighbors

    def find_uplink_port(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find the local interface connected to a neighbor with improved error handling"""
        platform = task.host.platform
        
        try:
            # Try LLDP first (most reliable)
            lldp_result = self._find_port_via_lldp(task, neighbor_ip, platform)
            if lldp_result:
                return lldp_result
            
            # Fall back to CDP for Cisco devices
            if platform.startswith("cisco"):
                cdp_result = self._find_port_via_cdp(task, neighbor_ip)
                if cdp_result:
                    return cdp_result
                    
            # Last resort: MAC address table lookup
            mac_result = self._find_port_via_mac(task, neighbor_ip)
            if mac_result:
                return mac_result
                
        except Exception as e:
            logger.error(f"Error finding uplink port on {task.host}: {str(e)}")
        
        return None

    def _find_port_via_lldp(self, task: Task, neighbor_ip: str, platform: str) -> Optional[str]:
        """Find port using LLDP"""
        try:
            neighbors = self.get_lldp_neighbors(task)
            
            for neighbor in neighbors:
                # Check multiple possible neighbor identifier fields
                neighbor_id = (neighbor.get('neighbor') or 
                             neighbor.get('mgmt_address') or 
                             neighbor.get('system_name'))
                
                if neighbor_id and (neighbor_id == neighbor_ip or 
                                  neighbor_id.startswith(neighbor_ip.split('.')[0])):
                    return neighbor.get('local_interface')
                    
        except Exception as e:
            logger.debug(f"LLDP port lookup failed: {str(e)}")
            
        return None

    def _find_port_via_cdp(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find port using CDP (Cisco devices)"""
        try:
            command = "show cdp neighbors detail"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if result.result:
                for neighbor in (result.result if isinstance(result.result, list) else [result.result]):
                    if neighbor.get('mgmt_address') == neighbor_ip:
                        return neighbor.get('local_port')
                        
        except Exception as e:
            logger.debug(f"CDP port lookup failed: {str(e)}")
            
        return None

    def _find_port_via_mac(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find port using MAC address table (least reliable)"""
        try:
            # This would require ARP table lookup first, then MAC table
            # Implementation depends on specific requirements
            pass
        except Exception as e:
            logger.debug(f"MAC table port lookup failed: {str(e)}")
            
        return None

    def verify_vlan_exists(self, task: Task, vlan_id: str) -> bool:
        """Check if VLAN exists with enhanced platform support"""
        platform = task.host.platform
        
        command_map = {
            "aruba_cx": f"show vlan {vlan_id}",
            "cisco_ios": f"show vlan id {vlan_id}",
            "cisco_xe": f"show vlan id {vlan_id}",
            "hp_comware": f"display vlan {vlan_id}",
            "juniper": f"show vlans {vlan_id}"
        }
        
        command = command_map.get(platform, f"show vlan id {vlan_id}")
        
        try:
            logger.debug(f"Running on {task.host}: {command}")
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if isinstance(result.result, str):
                # Check for common error messages
                error_indicators = ["invalid", "not found", "does not exist", "error"]
                return not any(indicator in result.result.lower() for indicator in error_indicators)
            
            return bool(result.result)
            
        except Exception as e:
            logger.error(f"Error checking VLAN on {task.host}: {str(e)}")
            return False

    def verify_access_vlan(self, task: Task, interface: str, vlan_id: str) -> bool:
        """Verify access port VLAN configuration with better error handling"""
        platform = task.host.platform
        
        try:
            # Method 1: Check VLAN membership
            if self._check_vlan_membership(task, interface, vlan_id, platform):
                return True
            
            # Method 2: Check interface configuration
            if self._check_interface_config(task, interface, vlan_id, platform):
                return True
            
            logger.debug(f"Access VLAN {vlan_id} not found on {interface}")
            return False
            
        except Exception as e:
            logger.error(f"Error checking access port on {task.host}: {str(e)}")
            return False

    def _check_vlan_membership(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check VLAN membership tables"""
        try:
            command_map = {
                "aruba_cx": f"show vlan {vlan_id}",
                "cisco_ios": f"show vlan id {vlan_id}",
                "cisco_xe": f"show vlan id {vlan_id}",
            }
            
            command = command_map.get(platform, f"show vlan id {vlan_id}")
            
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if result.result:
                for vlan in (result.result if isinstance(result.result, list) else [result.result]):
                    interfaces = vlan.get('interfaces', [])
                    if isinstance(interfaces, str):
                        interfaces = [interfaces]
                    
                    # Normalize interface names for comparison
                    normalized_interfaces = [self._normalize_interface_name(intf) for intf in interfaces]
                    normalized_target = self._normalize_interface_name(interface)
                    
                    if normalized_target in normalized_interfaces:
                        return True
                        
        except Exception as e:
            logger.debug(f"VLAN membership check failed: {str(e)}")
            
        return False

    def _check_interface_config(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check interface running configuration"""
        try:
            command = f"show running-config interface {interface}"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=False,
                enable=True
            )
            
            config = result.result.lower()
            
            # Platform-specific config patterns
            patterns = {
                "aruba_cx": [f"vlan access {vlan_id}"],
                "cisco_ios": [f"switchport access vlan {vlan_id}"],
                "cisco_xe": [f"switchport access vlan {vlan_id}"],
            }
            
            check_patterns = patterns.get(platform, [f"switchport access vlan {vlan_id}"])
            
            return any(pattern in config for pattern in check_patterns)
            
        except Exception as e:
            logger.debug(f"Interface config check failed: {str(e)}")
            
        return False

    def _normalize_interface_name(self, interface: str) -> str:
        """Normalize interface names for comparison"""
        # Handle common abbreviations
        interface = interface.replace("GigabitEthernet", "Gi")
        interface = interface.replace("FastEthernet", "Fa")
        interface = interface.replace("TenGigabitEthernet", "Te")
        
        # Remove spaces and convert to lowercase
        return interface.replace(" ", "").lower()

    def verify_trunk_vlan(self, task: Task, interface: str, vlan_id: str) -> bool:
        """Verify trunk allows the VLAN with comprehensive checking"""
        platform = task.host.platform
        
        try:
            # Method 1: Check switchport status
            if self._check_switchport_trunk(task, interface, vlan_id, platform):
                return True
            
            # Method 2: Check running configuration
            if self._check_trunk_config(task, interface, vlan_id, platform):
                return True
            
            return False
            
        except Exception as e:
            logger.error(f"Error checking trunk on {task.host}: {str(e)}")
            return False

    def _check_switchport_trunk(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check switchport trunk status"""
        try:
            command = f"show interfaces {interface} switchport"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if isinstance(result.result, str):
                # Parse raw output
                return self._parse_trunk_raw_output(result.result, vlan_id)
            
            if result.result and isinstance(result.result, list):
                sw_data = result.result[0]
                
                # Check if port is in trunk mode
                if sw_data.get('mode', '').lower() != 'trunk':
                    return False
                
                # Check allowed VLANs
                return self._check_allowed_vlans(sw_data, vlan_id)
                
        except Exception as e:
            logger.debug(f"Switchport trunk check failed: {str(e)}")
            
        return False

    def _parse_trunk_raw_output(self, output: str, vlan_id: str) -> bool:
        """Parse raw switchport output"""
        output_lower = output.lower()
        
        if "trunking" in output_lower:
            if "vlans allowed: all" in output_lower:
                return True
            if f"vlans allowed: {vlan_id}" in output_lower:
                return True
        
        return False

    def _check_allowed_vlans(self, switchport_data: Dict, vlan_id: str) -> bool:
        """Check if VLAN is in allowed VLAN list"""
        for field in ['trunking_vlans', 'vlans_allowed', 'allowed_vlans']:
            vlans = switchport_data.get(field, '')
            
            if vlans:
                if vlans.upper() == 'ALL':
                    return True
                if self._is_vlan_in_list(vlans, vlan_id):
                    return True
        
        return False

    def _check_trunk_config(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check trunk configuration in running config"""
        try:
            command = f"show running-config interface {interface}"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                enable=True
            )
            
            config = result.result.lower()
            
            # If trunk mode is configured but no allowed VLAN restrictions, assume all VLANs allowed
            if "switchport mode trunk" in config and "switchport trunk allowed vlan" not in config:
                return True
            
            # Check specific VLAN allowances
            if f"switchport trunk allowed vlan add {vlan_id}" in config:
                return True
            
            return False
            
        except Exception as e:
            logger.debug(f"Trunk config check failed: {str(e)}")
            
        return False

    def _is_vlan_in_list(self, vlan_str: str, target_vlan: str) -> bool:
        """Helper to safely parse VLAN lists (1,5,10-20,30)"""
        try:
            if not vlan_str:
                return False
                
            target_int = int(target_vlan)
            
            for part in str(vlan_str).split(','):
                part = part.strip()
                
                if '-' in part:
                    # Handle range (e.g., "10-20")
                    start, end = map(int, part.split('-'))
                    if start <= target_int <= end:
                        return True
                elif part.isdigit() and int(part) == target_int:
                    return True
                    
            return False
            
        except (ValueError, AttributeError) as e:
            logger.error(f"VLAN list parsing failed: {str(e)}")
            return False

    def trace_path_to_router(self, start_device: str) -> List[str]:
        """Trace path from edge switch to router using LLDP with improved logic"""
        logger.info("Starting path trace to router...")
        
        path = []
        current_device = start_device
        visited: Set[str] = set()
        
        # Get target router
        try:
            target_router = self.nr.inventory.hosts[start_device].data.get('router')
            if not target_router:
                logger.error(f"No router defined for {start_device}")
                return []
        except KeyError:
            logger.error(f"Device {start_device} not found in inventory")
            return []

        logger.info(f"Target router: {target_router}")

        while current_device and current_device not in visited and len(path) < self.max_hops:
            visited.add(current_device)
            path.append(current_device)
            
            logger.debug(f"Current device: {current_device}")
            logger.debug(f"Current path: {' -> '.join(path)}")
            
            # Check if we've reached the target router
            if current_device == target_router:
                logger.info(f"Reached target router: {current_device}")
                break
            
            # Get neighbors and find next hop
            next_hop = self._find_next_hop(current_device, target_router, visited)
            if not next_hop:
                logger.warning(f"No valid next hop found from {current_device}")
                break
                
            current_device = next_hop

        # Ensure router is in path
        if path and path[-1] != target_router:
            path.append(target_router)
            logger.debug(f"Added router {target_router} to path")

        logger.info(f"Final path: {' -> '.join(path)}")
        return path

    def _find_next_hop(self, current_device: str, target_router: str, visited: Set[str]) -> Optional[str]:
        """Find the next hop in the path"""
        try:
            neighbors_result = self.nr.filter(name=current_device).run(task=self.get_lldp_neighbors)
            neighbors = neighbors_result[current_device].result
            
            if not neighbors:
                logger.debug(f"No neighbors found for {current_device}")
                return None
            
            # Find unvisited neighbors
            possible_hops = []
            for neighbor in (neighbors if isinstance(neighbors, list) else [neighbors]):
                if isinstance(neighbor, dict):
                    neighbor_ip = self._extract_neighbor_ip(neighbor)
                    
                    if neighbor_ip and neighbor_ip not in visited:
                        # Try to resolve to inventory hostname
                        resolved_ip = self._resolve_neighbor_ip(neighbor_ip)
                        if resolved_ip:
                            possible_hops.append(resolved_ip)
            
            if not possible_hops:
                return None
            
            # Prioritize direct connection to router
            if target_router in possible_hops:
                return target_router
            
            # Prioritize devices that have the target router configured
            for hop in possible_hops:
                try:
                    if self.nr.inventory.hosts[hop].data.get('router') == target_router:
                        return hop
                except KeyError:
                    continue
            
            # Return first available hop
            return possible_hops[0]
            
        except Exception as e:
            logger.error(f"Error finding next hop from {current_device}: {str(e)}")
            return None

    def _extract_neighbor_ip(self, neighbor: Dict) -> Optional[str]:
        """Extract neighbor IP from LLDP data"""
        neighbor_ip = (neighbor.get('mgmt_address') or 
                      neighbor.get('neighbor') or 
                      neighbor.get('neighbor_name') or
                      neighbor.get('system_name'))
        
        if neighbor_ip and '.' not in neighbor_ip:
            # Handle hostname format
            neighbor_ip = neighbor_ip.split('.')[0]
        
        return neighbor_ip

    def _resolve_neighbor_ip(self, neighbor_ip: str) -> Optional[str]:
        """Resolve neighbor IP to inventory hostname"""
        # Direct match
        if neighbor_ip in self.nr.inventory.hosts:
            return neighbor_ip
        
        # Hostname match
        for hostname, host in self.nr.inventory.hosts.items():
            if (host.get('hostname', '') == neighbor_ip or 
                hostname.startswith(neighbor_ip)):
                return hostname
        
        return None

    def verify_vlan_path(self, initial_switch: str, target_port: str, vlan_id: str) -> Tuple[bool, str, List[str], Dict[str, DeviceResult]]:
        """Comprehensive VLAN path verification"""
        logger.info("Starting VLAN path verification")
        
        # Trace path
        path = self.trace_path_to_router(initial_switch)
        if not path:
            return False, "No path found to router", [], {}

        # Verify each device in path
        results = {}
        overall_success = True
        failure_reasons = []
        
        for i, device_ip in enumerate(path):
            logger.info(f"Verifying device {i+1}/{len(path)}: {device_ip}")
            
            result = DeviceResult(device_ip=device_ip, vlan_status="Unknown")
            
            # Check VLAN exists
            vlan_exists = self.nr.filter(name=device_ip).run(
                task=self.verify_vlan_exists,
                vlan_id=vlan_id
            )[device_ip].result
            
            if vlan_exists:
                result.vlan_status = "VLAN exists"
                logger.debug(f"VLAN {vlan_id} exists on {device_ip}")
            else:
                result.vlan_status = "VLAN missing"
                result.overall_status = VerificationStatus.FAIL
                overall_success = False
                failure_reasons.append(f"VLAN {vlan_id} missing on {device_ip}")
                logger.warning(f"VLAN {vlan_id} missing on {device_ip}")
            
            # First device: check access port
            if i == 0:
                access_ok = self.nr.filter(name=device_ip).run(
                    task=self.verify_access_vlan,
                    interface=target_port,
                    vlan_id=vlan_id
                )[device_ip].result
                
                if access_ok:
                    result.port_status = "Access port configured"
                    logger.debug(f"Access port {target_port} configured on {device_ip}")
                else:
                    result.port_status = f"Port {target_port} not in VLAN {vlan_id}"
                    result.overall_status = VerificationStatus.FAIL
                    overall_success = False
                    failure_reasons.append(f"Port {target_port} not in VLAN {vlan_id}")
                    logger.warning(f"Port {target_port} not in VLAN {vlan_id}")
            
            # Intermediate devices: check trunk ports
            elif i < len(path) - 1:
                next_device = path[i + 1]
                uplink_port = self.nr.filter(name=device_ip).run(
                    task=self.find_uplink_port,
                    neighbor_ip=next_device
                )[device_ip].result
                
                if uplink_port:
                    trunk_ok = self.nr.filter(name=device_ip).run(
                        task=self.verify_trunk_vlan,
                        interface=uplink_port,
                        vlan_id=vlan_id
                    )[device_ip].result
                    
                    if trunk_ok:
                        result.trunk_status = f"Trunk {uplink_port} allows VLAN"
                        logger.debug(f"Trunk {uplink_port} allows VLAN {vlan_id}")
                    else:
                        result.trunk_status = f"VLAN {vlan_id} blocked on {uplink_port}"
                        result.overall_status = VerificationStatus.FAIL
                        overall_success = False
                        failure_reasons.append(f"VLAN {vlan_id} blocked on {uplink_port}")
                        logger.warning(f"VLAN {vlan_id} blocked on {uplink_port}")
                else:
                    result.trunk_status = f"No uplink found to {next_device}"
                    result.overall_status = VerificationStatus.FAIL
                    overall_success = False
                    failure_reasons.append(f"No uplink found to {next_device}")
                    logger.warning(f"No uplink found to {next_device}")
            
            # Router endpoint
            else:
                result.role = "Router endpoint"
                logger.debug(f"Router endpoint: {device_ip}")
            
            # Set overall status if not already failed
            if result.overall_status == VerificationStatus.UNKNOWN:
                result.overall_status = VerificationStatus.PASS
            
            results[device_ip] = result

        # Generate summary message
        if overall_success:
            message = f"VLAN {vlan_id} path fully verified"
        else:
            message = f"VLAN path verification failed: {'; '.join(failure_reasons[:3])}"
        
        logger.info(f"Verification complete: {message}")
        return overall_success, message, path, results

    def visualize_path(self, path: List[str], verification_results: Dict[str, DeviceResult]):
        """Create enhanced visualization of the network path"""
        plt.ioff()
        fig, ax = plt.subplots(figsize=(18, 12))
        
        # Create graph
        G = nx.path_graph(path)
        
        # Position nodes
        pos = {node: (i * 3, 0) for i, node in enumerate(G.nodes())}
        
        # Prepare node colors and labels
        node_colors = []
        node_labels = {}
        status_labels = {}
        
        for node in G.nodes():
            result = verification_results.get(node)
            if not result:
                node_colors.append("gray")
                status_labels[node] = "No data"
                continue
            
            # Determine color based on status
            if result.overall_status == VerificationStatus.PASS:
                node_colors.append("lightgreen")
                status = "✓ PASS"
            elif result.overall_status == VerificationStatus.FAIL:
                node_colors.append("red")
                status = "✗ FAIL"
            else:
                node_colors.append("gray")
                status = "? UNKNOWN"
            
            # Create node label
            node_labels[node] = node
            
            # Create status label
            status_lines = [f"Status: {status}"]
            
            if result.vlan_status:
                status_lines.append(f"VLAN: {result.vlan_status}")
            
            if result.port_status:
                status_lines.append(f"Port: {result.port_status}")
            
            if result.trunk_status:
                status_lines.append(f"Trunk: {result.trunk_status}")
            
            if result.role:
                status_lines.append(f"Role: {result.role}")
            
            status_labels[node] = "\n".join(status_lines[:4])  # Limit to 4 lines
        
        # Draw network graph
        nx.draw_networkx_nodes(G, pos, node_color=node_colors, node_size=5000, 
                              edgecolors='black', linewidths=2)
        nx.draw_networkx_edges(G, pos, width=3, edge_color='steelblue', 
                              arrows=True, arrowstyle='-|>', arrowsize=30)
        
        # Add device labels (above nodes)
        name_pos = {k: (v[0], v[1] + 0.8) for k, v in pos.items()}
        nx.draw_networkx_labels(G, name_pos, labels=node_labels, font_size=10, 
                               font_weight="bold")
        
        # Add status labels (below nodes)
        status_pos = {k: (v[0], v[1] - 1.2) for k, v in pos.items()}
        nx.draw_networkx_labels(G, status_pos, labels=status_labels, font_size=8,
                               bbox=dict(facecolor='white', edgecolor='black',
                                       boxstyle='round,pad=0.5', alpha=0.9))
        
        # Add legend
        legend_elements = [
            plt.Line2D([0], [0], marker='o', color='w', label='Pass', 
                      markerfacecolor='lightgreen', markersize=15),
            plt.Line2D([0], [0], marker='o', color='w', label='Fail', 
                      markerfacecolor='red', markersize=15),
            plt.Line2D([0], [0], marker='o', color='w', label='Unknown', 
                      markerfacecolor='gray', markersize=15)
        ]
        
        plt.legend(handles=legend_elements, loc='upper right', fontsize=12, 
                  title="Verification Status", title_fontsize=14)
        
        plt.title("Network VLAN Path Verification Results", pad=40, fontsize=18, 
                 fontweight='bold')
        plt.axis('off')
        plt.tight_layout()
        plt.show(block=True)
        plt.ion()


def main():
    """Main function to run VLAN path verification"""
    # Configuration
    initial_switch = "172.17.57.243"
    target_port = "GigabitEthernet1/0/10"
    vlan_id = "5"
    
    # Create verifier instance
    verifier = NetworkVerifier(config_file="config.yaml")
    
    try:
        # Run verification
        success, message, path, results = verifier.verify_vlan_path(
            initial_switch, target_port, vlan_id
        )
        
        # Print results
        print("\n" + "="*60)
        print(f"VLAN PATH VERIFICATION {'SUCCEEDED' if success else 'FAILED'}")
        print("="*60)
        print(f"Initial Switch: {initial_switch}")
        print(f"Target Port: {target_port}")
        print(f"VLAN ID: {vlan_id}")
        print(f"Path: {' → '.join(path)}")
        print(f"Status: {message}")
        print("="*60)
        
        # Detailed results
        print("\nDETAILED RESULTS:")
        print("-" * 40)
        for device_ip, result in results.items():
            print(f"\nDevice: {device_ip}")
            print(f"  Overall Status: {result.overall_status.value.upper()}")
            print(f"  VLAN Status: {result.vlan_status}")
            if result.port_status:
                print(f"  Port Status: {result.port_status}")
            if result.trunk_status:
                print(f"  Trunk Status: {result.trunk_status}")
            if result.role:
                print(f"  Role: {result.role}")
        
        # Show visualization
        if path and results:
            print("\nGenerating network visualization...")
            verifier.visualize_path(path, results)
        
        return success
        
    except Exception as e:
        logger.error(f"Verification failed with error: {str(e)}")
        print(f"\nERROR: Verification failed - {str(e)}")
        return False
    
    finally:
        # Cleanup
        if hasattr(verifier, 'nr') and verifier.nr:
            verifier.nr.close_connections()


if __name__ == "__main__":
    import sys
    
    # Allow command line arguments
    if len(sys.argv) >= 4:
        initial_switch = sys.argv[1]
        target_port = sys.argv[2]
        vlan_id = sys.argv[3]
        
        verifier = NetworkVerifier()
        success, message, path, results = verifier.verify_vlan_path(
            initial_switch, target_port, vlan_id
        )
        
        if success:
            print(f"✓ VLAN {vlan_id} path verification successful")
            sys.exit(0)
        else:
            print(f"✗ VLAN {vlan_id} path verification failed: {message}")
            sys.exit(1)
    else:
        # Use default configuration
        success = main()
        sys.exit(0 if success else 1)7.242"
from nornir import InitNornir
from nornir_netmiko import netmiko_send_command
from nornir.core.task import Task, Result
from typing import Dict, List, Tuple, Optional, Set
import networkx as nx
import matplotlib.pyplot as plt
import re
import logging
from dataclasses import dataclass
from enum import Enum

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class VerificationStatus(Enum):
    PASS = "pass"
    FAIL = "fail"
    UNKNOWN = "unknown"

@dataclass
class DeviceResult:
    device_ip: str
    vlan_status: str
    port_status: Optional[str] = None
    trunk_status: Optional[str] = None
    role: Optional[str] = None
    overall_status: VerificationStatus = VerificationStatus.UNKNOWN

class NetworkVerifier:
    def __init__(self, config_file: str = "config.yaml"):
        self.nr = InitNornir(config_file=config_file)
        self.max_hops = 15
        
    def get_lldp_neighbors(self, task: Task) -> List[Dict]:
        """Collect LLDP neighbor information in a vendor-neutral way"""
        platform = task.host.platform
        
        # Enhanced command mapping for different platforms
        command_map = {
            "aruba_cx": "show lldp neighbors detail",
            "cisco_ios": "show lldp neighbors detail",
            "cisco_xe": "show lldp neighbors detail",
            "hp_comware": "display lldp neighbor-information",
            "juniper": "show lldp neighbors detail"
        }
        
        command = command_map.get(platform, "show lldp neighbors detail")
        
        logger.debug(f"Running on {task.host}: {command}")
        
        try:
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            # Handle different result types
            if isinstance(result.result, str):
                logger.warning(f"TextFSM parsing failed for {task.host}, attempting manual parsing")
                return self._parse_lldp_manually(result.result, platform)
            elif isinstance(result.result, dict):
                return [result.result]
            elif isinstance(result.result, list):
                return result.result
            else:
                logger.warning(f"No LLDP neighbors found on {task.host}")
                return []
                
        except Exception as e:
            logger.error(f"Error getting LLDP neighbors on {task.host}: {str(e)}")
            return []

    def _parse_lldp_manually(self, output: str, platform: str) -> List[Dict]:
        """Manual parsing fallback for when TextFSM fails"""
        neighbors = []
        
        try:
            # Basic regex patterns for common LLDP output formats
            if platform == "cisco_ios":
                # Cisco IOS LLDP format
                pattern = r'Device ID: (\S+).*?Local Intf: (\S+).*?Port id: (\S+)'
                matches = re.findall(pattern, output, re.DOTALL)
                
                for match in matches:
                    neighbors.append({
                        'neighbor': match[0],
                        'local_interface': match[1],
                        'neighbor_port': match[2]
                    })
            
            # Add more platform-specific parsing as needed
            
        except Exception as e:
            logger.error(f"Manual LLDP parsing failed: {str(e)}")
            
        return neighbors

    def find_uplink_port(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find the local interface connected to a neighbor with improved error handling"""
        platform = task.host.platform
        
        try:
            # Try LLDP first (most reliable)
            lldp_result = self._find_port_via_lldp(task, neighbor_ip, platform)
            if lldp_result:
                return lldp_result
            
            # Fall back to CDP for Cisco devices
            if platform.startswith("cisco"):
                cdp_result = self._find_port_via_cdp(task, neighbor_ip)
                if cdp_result:
                    return cdp_result
                    
            # Last resort: MAC address table lookup
            mac_result = self._find_port_via_mac(task, neighbor_ip)
            if mac_result:
                return mac_result
                
        except Exception as e:
            logger.error(f"Error finding uplink port on {task.host}: {str(e)}")
        
        return None

    def _find_port_via_lldp(self, task: Task, neighbor_ip: str, platform: str) -> Optional[str]:
        """Find port using LLDP"""
        try:
            neighbors = self.get_lldp_neighbors(task)
            
            for neighbor in neighbors:
                # Check multiple possible neighbor identifier fields
                neighbor_id = (neighbor.get('neighbor') or 
                             neighbor.get('mgmt_address') or 
                             neighbor.get('system_name'))
                
                if neighbor_id and (neighbor_id == neighbor_ip or 
                                  neighbor_id.startswith(neighbor_ip.split('.')[0])):
                    return neighbor.get('local_interface')
                    
        except Exception as e:
            logger.debug(f"LLDP port lookup failed: {str(e)}")
            
        return None

    def _find_port_via_cdp(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find port using CDP (Cisco devices)"""
        try:
            command = "show cdp neighbors detail"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if result.result:
                for neighbor in (result.result if isinstance(result.result, list) else [result.result]):
                    if neighbor.get('mgmt_address') == neighbor_ip:
                        return neighbor.get('local_port')
                        
        except Exception as e:
            logger.debug(f"CDP port lookup failed: {str(e)}")
            
        return None

    def _find_port_via_mac(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find port using MAC address table (least reliable)"""
        try:
            # This would require ARP table lookup first, then MAC table
            # Implementation depends on specific requirements
            pass
        except Exception as e:
            logger.debug(f"MAC table port lookup failed: {str(e)}")
            
        return None

    def verify_vlan_exists(self, task: Task, vlan_id: str) -> bool:
        """Check if VLAN exists with enhanced platform support"""
        platform = task.host.platform
        
        command_map = {
            "aruba_cx": f"show vlan {vlan_id}",
            "cisco_ios": f"show vlan id {vlan_id}",
            "cisco_xe": f"show vlan id {vlan_id}",
            "hp_comware": f"display vlan {vlan_id}",
            "juniper": f"show vlans {vlan_id}"
        }
        
        command = command_map.get(platform, f"show vlan id {vlan_id}")
        
        try:
            logger.debug(f"Running on {task.host}: {command}")
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if isinstance(result.result, str):
                # Check for common error messages
                error_indicators = ["invalid", "not found", "does not exist", "error"]
                return not any(indicator in result.result.lower() for indicator in error_indicators)
            
            return bool(result.result)
            
        except Exception as e:
            logger.error(f"Error checking VLAN on {task.host}: {str(e)}")
            return False

    def verify_access_vlan(self, task: Task, interface: str, vlan_id: str) -> bool:
        """Verify access port VLAN configuration with better error handling"""
        platform = task.host.platform
        
        try:
            # Method 1: Check VLAN membership
            if self._check_vlan_membership(task, interface, vlan_id, platform):
                return True
            
            # Method 2: Check interface configuration
            if self._check_interface_config(task, interface, vlan_id, platform):
                return True
            
            logger.debug(f"Access VLAN {vlan_id} not found on {interface}")
            return False
            
        except Exception as e:
            logger.error(f"Error checking access port on {task.host}: {str(e)}")
            return False

    def _check_vlan_membership(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check VLAN membership tables"""
        try:
            command_map = {
                "aruba_cx": f"show vlan {vlan_id}",
                "cisco_ios": f"show vlan id {vlan_id}",
                "cisco_xe": f"show vlan id {vlan_id}",
            }
            
            command = command_map.get(platform, f"show vlan id {vlan_id}")
            
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if result.result:
                for vlan in (result.result if isinstance(result.result, list) else [result.result]):
                    interfaces = vlan.get('interfaces', [])
                    if isinstance(interfaces, str):
                        interfaces = [interfaces]
                    
                    # Normalize interface names for comparison
                    normalized_interfaces = [self._normalize_interface_name(intf) for intf in interfaces]
                    normalized_target = self._normalize_interface_name(interface)
                    
                    if normalized_target in normalized_interfaces:
                        return True
                        
        except Exception as e:
            logger.debug(f"VLAN membership check failed: {str(e)}")
            
        return False

    def _check_interface_config(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check interface running configuration"""
        try:
            command = f"show running-config interface {interface}"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=False,
                enable=True
            )
            
            config = result.result.lower()
            
            # Platform-specific config patterns
            patterns = {
                "aruba_cx": [f"vlan access {vlan_id}"],
                "cisco_ios": [f"switchport access vlan {vlan_id}"],
                "cisco_xe": [f"switchport access vlan {vlan_id}"],
            }
            
            check_patterns = patterns.get(platform, [f"switchport access vlan {vlan_id}"])
            
            return any(pattern in config for pattern in check_patterns)
            
        except Exception as e:
            logger.debug(f"Interface config check failed: {str(e)}")
            
        return False

    def _normalize_interface_name(self, interface: str) -> str:
        """Normalize interface names for comparison"""
        # Handle common abbreviations
        interface = interface.replace("GigabitEthernet", "Gi")
        interface = interface.replace("FastEthernet", "Fa")
        interface = interface.replace("TenGigabitEthernet", "Te")
        
        # Remove spaces and convert to lowercase
        return interface.replace(" ", "").lower()

    def verify_trunk_vlan(self, task: Task, interface: str, vlan_id: str) -> bool:
        """Verify trunk allows the VLAN with comprehensive checking"""
        platform = task.host.platform
        
        try:
            # Method 1: Check switchport status
            if self._check_switchport_trunk(task, interface, vlan_id, platform):
                return True
            
            # Method 2: Check running configuration
            if self._check_trunk_config(task, interface, vlan_id, platform):
                return True
            
            return False
            
        except Exception as e:
            logger.error(f"Error checking trunk on {task.host}: {str(e)}")
            return False

    def _check_switchport_trunk(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check switchport trunk status"""
        try:
            command = f"show interfaces {interface} switchport"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if isinstance(result.result, str):
                # Parse raw output
                return self._parse_trunk_raw_output(result.result, vlan_id)
            
            if result.result and isinstance(result.result, list):
                sw_data = result.result[0]
                
                # Check if port is in trunk mode
                if sw_data.get('mode', '').lower() != 'trunk':
                    return False
                
                # Check allowed VLANs
                return self._check_allowed_vlans(sw_data, vlan_id)
                
        except Exception as e:
            logger.debug(f"Switchport trunk check failed: {str(e)}")
            
        return False

    def _parse_trunk_raw_output(self, output: str, vlan_id: str) -> bool:
        """Parse raw switchport output"""
        output_lower = output.lower()
        
        if "trunking" in output_lower:
            if "vlans allowed: all" in output_lower:
                return True
            if f"vlans allowed: {vlan_id}" in output_lower:
                return True
        
        return False

    def _check_allowed_vlans(self, switchport_data: Dict, vlan_id: str) -> bool:
        """Check if VLAN is in allowed VLAN list"""
        for field in ['trunking_vlans', 'vlans_allowed', 'allowed_vlans']:
            vlans = switchport_data.get(field, '')
            
            if vlans:
                if vlans.upper() == 'ALL':
                    return True
                if self._is_vlan_in_list(vlans, vlan_id):
                    return True
        
        return False

    def _check_trunk_config(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check trunk configuration in running config"""
        try:
            command = f"show running-config interface {interface}"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                enable=True
            )
            
            config = result.result.lower()
            
            # If trunk mode is configured but no allowed VLAN restrictions, assume all VLANs allowed
            if "switchport mode trunk" in config and "switchport trunk allowed vlan" not in config:
                return True
            
            # Check specific VLAN allowances
            if f"switchport trunk allowed vlan add {vlan_id}" in config:
                return True
            
            return False
            
        except Exception as e:
            logger.debug(f"Trunk config check failed: {str(e)}")
            
        return False

    def _is_vlan_in_list(self, vlan_str: str, target_vlan: str) -> bool:
        """Helper to safely parse VLAN lists (1,5,10-20,30)"""
        try:
            if not vlan_str:
                return False
                
            target_int = int(target_vlan)
            
            for part in str(vlan_str).split(','):
                part = part.strip()
                
                if '-' in part:
                    # Handle range (e.g., "10-20")
                    start, end = map(int, part.split('-'))
                    if start <= target_int <= end:
                        return True
                elif part.isdigit() and int(part) == target_int:
                    return True
                    
            return False
            
        except (ValueError, AttributeError) as e:
            logger.error(f"VLAN list parsing failed: {str(e)}")
            return False

    def trace_path_to_router(self, start_device: str) -> List[str]:
        """Trace path from edge switch to router using LLDP with improved logic"""
        logger.info("Starting path trace to router...")
        
        path = []
        current_device = start_device
        visited: Set[str] = set()
        
        # Get target router
        try:
            target_router = self.nr.inventory.hosts[start_device].data.get('router')
            if not target_router:
                logger.error(f"No router defined for {start_device}")
                return []
        except KeyError:
            logger.error(f"Device {start_device} not found in inventory")
            return []

        logger.info(f"Target router: {target_router}")

        while current_device and current_device not in visited and len(path) < self.max_hops:
            visited.add(current_device)
            path.append(current_device)
            
            logger.debug(f"Current device: {current_device}")
            logger.debug(f"Current path: {' -> '.join(path)}")
            
            # Check if we've reached the target router
            if current_device == target_router:
                logger.info(f"Reached target router: {current_device}")
                break
            
            # Get neighbors and find next hop
            next_hop = self._find_next_hop(current_device, target_router, visited)
            if not next_hop:
                logger.warning(f"No valid next hop found from {current_device}")
                break
                
            current_device = next_hop

        # Ensure router is in path
        if path and path[-1] != target_router:
            path.append(target_router)
            logger.debug(f"Added router {target_router} to path")

        logger.info(f"Final path: {' -> '.join(path)}")
        return path

    def _find_next_hop(self, current_device: str, target_router: str, visited: Set[str]) -> Optional[str]:
        """Find the next hop in the path"""
        try:
            neighbors_result = self.nr.filter(name=current_device).run(task=self.get_lldp_neighbors)
            neighbors = neighbors_result[current_device].result
            
            if not neighbors:
                logger.debug(f"No neighbors found for {current_device}")
                return None
            
            # Find unvisited neighbors
            possible_hops = []
            for neighbor in (neighbors if isinstance(neighbors, list) else [neighbors]):
                if isinstance(neighbor, dict):
                    neighbor_ip = self._extract_neighbor_ip(neighbor)
                    
                    if neighbor_ip and neighbor_ip not in visited:
                        # Try to resolve to inventory hostname
                        resolved_ip = self._resolve_neighbor_ip(neighbor_ip)
                        if resolved_ip:
                            possible_hops.append(resolved_ip)
            
            if not possible_hops:
                return None
            
            # Prioritize direct connection to router
            if target_router in possible_hops:
                return target_router
            
            # Prioritize devices that have the target router configured
            for hop in possible_hops:
                try:
                    if self.nr.inventory.hosts[hop].data.get('router') == target_router:
                        return hop
                except KeyError:
                    continue
            
            # Return first available hop
            return possible_hops[0]
            
        except Exception as e:
            logger.error(f"Error finding next hop from {current_device}: {str(e)}")
            return None

    def _extract_neighbor_ip(self, neighbor: Dict) -> Optional[str]:
        """Extract neighbor IP from LLDP data"""
        neighbor_ip = (neighbor.get('mgmt_address') or 
                      neighbor.get('neighbor') or 
                      neighbor.get('neighbor_name') or
                      neighbor.get('system_name'))
        
        if neighbor_ip and '.' not in neighbor_ip:
            # Handle hostname format
            neighbor_ip = neighbor_ip.split('.')[0]
        
        return neighbor_ip

    def _resolve_neighbor_ip(self, neighbor_ip: str) -> Optional[str]:
        """Resolve neighbor IP to inventory hostname"""
        # Direct match
        if neighbor_ip in self.nr.inventory.hosts:
            return neighbor_ip
        
        # Hostname match
        for hostname, host in self.nr.inventory.hosts.items():
            if (host.get('hostname', '') == neighbor_ip or 
                hostname.startswith(neighbor_ip)):
                return hostname
        
        return None

    def verify_vlan_path(self, initial_switch: str, target_port: str, vlan_id: str) -> Tuple[bool, str, List[str], Dict[str, DeviceResult]]:
        """Comprehensive VLAN path verification"""
        logger.info("Starting VLAN path verification")
        
        # Trace path
        path = self.trace_path_to_router(initial_switch)
        if not path:
            return False, "No path found to router", [], {}

        # Verify each device in path
        results = {}
        overall_success = True
        failure_reasons = []
        
        for i, device_ip in enumerate(path):
            logger.info(f"Verifying device {i+1}/{len(path)}: {device_ip}")
            
            result = DeviceResult(device_ip=device_ip, vlan_status="Unknown")
            
            # Check VLAN exists
            vlan_exists = self.nr.filter(name=device_ip).run(
                task=self.verify_vlan_exists,
                vlan_id=vlan_id
            )[device_ip].result
            
            if vlan_exists:
                result.vlan_status = "VLAN exists"
                logger.debug(f"VLAN {vlan_id} exists on {device_ip}")
            else:
                result.vlan_status = "VLAN missing"
                result.overall_status = VerificationStatus.FAIL
                overall_success = False
                failure_reasons.append(f"VLAN {vlan_id} missing on {device_ip}")
                logger.warning(f"VLAN {vlan_id} missing on {device_ip}")
            
            # First device: check access port
            if i == 0:
                access_ok = self.nr.filter(name=device_ip).run(
                    task=self.verify_access_vlan,
                    interface=target_port,
                    vlan_id=vlan_id
                )[device_ip].result
                
                if access_ok:
                    result.port_status = "Access port configured"
                    logger.debug(f"Access port {target_port} configured on {device_ip}")
                else:
                    result.port_status = f"Port {target_port} not in VLAN {vlan_id}"
                    result.overall_status = VerificationStatus.FAIL
                    overall_success = False
                    failure_reasons.append(f"Port {target_port} not in VLAN {vlan_id}")
                    logger.warning(f"Port {target_port} not in VLAN {vlan_id}")
            
            # Intermediate devices: check trunk ports
            elif i < len(path) - 1:
                next_device = path[i + 1]
                uplink_port = self.nr.filter(name=device_ip).run(
                    task=self.find_uplink_port,
                    neighbor_ip=next_device
                )[device_ip].result
                
                if uplink_port:
                    trunk_ok = self.nr.filter(name=device_ip).run(
                        task=self.verify_trunk_vlan,
                        interface=uplink_port,
                        vlan_id=vlan_id
                    )[device_ip].result
                    
                    if trunk_ok:
                        result.trunk_status = f"Trunk {uplink_port} allows VLAN"
                        logger.debug(f"Trunk {uplink_port} allows VLAN {vlan_id}")
                    else:
                        result.trunk_status = f"VLAN {vlan_id} blocked on {uplink_port}"
                        result.overall_status = VerificationStatus.FAIL
                        overall_success = False
                        failure_reasons.append(f"VLAN {vlan_id} blocked on {uplink_port}")
                        logger.warning(f"VLAN {vlan_id} blocked on {uplink_port}")
                else:
                    result.trunk_status = f"No uplink found to {next_device}"
                    result.overall_status = VerificationStatus.FAIL
                    overall_success = False
                    failure_reasons.append(f"No uplink found to {next_device}")
                    logger.warning(f"No uplink found to {next_device}")
            
            # Router endpoint
            else:
                result.role = "Router endpoint"
                logger.debug(f"Router endpoint: {device_ip}")
            
            # Set overall status if not already failed
            if result.overall_status == VerificationStatus.UNKNOWN:
                result.overall_status = VerificationStatus.PASS
            
            results[device_ip] = result

        # Generate summary message
        if overall_success:
            message = f"VLAN {vlan_id} path fully verified"
        else:
            message = f"VLAN path verification failed: {'; '.join(failure_reasons[:3])}"
        
        logger.info(f"Verification complete: {message}")
        return overall_success, message, path, results

    def visualize_path(self, path: List[str], verification_results: Dict[str, DeviceResult]):
        """Create enhanced visualization of the network path"""
        plt.ioff()
        fig, ax = plt.subplots(figsize=(18, 12))
        
        # Create graph
        G = nx.path_graph(path)
        
        # Position nodes
        pos = {node: (i * 3, 0) for i, node in enumerate(G.nodes())}
        
        # Prepare node colors and labels
        node_colors = []
        node_labels = {}
        status_labels = {}
        
        for node in G.nodes():
            result = verification_results.get(node)
            if not result:
                node_colors.append("gray")
                status_labels[node] = "No data"
                continue
            
            # Determine color based on status
            if result.overall_status == VerificationStatus.PASS:
                node_colors.append("lightgreen")
                status = "✓ PASS"
            elif result.overall_status == VerificationStatus.FAIL:
                node_colors.append("red")
                status = "✗ FAIL"
            else:
                node_colors.append("gray")
                status = "? UNKNOWN"
            
            # Create node label
            node_labels[node] = node
            
            # Create status label
            status_lines = [f"Status: {status}"]
            
            if result.vlan_status:
                status_lines.append(f"VLAN: {result.vlan_status}")
            
            if result.port_status:
                status_lines.append(f"Port: {result.port_status}")
            
            if result.trunk_status:
                status_lines.append(f"Trunk: {result.trunk_status}")
            
            if result.role:
                status_lines.append(f"Role: {result.role}")
            
            status_labels[node] = "\n".join(status_lines[:4])  # Limit to 4 lines
        
        # Draw network graph
        nx.draw_networkx_nodes(G, pos, node_color=node_colors, node_size=5000, 
                              edgecolors='black', linewidths=2)
        nx.draw_networkx_edges(G, pos, width=3, edge_color='steelblue', 
                              arrows=True, arrowstyle='-|>', arrowsize=30)
        
        # Add device labels (above nodes)
        name_pos = {k: (v[0], v[1] + 0.8) for k, v in pos.items()}
        nx.draw_networkx_labels(G, name_pos, labels=node_labels, font_size=10, 
                               font_weight="bold")
        
        # Add status labels (below nodes)
        status_pos = {k: (v[0], v[1] - 1.2) for k, v in pos.items()}
        nx.draw_networkx_labels(G, status_pos, labels=status_labels, font_size=8,
                               bbox=dict(facecolor='white', edgecolor='black',
                                       boxstyle='round,pad=0.5', alpha=0.9))
        
        # Add legend
        legend_elements = [
            plt.Line2D([0], [0], marker='o', color='w', label='Pass', 
                      markerfacecolor='lightgreen', markersize=15),
            plt.Line2D([0], [0], marker='o', color='w', label='Fail', 
                      markerfacecolor='red', markersize=15),
            plt.Line2D([0], [0], marker='o', color='w', label='Unknown', 
                      markerfacecolor='gray', markersize=15)
        ]
        
        plt.legend(handles=legend_elements, loc='upper right', fontsize=12, 
                  title="Verification Status", title_fontsize=14)
        
        plt.title("Network VLAN Path Verification Results", pad=40, fontsize=18, 
                 fontweight='bold')
        plt.axis('off')
        plt.tight_layout()
        plt.show(block=True)
        plt.ion()


def main():
    """Main function to run VLAN path verification"""
    # Configuration
    initial_switch = "172.17.57.243"
    target_port = "GigabitEthernet1/0/10"
    vlan_id = "5"
    
    # Create verifier instance
    verifier = NetworkVerifier(config_file="config.yaml")
    
    try:
        # Run verification
        success, message, path, results = verifier.verify_vlan_path(
            initial_switch, target_port, vlan_id
        )
        
        # Print results
        print("\n" + "="*60)
        print(f"VLAN PATH VERIFICATION {'SUCCEEDED' if success else 'FAILED'}")
        print("="*60)
        print(f"Initial Switch: {initial_switch}")
        print(f"Target Port: {target_port}")
        print(f"VLAN ID: {vlan_id}")
        print(f"Path: {' → '.join(path)}")
        print(f"Status: {message}")
        print("="*60)
        
        # Detailed results
        print("\nDETAILED RESULTS:")
        print("-" * 40)
        for device_ip, result in results.items():
            print(f"\nDevice: {device_ip}")
            print(f"  Overall Status: {result.overall_status.value.upper()}")
            print(f"  VLAN Status: {result.vlan_status}")
            if result.port_status:
                print(f"  Port Status: {result.port_status}")
            if result.trunk_status:
                print(f"  Trunk Status: {result.trunk_status}")
            if result.role:
                print(f"  Role: {result.role}")
        
        # Show visualization
        if path and results:
            print("\nGenerating network visualization...")
            verifier.visualize_path(path, results)
        
        return success
        
    except Exception as e:
        logger.error(f"Verification failed with error: {str(e)}")
        print(f"\nERROR: Verification failed - {str(e)}")
        return False
    
    finally:
        # Cleanup
        if hasattr(verifier, 'nr') and verifier.nr:
            verifier.nr.close_connections()


if __name__ == "__main__":
    import sys
    
    # Allow command line arguments
    if len(sys.argv) >= 4:
        initial_switch = sys.argv[1]
        target_port = sys.argv[2]
        vlan_id = sys.argv[3]
        
        verifier = NetworkVerifier()
        success, message, path, results = verifier.verify_vlan_path(
            initial_switch, target_port, vlan_id
        )
        
        if success:
            print(f"✓ VLAN {vlan_id} path verification successful")
            sys.exit(0)
        else:
            print(f"✗ VLAN {vlan_id} path verification failed: {message}")
            sys.exit(1)
    else:
        # Use default configuration
        success = main()
        sys.exit(0 if success else 1)bitEthernet1/0/10"
from nornir import InitNornir
from nornir_netmiko import netmiko_send_command
from nornir.core.task import Task, Result
from typing import Dict, List, Tuple, Optional, Set
import networkx as nx
import matplotlib.pyplot as plt
import re
import logging
from dataclasses import dataclass
from enum import Enum

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class VerificationStatus(Enum):
    PASS = "pass"
    FAIL = "fail"
    UNKNOWN = "unknown"

@dataclass
class DeviceResult:
    device_ip: str
    vlan_status: str
    port_status: Optional[str] = None
    trunk_status: Optional[str] = None
    role: Optional[str] = None
    overall_status: VerificationStatus = VerificationStatus.UNKNOWN

class NetworkVerifier:
    def __init__(self, config_file: str = "config.yaml"):
        self.nr = InitNornir(config_file=config_file)
        self.max_hops = 15
        
    def get_lldp_neighbors(self, task: Task) -> List[Dict]:
        """Collect LLDP neighbor information in a vendor-neutral way"""
        platform = task.host.platform
        
        # Enhanced command mapping for different platforms
        command_map = {
            "aruba_cx": "show lldp neighbors detail",
            "cisco_ios": "show lldp neighbors detail",
            "cisco_xe": "show lldp neighbors detail",
            "hp_comware": "display lldp neighbor-information",
            "juniper": "show lldp neighbors detail"
        }
        
        command = command_map.get(platform, "show lldp neighbors detail")
        
        logger.debug(f"Running on {task.host}: {command}")
        
        try:
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            # Handle different result types
            if isinstance(result.result, str):
                logger.warning(f"TextFSM parsing failed for {task.host}, attempting manual parsing")
                return self._parse_lldp_manually(result.result, platform)
            elif isinstance(result.result, dict):
                return [result.result]
            elif isinstance(result.result, list):
                return result.result
            else:
                logger.warning(f"No LLDP neighbors found on {task.host}")
                return []
                
        except Exception as e:
            logger.error(f"Error getting LLDP neighbors on {task.host}: {str(e)}")
            return []

    def _parse_lldp_manually(self, output: str, platform: str) -> List[Dict]:
        """Manual parsing fallback for when TextFSM fails"""
        neighbors = []
        
        try:
            # Basic regex patterns for common LLDP output formats
            if platform == "cisco_ios":
                # Cisco IOS LLDP format
                pattern = r'Device ID: (\S+).*?Local Intf: (\S+).*?Port id: (\S+)'
                matches = re.findall(pattern, output, re.DOTALL)
                
                for match in matches:
                    neighbors.append({
                        'neighbor': match[0],
                        'local_interface': match[1],
                        'neighbor_port': match[2]
                    })
            
            # Add more platform-specific parsing as needed
            
        except Exception as e:
            logger.error(f"Manual LLDP parsing failed: {str(e)}")
            
        return neighbors

    def find_uplink_port(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find the local interface connected to a neighbor with improved error handling"""
        platform = task.host.platform
        
        try:
            # Try LLDP first (most reliable)
            lldp_result = self._find_port_via_lldp(task, neighbor_ip, platform)
            if lldp_result:
                return lldp_result
            
            # Fall back to CDP for Cisco devices
            if platform.startswith("cisco"):
                cdp_result = self._find_port_via_cdp(task, neighbor_ip)
                if cdp_result:
                    return cdp_result
                    
            # Last resort: MAC address table lookup
            mac_result = self._find_port_via_mac(task, neighbor_ip)
            if mac_result:
                return mac_result
                
        except Exception as e:
            logger.error(f"Error finding uplink port on {task.host}: {str(e)}")
        
        return None

    def _find_port_via_lldp(self, task: Task, neighbor_ip: str, platform: str) -> Optional[str]:
        """Find port using LLDP"""
        try:
            neighbors = self.get_lldp_neighbors(task)
            
            for neighbor in neighbors:
                # Check multiple possible neighbor identifier fields
                neighbor_id = (neighbor.get('neighbor') or 
                             neighbor.get('mgmt_address') or 
                             neighbor.get('system_name'))
                
                if neighbor_id and (neighbor_id == neighbor_ip or 
                                  neighbor_id.startswith(neighbor_ip.split('.')[0])):
                    return neighbor.get('local_interface')
                    
        except Exception as e:
            logger.debug(f"LLDP port lookup failed: {str(e)}")
            
        return None

    def _find_port_via_cdp(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find port using CDP (Cisco devices)"""
        try:
            command = "show cdp neighbors detail"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if result.result:
                for neighbor in (result.result if isinstance(result.result, list) else [result.result]):
                    if neighbor.get('mgmt_address') == neighbor_ip:
                        return neighbor.get('local_port')
                        
        except Exception as e:
            logger.debug(f"CDP port lookup failed: {str(e)}")
            
        return None

    def _find_port_via_mac(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find port using MAC address table (least reliable)"""
        try:
            # This would require ARP table lookup first, then MAC table
            # Implementation depends on specific requirements
            pass
        except Exception as e:
            logger.debug(f"MAC table port lookup failed: {str(e)}")
            
        return None

    def verify_vlan_exists(self, task: Task, vlan_id: str) -> bool:
        """Check if VLAN exists with enhanced platform support"""
        platform = task.host.platform
        
        command_map = {
            "aruba_cx": f"show vlan {vlan_id}",
            "cisco_ios": f"show vlan id {vlan_id}",
            "cisco_xe": f"show vlan id {vlan_id}",
            "hp_comware": f"display vlan {vlan_id}",
            "juniper": f"show vlans {vlan_id}"
        }
        
        command = command_map.get(platform, f"show vlan id {vlan_id}")
        
        try:
            logger.debug(f"Running on {task.host}: {command}")
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if isinstance(result.result, str):
                # Check for common error messages
                error_indicators = ["invalid", "not found", "does not exist", "error"]
                return not any(indicator in result.result.lower() for indicator in error_indicators)
            
            return bool(result.result)
            
        except Exception as e:
            logger.error(f"Error checking VLAN on {task.host}: {str(e)}")
            return False

    def verify_access_vlan(self, task: Task, interface: str, vlan_id: str) -> bool:
        """Verify access port VLAN configuration with better error handling"""
        platform = task.host.platform
        
        try:
            # Method 1: Check VLAN membership
            if self._check_vlan_membership(task, interface, vlan_id, platform):
                return True
            
            # Method 2: Check interface configuration
            if self._check_interface_config(task, interface, vlan_id, platform):
                return True
            
            logger.debug(f"Access VLAN {vlan_id} not found on {interface}")
            return False
            
        except Exception as e:
            logger.error(f"Error checking access port on {task.host}: {str(e)}")
            return False

    def _check_vlan_membership(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check VLAN membership tables"""
        try:
            command_map = {
                "aruba_cx": f"show vlan {vlan_id}",
                "cisco_ios": f"show vlan id {vlan_id}",
                "cisco_xe": f"show vlan id {vlan_id}",
            }
            
            command = command_map.get(platform, f"show vlan id {vlan_id}")
            
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if result.result:
                for vlan in (result.result if isinstance(result.result, list) else [result.result]):
                    interfaces = vlan.get('interfaces', [])
                    if isinstance(interfaces, str):
                        interfaces = [interfaces]
                    
                    # Normalize interface names for comparison
                    normalized_interfaces = [self._normalize_interface_name(intf) for intf in interfaces]
                    normalized_target = self._normalize_interface_name(interface)
                    
                    if normalized_target in normalized_interfaces:
                        return True
                        
        except Exception as e:
            logger.debug(f"VLAN membership check failed: {str(e)}")
            
        return False

    def _check_interface_config(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check interface running configuration"""
        try:
            command = f"show running-config interface {interface}"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=False,
                enable=True
            )
            
            config = result.result.lower()
            
            # Platform-specific config patterns
            patterns = {
                "aruba_cx": [f"vlan access {vlan_id}"],
                "cisco_ios": [f"switchport access vlan {vlan_id}"],
                "cisco_xe": [f"switchport access vlan {vlan_id}"],
            }
            
            check_patterns = patterns.get(platform, [f"switchport access vlan {vlan_id}"])
            
            return any(pattern in config for pattern in check_patterns)
            
        except Exception as e:
            logger.debug(f"Interface config check failed: {str(e)}")
            
        return False

    def _normalize_interface_name(self, interface: str) -> str:
        """Normalize interface names for comparison"""
        # Handle common abbreviations
        interface = interface.replace("GigabitEthernet", "Gi")
        interface = interface.replace("FastEthernet", "Fa")
        interface = interface.replace("TenGigabitEthernet", "Te")
        
        # Remove spaces and convert to lowercase
        return interface.replace(" ", "").lower()

    def verify_trunk_vlan(self, task: Task, interface: str, vlan_id: str) -> bool:
        """Verify trunk allows the VLAN with comprehensive checking"""
        platform = task.host.platform
        
        try:
            # Method 1: Check switchport status
            if self._check_switchport_trunk(task, interface, vlan_id, platform):
                return True
            
            # Method 2: Check running configuration
            if self._check_trunk_config(task, interface, vlan_id, platform):
                return True
            
            return False
            
        except Exception as e:
            logger.error(f"Error checking trunk on {task.host}: {str(e)}")
            return False

    def _check_switchport_trunk(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check switchport trunk status"""
        try:
            command = f"show interfaces {interface} switchport"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if isinstance(result.result, str):
                # Parse raw output
                return self._parse_trunk_raw_output(result.result, vlan_id)
            
            if result.result and isinstance(result.result, list):
                sw_data = result.result[0]
                
                # Check if port is in trunk mode
                if sw_data.get('mode', '').lower() != 'trunk':
                    return False
                
                # Check allowed VLANs
                return self._check_allowed_vlans(sw_data, vlan_id)
                
        except Exception as e:
            logger.debug(f"Switchport trunk check failed: {str(e)}")
            
        return False

    def _parse_trunk_raw_output(self, output: str, vlan_id: str) -> bool:
        """Parse raw switchport output"""
        output_lower = output.lower()
        
        if "trunking" in output_lower:
            if "vlans allowed: all" in output_lower:
                return True
            if f"vlans allowed: {vlan_id}" in output_lower:
                return True
        
        return False

    def _check_allowed_vlans(self, switchport_data: Dict, vlan_id: str) -> bool:
        """Check if VLAN is in allowed VLAN list"""
        for field in ['trunking_vlans', 'vlans_allowed', 'allowed_vlans']:
            vlans = switchport_data.get(field, '')
            
            if vlans:
                if vlans.upper() == 'ALL':
                    return True
                if self._is_vlan_in_list(vlans, vlan_id):
                    return True
        
        return False

    def _check_trunk_config(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check trunk configuration in running config"""
        try:
            command = f"show running-config interface {interface}"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                enable=True
            )
            
            config = result.result.lower()
            
            # If trunk mode is configured but no allowed VLAN restrictions, assume all VLANs allowed
            if "switchport mode trunk" in config and "switchport trunk allowed vlan" not in config:
                return True
            
            # Check specific VLAN allowances
            if f"switchport trunk allowed vlan add {vlan_id}" in config:
                return True
            
            return False
            
        except Exception as e:
            logger.debug(f"Trunk config check failed: {str(e)}")
            
        return False

    def _is_vlan_in_list(self, vlan_str: str, target_vlan: str) -> bool:
        """Helper to safely parse VLAN lists (1,5,10-20,30)"""
        try:
            if not vlan_str:
                return False
                
            target_int = int(target_vlan)
            
            for part in str(vlan_str).split(','):
                part = part.strip()
                
                if '-' in part:
                    # Handle range (e.g., "10-20")
                    start, end = map(int, part.split('-'))
                    if start <= target_int <= end:
                        return True
                elif part.isdigit() and int(part) == target_int:
                    return True
                    
            return False
            
        except (ValueError, AttributeError) as e:
            logger.error(f"VLAN list parsing failed: {str(e)}")
            return False

    def trace_path_to_router(self, start_device: str) -> List[str]:
        """Trace path from edge switch to router using LLDP with improved logic"""
        logger.info("Starting path trace to router...")
        
        path = []
        current_device = start_device
        visited: Set[str] = set()
        
        # Get target router
        try:
            target_router = self.nr.inventory.hosts[start_device].data.get('router')
            if not target_router:
                logger.error(f"No router defined for {start_device}")
                return []
        except KeyError:
            logger.error(f"Device {start_device} not found in inventory")
            return []

        logger.info(f"Target router: {target_router}")

        while current_device and current_device not in visited and len(path) < self.max_hops:
            visited.add(current_device)
            path.append(current_device)
            
            logger.debug(f"Current device: {current_device}")
            logger.debug(f"Current path: {' -> '.join(path)}")
            
            # Check if we've reached the target router
            if current_device == target_router:
                logger.info(f"Reached target router: {current_device}")
                break
            
            # Get neighbors and find next hop
            next_hop = self._find_next_hop(current_device, target_router, visited)
            if not next_hop:
                logger.warning(f"No valid next hop found from {current_device}")
                break
                
            current_device = next_hop

        # Ensure router is in path
        if path and path[-1] != target_router:
            path.append(target_router)
            logger.debug(f"Added router {target_router} to path")

        logger.info(f"Final path: {' -> '.join(path)}")
        return path

    def _find_next_hop(self, current_device: str, target_router: str, visited: Set[str]) -> Optional[str]:
        """Find the next hop in the path"""
        try:
            neighbors_result = self.nr.filter(name=current_device).run(task=self.get_lldp_neighbors)
            neighbors = neighbors_result[current_device].result
            
            if not neighbors:
                logger.debug(f"No neighbors found for {current_device}")
                return None
            
            # Find unvisited neighbors
            possible_hops = []
            for neighbor in (neighbors if isinstance(neighbors, list) else [neighbors]):
                if isinstance(neighbor, dict):
                    neighbor_ip = self._extract_neighbor_ip(neighbor)
                    
                    if neighbor_ip and neighbor_ip not in visited:
                        # Try to resolve to inventory hostname
                        resolved_ip = self._resolve_neighbor_ip(neighbor_ip)
                        if resolved_ip:
                            possible_hops.append(resolved_ip)
            
            if not possible_hops:
                return None
            
            # Prioritize direct connection to router
            if target_router in possible_hops:
                return target_router
            
            # Prioritize devices that have the target router configured
            for hop in possible_hops:
                try:
                    if self.nr.inventory.hosts[hop].data.get('router') == target_router:
                        return hop
                except KeyError:
                    continue
            
            # Return first available hop
            return possible_hops[0]
            
        except Exception as e:
            logger.error(f"Error finding next hop from {current_device}: {str(e)}")
            return None

    def _extract_neighbor_ip(self, neighbor: Dict) -> Optional[str]:
        """Extract neighbor IP from LLDP data"""
        neighbor_ip = (neighbor.get('mgmt_address') or 
                      neighbor.get('neighbor') or 
                      neighbor.get('neighbor_name') or
                      neighbor.get('system_name'))
        
        if neighbor_ip and '.' not in neighbor_ip:
            # Handle hostname format
            neighbor_ip = neighbor_ip.split('.')[0]
        
        return neighbor_ip

    def _resolve_neighbor_ip(self, neighbor_ip: str) -> Optional[str]:
        """Resolve neighbor IP to inventory hostname"""
        # Direct match
        if neighbor_ip in self.nr.inventory.hosts:
            return neighbor_ip
        
        # Hostname match
        for hostname, host in self.nr.inventory.hosts.items():
            if (host.get('hostname', '') == neighbor_ip or 
                hostname.startswith(neighbor_ip)):
                return hostname
        
        return None

    def verify_vlan_path(self, initial_switch: str, target_port: str, vlan_id: str) -> Tuple[bool, str, List[str], Dict[str, DeviceResult]]:
        """Comprehensive VLAN path verification"""
        logger.info("Starting VLAN path verification")
        
        # Trace path
        path = self.trace_path_to_router(initial_switch)
        if not path:
            return False, "No path found to router", [], {}

        # Verify each device in path
        results = {}
        overall_success = True
        failure_reasons = []
        
        for i, device_ip in enumerate(path):
            logger.info(f"Verifying device {i+1}/{len(path)}: {device_ip}")
            
            result = DeviceResult(device_ip=device_ip, vlan_status="Unknown")
            
            # Check VLAN exists
            vlan_exists = self.nr.filter(name=device_ip).run(
                task=self.verify_vlan_exists,
                vlan_id=vlan_id
            )[device_ip].result
            
            if vlan_exists:
                result.vlan_status = "VLAN exists"
                logger.debug(f"VLAN {vlan_id} exists on {device_ip}")
            else:
                result.vlan_status = "VLAN missing"
                result.overall_status = VerificationStatus.FAIL
                overall_success = False
                failure_reasons.append(f"VLAN {vlan_id} missing on {device_ip}")
                logger.warning(f"VLAN {vlan_id} missing on {device_ip}")
            
            # First device: check access port
            if i == 0:
                access_ok = self.nr.filter(name=device_ip).run(
                    task=self.verify_access_vlan,
                    interface=target_port,
                    vlan_id=vlan_id
                )[device_ip].result
                
                if access_ok:
                    result.port_status = "Access port configured"
                    logger.debug(f"Access port {target_port} configured on {device_ip}")
                else:
                    result.port_status = f"Port {target_port} not in VLAN {vlan_id}"
                    result.overall_status = VerificationStatus.FAIL
                    overall_success = False
                    failure_reasons.append(f"Port {target_port} not in VLAN {vlan_id}")
                    logger.warning(f"Port {target_port} not in VLAN {vlan_id}")
            
            # Intermediate devices: check trunk ports
            elif i < len(path) - 1:
                next_device = path[i + 1]
                uplink_port = self.nr.filter(name=device_ip).run(
                    task=self.find_uplink_port,
                    neighbor_ip=next_device
                )[device_ip].result
                
                if uplink_port:
                    trunk_ok = self.nr.filter(name=device_ip).run(
                        task=self.verify_trunk_vlan,
                        interface=uplink_port,
                        vlan_id=vlan_id
                    )[device_ip].result
                    
                    if trunk_ok:
                        result.trunk_status = f"Trunk {uplink_port} allows VLAN"
                        logger.debug(f"Trunk {uplink_port} allows VLAN {vlan_id}")
                    else:
                        result.trunk_status = f"VLAN {vlan_id} blocked on {uplink_port}"
                        result.overall_status = VerificationStatus.FAIL
                        overall_success = False
                        failure_reasons.append(f"VLAN {vlan_id} blocked on {uplink_port}")
                        logger.warning(f"VLAN {vlan_id} blocked on {uplink_port}")
                else:
                    result.trunk_status = f"No uplink found to {next_device}"
                    result.overall_status = VerificationStatus.FAIL
                    overall_success = False
                    failure_reasons.append(f"No uplink found to {next_device}")
                    logger.warning(f"No uplink found to {next_device}")
            
            # Router endpoint
            else:
                result.role = "Router endpoint"
                logger.debug(f"Router endpoint: {device_ip}")
            
            # Set overall status if not already failed
            if result.overall_status == VerificationStatus.UNKNOWN:
                result.overall_status = VerificationStatus.PASS
            
            results[device_ip] = result

        # Generate summary message
        if overall_success:
            message = f"VLAN {vlan_id} path fully verified"
        else:
            message = f"VLAN path verification failed: {'; '.join(failure_reasons[:3])}"
        
        logger.info(f"Verification complete: {message}")
        return overall_success, message, path, results

    def visualize_path(self, path: List[str], verification_results: Dict[str, DeviceResult]):
        """Create enhanced visualization of the network path"""
        plt.ioff()
        fig, ax = plt.subplots(figsize=(18, 12))
        
        # Create graph
        G = nx.path_graph(path)
        
        # Position nodes
        pos = {node: (i * 3, 0) for i, node in enumerate(G.nodes())}
        
        # Prepare node colors and labels
        node_colors = []
        node_labels = {}
        status_labels = {}
        
        for node in G.nodes():
            result = verification_results.get(node)
            if not result:
                node_colors.append("gray")
                status_labels[node] = "No data"
                continue
            
            # Determine color based on status
            if result.overall_status == VerificationStatus.PASS:
                node_colors.append("lightgreen")
                status = "✓ PASS"
            elif result.overall_status == VerificationStatus.FAIL:
                node_colors.append("red")
                status = "✗ FAIL"
            else:
                node_colors.append("gray")
                status = "? UNKNOWN"
            
            # Create node label
            node_labels[node] = node
            
            # Create status label
            status_lines = [f"Status: {status}"]
            
            if result.vlan_status:
                status_lines.append(f"VLAN: {result.vlan_status}")
            
            if result.port_status:
                status_lines.append(f"Port: {result.port_status}")
            
            if result.trunk_status:
                status_lines.append(f"Trunk: {result.trunk_status}")
            
            if result.role:
                status_lines.append(f"Role: {result.role}")
            
            status_labels[node] = "\n".join(status_lines[:4])  # Limit to 4 lines
        
        # Draw network graph
        nx.draw_networkx_nodes(G, pos, node_color=node_colors, node_size=5000, 
                              edgecolors='black', linewidths=2)
        nx.draw_networkx_edges(G, pos, width=3, edge_color='steelblue', 
                              arrows=True, arrowstyle='-|>', arrowsize=30)
        
        # Add device labels (above nodes)
        name_pos = {k: (v[0], v[1] + 0.8) for k, v in pos.items()}
        nx.draw_networkx_labels(G, name_pos, labels=node_labels, font_size=10, 
                               font_weight="bold")
        
        # Add status labels (below nodes)
        status_pos = {k: (v[0], v[1] - 1.2) for k, v in pos.items()}
        nx.draw_networkx_labels(G, status_pos, labels=status_labels, font_size=8,
                               bbox=dict(facecolor='white', edgecolor='black',
                                       boxstyle='round,pad=0.5', alpha=0.9))
        
        # Add legend
        legend_elements = [
            plt.Line2D([0], [0], marker='o', color='w', label='Pass', 
                      markerfacecolor='lightgreen', markersize=15),
            plt.Line2D([0], [0], marker='o', color='w', label='Fail', 
                      markerfacecolor='red', markersize=15),
            plt.Line2D([0], [0], marker='o', color='w', label='Unknown', 
                      markerfacecolor='gray', markersize=15)
        ]
        
        plt.legend(handles=legend_elements, loc='upper right', fontsize=12, 
                  title="Verification Status", title_fontsize=14)
        
        plt.title("Network VLAN Path Verification Results", pad=40, fontsize=18, 
                 fontweight='bold')
        plt.axis('off')
        plt.tight_layout()
        plt.show(block=True)
        plt.ion()


def main():
    """Main function to run VLAN path verification"""
    # Configuration
    initial_switch = "172.17.57.243"
    target_port = "GigabitEthernet1/0/10"
    vlan_id = "5"
    
    # Create verifier instance
    verifier = NetworkVerifier(config_file="config.yaml")
    
    try:
        # Run verification
        success, message, path, results = verifier.verify_vlan_path(
            initial_switch, target_port, vlan_id
        )
        
        # Print results
        print("\n" + "="*60)
        print(f"VLAN PATH VERIFICATION {'SUCCEEDED' if success else 'FAILED'}")
        print("="*60)
        print(f"Initial Switch: {initial_switch}")
        print(f"Target Port: {target_port}")
        print(f"VLAN ID: {vlan_id}")
        print(f"Path: {' → '.join(path)}")
        print(f"Status: {message}")
        print("="*60)
        
        # Detailed results
        print("\nDETAILED RESULTS:")
        print("-" * 40)
        for device_ip, result in results.items():
            print(f"\nDevice: {device_ip}")
            print(f"  Overall Status: {result.overall_status.value.upper()}")
            print(f"  VLAN Status: {result.vlan_status}")
            if result.port_status:
                print(f"  Port Status: {result.port_status}")
            if result.trunk_status:
                print(f"  Trunk Status: {result.trunk_status}")
            if result.role:
                print(f"  Role: {result.role}")
        
        # Show visualization
        if path and results:
            print("\nGenerating network visualization...")
            verifier.visualize_path(path, results)
        
        return success
        
    except Exception as e:
        logger.error(f"Verification failed with error: {str(e)}")
        print(f"\nERROR: Verification failed - {str(e)}")
        return False
    
    finally:
        # Cleanup
        if hasattr(verifier, 'nr') and verifier.nr:
            verifier.nr.close_connections()


if __name__ == "__main__":
    import sys
    
    # Allow command line arguments
    if len(sys.argv) >= 4:
        initial_switch = sys.argv[1]
        target_port = sys.argv[2]
        vlan_id = sys.argv[3]
        
        verifier = NetworkVerifier()
        success, message, path, results = verifier.verify_vlan_path(
            initial_switch, target_port, vlan_id
        )
        
        if success:
            print(f"✓ VLAN {vlan_id} path verification successful")
            sys.exit(0)
        else:
            print(f"✗ VLAN {vlan_id} path verification failed: {message}")
            sys.exit(1)
    else:
        # Use default configuration
        success = main()
        sys.exit(0 if success else 1)
from nornir import InitNornir
from nornir_netmiko import netmiko_send_command
from nornir.core.task import Task, Result
from typing import Dict, List, Tuple, Optional, Set
import networkx as nx
import matplotlib.pyplot as plt
import re
import logging
from dataclasses import dataclass
from enum import Enum

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class VerificationStatus(Enum):
    PASS = "pass"
    FAIL = "fail"
    UNKNOWN = "unknown"

@dataclass
class DeviceResult:
    device_ip: str
    vlan_status: str
    port_status: Optional[str] = None
    trunk_status: Optional[str] = None
    role: Optional[str] = None
    overall_status: VerificationStatus = VerificationStatus.UNKNOWN

class NetworkVerifier:
    def __init__(self, config_file: str = "config.yaml"):
        self.nr = InitNornir(config_file=config_file)
        self.max_hops = 15
        
    def get_lldp_neighbors(self, task: Task) -> List[Dict]:
        """Collect LLDP neighbor information in a vendor-neutral way"""
        platform = task.host.platform
        
        # Enhanced command mapping for different platforms
        command_map = {
            "aruba_cx": "show lldp neighbors detail",
            "cisco_ios": "show lldp neighbors detail",
            "cisco_xe": "show lldp neighbors detail",
            "hp_comware": "display lldp neighbor-information",
            "juniper": "show lldp neighbors detail"
        }
        
        command = command_map.get(platform, "show lldp neighbors detail")
        
        logger.debug(f"Running on {task.host}: {command}")
        
        try:
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            # Handle different result types
            if isinstance(result.result, str):
                logger.warning(f"TextFSM parsing failed for {task.host}, attempting manual parsing")
                return self._parse_lldp_manually(result.result, platform)
            elif isinstance(result.result, dict):
                return [result.result]
            elif isinstance(result.result, list):
                return result.result
            else:
                logger.warning(f"No LLDP neighbors found on {task.host}")
                return []
                
        except Exception as e:
            logger.error(f"Error getting LLDP neighbors on {task.host}: {str(e)}")
            return []

    def _parse_lldp_manually(self, output: str, platform: str) -> List[Dict]:
        """Manual parsing fallback for when TextFSM fails"""
        neighbors = []
        
        try:
            # Basic regex patterns for common LLDP output formats
            if platform == "cisco_ios":
                # Cisco IOS LLDP format
                pattern = r'Device ID: (\S+).*?Local Intf: (\S+).*?Port id: (\S+)'
                matches = re.findall(pattern, output, re.DOTALL)
                
                for match in matches:
                    neighbors.append({
                        'neighbor': match[0],
                        'local_interface': match[1],
                        'neighbor_port': match[2]
                    })
            
            # Add more platform-specific parsing as needed
            
        except Exception as e:
            logger.error(f"Manual LLDP parsing failed: {str(e)}")
            
        return neighbors

    def find_uplink_port(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find the local interface connected to a neighbor with improved error handling"""
        platform = task.host.platform
        
        try:
            # Try LLDP first (most reliable)
            lldp_result = self._find_port_via_lldp(task, neighbor_ip, platform)
            if lldp_result:
                return lldp_result
            
            # Fall back to CDP for Cisco devices
            if platform.startswith("cisco"):
                cdp_result = self._find_port_via_cdp(task, neighbor_ip)
                if cdp_result:
                    return cdp_result
                    
            # Last resort: MAC address table lookup
            mac_result = self._find_port_via_mac(task, neighbor_ip)
            if mac_result:
                return mac_result
                
        except Exception as e:
            logger.error(f"Error finding uplink port on {task.host}: {str(e)}")
        
        return None

    def _find_port_via_lldp(self, task: Task, neighbor_ip: str, platform: str) -> Optional[str]:
        """Find port using LLDP"""
        try:
            neighbors = self.get_lldp_neighbors(task)
            
            for neighbor in neighbors:
                # Check multiple possible neighbor identifier fields
                neighbor_id = (neighbor.get('neighbor') or 
                             neighbor.get('mgmt_address') or 
                             neighbor.get('system_name'))
                
                if neighbor_id and (neighbor_id == neighbor_ip or 
                                  neighbor_id.startswith(neighbor_ip.split('.')[0])):
                    return neighbor.get('local_interface')
                    
        except Exception as e:
            logger.debug(f"LLDP port lookup failed: {str(e)}")
            
        return None

    def _find_port_via_cdp(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find port using CDP (Cisco devices)"""
        try:
            command = "show cdp neighbors detail"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if result.result:
                for neighbor in (result.result if isinstance(result.result, list) else [result.result]):
                    if neighbor.get('mgmt_address') == neighbor_ip:
                        return neighbor.get('local_port')
                        
        except Exception as e:
            logger.debug(f"CDP port lookup failed: {str(e)}")
            
        return None

    def _find_port_via_mac(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find port using MAC address table (least reliable)"""
        try:
            # This would require ARP table lookup first, then MAC table
            # Implementation depends on specific requirements
            pass
        except Exception as e:
            logger.debug(f"MAC table port lookup failed: {str(e)}")
            
        return None

    def verify_vlan_exists(self, task: Task, vlan_id: str) -> bool:
        """Check if VLAN exists with enhanced platform support"""
        platform = task.host.platform
        
        command_map = {
            "aruba_cx": f"show vlan {vlan_id}",
            "cisco_ios": f"show vlan id {vlan_id}",
            "cisco_xe": f"show vlan id {vlan_id}",
            "hp_comware": f"display vlan {vlan_id}",
            "juniper": f"show vlans {vlan_id}"
        }
        
        command = command_map.get(platform, f"show vlan id {vlan_id}")
        
        try:
            logger.debug(f"Running on {task.host}: {command}")
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if isinstance(result.result, str):
                # Check for common error messages
                error_indicators = ["invalid", "not found", "does not exist", "error"]
                return not any(indicator in result.result.lower() for indicator in error_indicators)
            
            return bool(result.result)
            
        except Exception as e:
            logger.error(f"Error checking VLAN on {task.host}: {str(e)}")
            return False

    def verify_access_vlan(self, task: Task, interface: str, vlan_id: str) -> bool:
        """Verify access port VLAN configuration with better error handling"""
        platform = task.host.platform
        
        try:
            # Method 1: Check VLAN membership
            if self._check_vlan_membership(task, interface, vlan_id, platform):
                return True
            
            # Method 2: Check interface configuration
            if self._check_interface_config(task, interface, vlan_id, platform):
                return True
            
            logger.debug(f"Access VLAN {vlan_id} not found on {interface}")
            return False
            
        except Exception as e:
            logger.error(f"Error checking access port on {task.host}: {str(e)}")
            return False

    def _check_vlan_membership(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check VLAN membership tables"""
        try:
            command_map = {
                "aruba_cx": f"show vlan {vlan_id}",
                "cisco_ios": f"show vlan id {vlan_id}",
                "cisco_xe": f"show vlan id {vlan_id}",
            }
            
            command = command_map.get(platform, f"show vlan id {vlan_id}")
            
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if result.result:
                for vlan in (result.result if isinstance(result.result, list) else [result.result]):
                    interfaces = vlan.get('interfaces', [])
                    if isinstance(interfaces, str):
                        interfaces = [interfaces]
                    
                    # Normalize interface names for comparison
                    normalized_interfaces = [self._normalize_interface_name(intf) for intf in interfaces]
                    normalized_target = self._normalize_interface_name(interface)
                    
                    if normalized_target in normalized_interfaces:
                        return True
                        
        except Exception as e:
            logger.debug(f"VLAN membership check failed: {str(e)}")
            
        return False

    def _check_interface_config(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check interface running configuration"""
        try:
            command = f"show running-config interface {interface}"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=False,
                enable=True
            )
            
            config = result.result.lower()
            
            # Platform-specific config patterns
            patterns = {
                "aruba_cx": [f"vlan access {vlan_id}"],
                "cisco_ios": [f"switchport access vlan {vlan_id}"],
                "cisco_xe": [f"switchport access vlan {vlan_id}"],
            }
            
            check_patterns = patterns.get(platform, [f"switchport access vlan {vlan_id}"])
            
            return any(pattern in config for pattern in check_patterns)
            
        except Exception as e:
            logger.debug(f"Interface config check failed: {str(e)}")
            
        return False

    def _normalize_interface_name(self, interface: str) -> str:
        """Normalize interface names for comparison"""
        # Handle common abbreviations
        interface = interface.replace("GigabitEthernet", "Gi")
        interface = interface.replace("FastEthernet", "Fa")
        interface = interface.replace("TenGigabitEthernet", "Te")
        
        # Remove spaces and convert to lowercase
        return interface.replace(" ", "").lower()

    def verify_trunk_vlan(self, task: Task, interface: str, vlan_id: str) -> bool:
        """Verify trunk allows the VLAN with comprehensive checking"""
        platform = task.host.platform
        
        try:
            # Method 1: Check switchport status
            if self._check_switchport_trunk(task, interface, vlan_id, platform):
                return True
            
            # Method 2: Check running configuration
            if self._check_trunk_config(task, interface, vlan_id, platform):
                return True
            
            return False
            
        except Exception as e:
            logger.error(f"Error checking trunk on {task.host}: {str(e)}")
            return False

    def _check_switchport_trunk(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check switchport trunk status"""
        try:
            command = f"show interfaces {interface} switchport"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if isinstance(result.result, str):
                # Parse raw output
                return self._parse_trunk_raw_output(result.result, vlan_id)
            
            if result.result and isinstance(result.result, list):
                sw_data = result.result[0]
                
                # Check if port is in trunk mode
                if sw_data.get('mode', '').lower() != 'trunk':
                    return False
                
                # Check allowed VLANs
                return self._check_allowed_vlans(sw_data, vlan_id)
                
        except Exception as e:
            logger.debug(f"Switchport trunk check failed: {str(e)}")
            
        return False

    def _parse_trunk_raw_output(self, output: str, vlan_id: str) -> bool:
        """Parse raw switchport output"""
        output_lower = output.lower()
        
        if "trunking" in output_lower:
            if "vlans allowed: all" in output_lower:
                return True
            if f"vlans allowed: {vlan_id}" in output_lower:
                return True
        
        return False

    def _check_allowed_vlans(self, switchport_data: Dict, vlan_id: str) -> bool:
        """Check if VLAN is in allowed VLAN list"""
        for field in ['trunking_vlans', 'vlans_allowed', 'allowed_vlans']:
            vlans = switchport_data.get(field, '')
            
            if vlans:
                if vlans.upper() == 'ALL':
                    return True
                if self._is_vlan_in_list(vlans, vlan_id):
                    return True
        
        return False

    def _check_trunk_config(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check trunk configuration in running config"""
        try:
            command = f"show running-config interface {interface}"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                enable=True
            )
            
            config = result.result.lower()
            
            # If trunk mode is configured but no allowed VLAN restrictions, assume all VLANs allowed
            if "switchport mode trunk" in config and "switchport trunk allowed vlan" not in config:
                return True
            
            # Check specific VLAN allowances
            if f"switchport trunk allowed vlan add {vlan_id}" in config:
                return True
            
            return False
            
        except Exception as e:
            logger.debug(f"Trunk config check failed: {str(e)}")
            
        return False

    def _is_vlan_in_list(self, vlan_str: str, target_vlan: str) -> bool:
        """Helper to safely parse VLAN lists (1,5,10-20,30)"""
        try:
            if not vlan_str:
                return False
                
            target_int = int(target_vlan)
            
            for part in str(vlan_str).split(','):
                part = part.strip()
                
                if '-' in part:
                    # Handle range (e.g., "10-20")
                    start, end = map(int, part.split('-'))
                    if start <= target_int <= end:
                        return True
                elif part.isdigit() and int(part) == target_int:
                    return True
                    
            return False
            
        except (ValueError, AttributeError) as e:
            logger.error(f"VLAN list parsing failed: {str(e)}")
            return False

    def trace_path_to_router(self, start_device: str) -> List[str]:
        """Trace path from edge switch to router using LLDP with improved logic"""
        logger.info("Starting path trace to router...")
        
        path = []
        current_device = start_device
        visited: Set[str] = set()
        
        # Get target router
        try:
            target_router = self.nr.inventory.hosts[start_device].data.get('router')
            if not target_router:
                logger.error(f"No router defined for {start_device}")
                return []
        except KeyError:
            logger.error(f"Device {start_device} not found in inventory")
            return []

        logger.info(f"Target router: {target_router}")

        while current_device and current_device not in visited and len(path) < self.max_hops:
            visited.add(current_device)
            path.append(current_device)
            
            logger.debug(f"Current device: {current_device}")
            logger.debug(f"Current path: {' -> '.join(path)}")
            
            # Check if we've reached the target router
            if current_device == target_router:
                logger.info(f"Reached target router: {current_device}")
                break
            
            # Get neighbors and find next hop
            next_hop = self._find_next_hop(current_device, target_router, visited)
            if not next_hop:
                logger.warning(f"No valid next hop found from {current_device}")
                break
                
            current_device = next_hop

        # Ensure router is in path
        if path and path[-1] != target_router:
            path.append(target_router)
            logger.debug(f"Added router {target_router} to path")

        logger.info(f"Final path: {' -> '.join(path)}")
        return path

    def _find_next_hop(self, current_device: str, target_router: str, visited: Set[str]) -> Optional[str]:
        """Find the next hop in the path"""
        try:
            neighbors_result = self.nr.filter(name=current_device).run(task=self.get_lldp_neighbors)
            neighbors = neighbors_result[current_device].result
            
            if not neighbors:
                logger.debug(f"No neighbors found for {current_device}")
                return None
            
            # Find unvisited neighbors
            possible_hops = []
            for neighbor in (neighbors if isinstance(neighbors, list) else [neighbors]):
                if isinstance(neighbor, dict):
                    neighbor_ip = self._extract_neighbor_ip(neighbor)
                    
                    if neighbor_ip and neighbor_ip not in visited:
                        # Try to resolve to inventory hostname
                        resolved_ip = self._resolve_neighbor_ip(neighbor_ip)
                        if resolved_ip:
                            possible_hops.append(resolved_ip)
            
            if not possible_hops:
                return None
            
            # Prioritize direct connection to router
            if target_router in possible_hops:
                return target_router
            
            # Prioritize devices that have the target router configured
            for hop in possible_hops:
                try:
                    if self.nr.inventory.hosts[hop].data.get('router') == target_router:
                        return hop
                except KeyError:
                    continue
            
            # Return first available hop
            return possible_hops[0]
            
        except Exception as e:
            logger.error(f"Error finding next hop from {current_device}: {str(e)}")
            return None

    def _extract_neighbor_ip(self, neighbor: Dict) -> Optional[str]:
        """Extract neighbor IP from LLDP data"""
        neighbor_ip = (neighbor.get('mgmt_address') or 
                      neighbor.get('neighbor') or 
                      neighbor.get('neighbor_name') or
                      neighbor.get('system_name'))
        
        if neighbor_ip and '.' not in neighbor_ip:
            # Handle hostname format
            neighbor_ip = neighbor_ip.split('.')[0]
        
        return neighbor_ip

    def _resolve_neighbor_ip(self, neighbor_ip: str) -> Optional[str]:
        """Resolve neighbor IP to inventory hostname"""
        # Direct match
        if neighbor_ip in self.nr.inventory.hosts:
            return neighbor_ip
        
        # Hostname match
        for hostname, host in self.nr.inventory.hosts.items():
            if (host.get('hostname', '') == neighbor_ip or 
                hostname.startswith(neighbor_ip)):
                return hostname
        
        return None

    def verify_vlan_path(self, initial_switch: str, target_port: str, vlan_id: str) -> Tuple[bool, str, List[str], Dict[str, DeviceResult]]:
        """Comprehensive VLAN path verification"""
        logger.info("Starting VLAN path verification")
        
        # Trace path
        path = self.trace_path_to_router(initial_switch)
        if not path:
            return False, "No path found to router", [], {}

        # Verify each device in path
        results = {}
        overall_success = True
        failure_reasons = []
        
        for i, device_ip in enumerate(path):
            logger.info(f"Verifying device {i+1}/{len(path)}: {device_ip}")
            
            result = DeviceResult(device_ip=device_ip, vlan_status="Unknown")
            
            # Check VLAN exists
            vlan_exists = self.nr.filter(name=device_ip).run(
                task=self.verify_vlan_exists,
                vlan_id=vlan_id
            )[device_ip].result
            
            if vlan_exists:
                result.vlan_status = "VLAN exists"
                logger.debug(f"VLAN {vlan_id} exists on {device_ip}")
            else:
                result.vlan_status = "VLAN missing"
                result.overall_status = VerificationStatus.FAIL
                overall_success = False
                failure_reasons.append(f"VLAN {vlan_id} missing on {device_ip}")
                logger.warning(f"VLAN {vlan_id} missing on {device_ip}")
            
            # First device: check access port
            if i == 0:
                access_ok = self.nr.filter(name=device_ip).run(
                    task=self.verify_access_vlan,
                    interface=target_port,
                    vlan_id=vlan_id
                )[device_ip].result
                
                if access_ok:
                    result.port_status = "Access port configured"
                    logger.debug(f"Access port {target_port} configured on {device_ip}")
                else:
                    result.port_status = f"Port {target_port} not in VLAN {vlan_id}"
                    result.overall_status = VerificationStatus.FAIL
                    overall_success = False
                    failure_reasons.append(f"Port {target_port} not in VLAN {vlan_id}")
                    logger.warning(f"Port {target_port} not in VLAN {vlan_id}")
            
            # Intermediate devices: check trunk ports
            elif i < len(path) - 1:
                next_device = path[i + 1]
                uplink_port = self.nr.filter(name=device_ip).run(
                    task=self.find_uplink_port,
                    neighbor_ip=next_device
                )[device_ip].result
                
                if uplink_port:
                    trunk_ok = self.nr.filter(name=device_ip).run(
                        task=self.verify_trunk_vlan,
                        interface=uplink_port,
                        vlan_id=vlan_id
                    )[device_ip].result
                    
                    if trunk_ok:
                        result.trunk_status = f"Trunk {uplink_port} allows VLAN"
                        logger.debug(f"Trunk {uplink_port} allows VLAN {vlan_id}")
                    else:
                        result.trunk_status = f"VLAN {vlan_id} blocked on {uplink_port}"
                        result.overall_status = VerificationStatus.FAIL
                        overall_success = False
                        failure_reasons.append(f"VLAN {vlan_id} blocked on {uplink_port}")
                        logger.warning(f"VLAN {vlan_id} blocked on {uplink_port}")
                else:
                    result.trunk_status = f"No uplink found to {next_device}"
                    result.overall_status = VerificationStatus.FAIL
                    overall_success = False
                    failure_reasons.append(f"No uplink found to {next_device}")
                    logger.warning(f"No uplink found to {next_device}")
            
            # Router endpoint
            else:
                result.role = "Router endpoint"
                logger.debug(f"Router endpoint: {device_ip}")
            
            # Set overall status if not already failed
            if result.overall_status == VerificationStatus.UNKNOWN:
                result.overall_status = VerificationStatus.PASS
            
            results[device_ip] = result

        # Generate summary message
        if overall_success:
            message = f"VLAN {vlan_id} path fully verified"
        else:
            message = f"VLAN path verification failed: {'; '.join(failure_reasons[:3])}"
        
        logger.info(f"Verification complete: {message}")
        return overall_success, message, path, results

    def visualize_path(self, path: List[str], verification_results: Dict[str, DeviceResult]):
        """Create enhanced visualization of the network path"""
        plt.ioff()
        fig, ax = plt.subplots(figsize=(18, 12))
        
        # Create graph
        G = nx.path_graph(path)
        
        # Position nodes
        pos = {node: (i * 3, 0) for i, node in enumerate(G.nodes())}
        
        # Prepare node colors and labels
        node_colors = []
        node_labels = {}
        status_labels = {}
        
        for node in G.nodes():
            result = verification_results.get(node)
            if not result:
                node_colors.append("gray")
                status_labels[node] = "No data"
                continue
            
            # Determine color based on status
            if result.overall_status == VerificationStatus.PASS:
                node_colors.append("lightgreen")
                status = "✓ PASS"
            elif result.overall_status == VerificationStatus.FAIL:
                node_colors.append("red")
                status = "✗ FAIL"
            else:
                node_colors.append("gray")
                status = "? UNKNOWN"
            
            # Create node label
            node_labels[node] = node
            
            # Create status label
            status_lines = [f"Status: {status}"]
            
            if result.vlan_status:
                status_lines.append(f"VLAN: {result.vlan_status}")
            
            if result.port_status:
                status_lines.append(f"Port: {result.port_status}")
            
            if result.trunk_status:
                status_lines.append(f"Trunk: {result.trunk_status}")
            
            if result.role:
                status_lines.append(f"Role: {result.role}")
            
            status_labels[node] = "\n".join(status_lines[:4])  # Limit to 4 lines
        
        # Draw network graph
        nx.draw_networkx_nodes(G, pos, node_color=node_colors, node_size=5000, 
                              edgecolors='black', linewidths=2)
        nx.draw_networkx_edges(G, pos, width=3, edge_color='steelblue', 
                              arrows=True, arrowstyle='-|>', arrowsize=30)
        
        # Add device labels (above nodes)
        name_pos = {k: (v[0], v[1] + 0.8) for k, v in pos.items()}
        nx.draw_networkx_labels(G, name_pos, labels=node_labels, font_size=10, 
                               font_weight="bold")
        
        # Add status labels (below nodes)
        status_pos = {k: (v[0], v[1] - 1.2) for k, v in pos.items()}
        nx.draw_networkx_labels(G, status_pos, labels=status_labels, font_size=8,
                               bbox=dict(facecolor='white', edgecolor='black',
                                       boxstyle='round,pad=0.5', alpha=0.9))
        
        # Add legend
        legend_elements = [
            plt.Line2D([0], [0], marker='o', color='w', label='Pass', 
                      markerfacecolor='lightgreen', markersize=15),
            plt.Line2D([0], [0], marker='o', color='w', label='Fail', 
                      markerfacecolor='red', markersize=15),
            plt.Line2D([0], [0], marker='o', color='w', label='Unknown', 
                      markerfacecolor='gray', markersize=15)
        ]
        
        plt.legend(handles=legend_elements, loc='upper right', fontsize=12, 
                  title="Verification Status", title_fontsize=14)
        
        plt.title("Network VLAN Path Verification Results", pad=40, fontsize=18, 
                 fontweight='bold')
        plt.axis('off')
        plt.tight_layout()
        plt.show(block=True)
        plt.ion()


def main():
    """Main function to run VLAN path verification"""
    # Configuration
    initial_switch = "172.17.57.243"
    target_port = "GigabitEthernet1/0/10"
    vlan_id = "5"
    
    # Create verifier instance
    verifier = NetworkVerifier(config_file="config.yaml")
    
    try:
        # Run verification
        success, message, path, results = verifier.verify_vlan_path(
            initial_switch, target_port, vlan_id
        )
        
        # Print results
        print("\n" + "="*60)
        print(f"VLAN PATH VERIFICATION {'SUCCEEDED' if success else 'FAILED'}")
        print("="*60)
        print(f"Initial Switch: {initial_switch}")
        print(f"Target Port: {target_port}")
        print(f"VLAN ID: {vlan_id}")
        print(f"Path: {' → '.join(path)}")
        print(f"Status: {message}")
        print("="*60)
        
        # Detailed results
        print("\nDETAILED RESULTS:")
        print("-" * 40)
        for device_ip, result in results.items():
            print(f"\nDevice: {device_ip}")
            print(f"  Overall Status: {result.overall_status.value.upper()}")
            print(f"  VLAN Status: {result.vlan_status}")
            if result.port_status:
                print(f"  Port Status: {result.port_status}")
            if result.trunk_status:
                print(f"  Trunk Status: {result.trunk_status}")
            if result.role:
                print(f"  Role: {result.role}")
        
        # Show visualization
        if path and results:
            print("\nGenerating network visualization...")
            verifier.visualize_path(path, results)
        
        return success
        
    except Exception as e:
        logger.error(f"Verification failed with error: {str(e)}")
        print(f"\nERROR: Verification failed - {str(e)}")
        return False
    
    finally:
        # Cleanup
        if hasattr(verifier, 'nr') and verifier.nr:
            verifier.nr.close_connections()


if __name__ == "__main__":
    import sys
    
    # Allow command line arguments
    if len(sys.argv) >= 4:
        initial_switch = sys.argv[1]
        target_port = sys.argv[2]
        vlan_id = sys.argv[3]
        
        verifier = NetworkVerifier()
        success, message, path, results = verifier.verify_vlan_path(
            initial_switch, target_port, vlan_id
        )
        
        if success:
            print(f"✓ VLAN {vlan_id} path verification successful")
            sys.exit(0)
        else:
            print(f"✗ VLAN {vlan_id} path verification failed: {message}")
            sys.exit(1)
    else:
        # Use default configuration
        success = main()
        sys.exit(0 if success else 1)tory.hosts[start_switch].data.get("router")
from nornir import InitNornir
from nornir_netmiko import netmiko_send_command
from nornir.core.task import Task, Result
from typing import Dict, List, Tuple, Optional, Set
import networkx as nx
import matplotlib.pyplot as plt
import re
import logging
from dataclasses import dataclass
from enum import Enum

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class VerificationStatus(Enum):
    PASS = "pass"
    FAIL = "fail"
    UNKNOWN = "unknown"

@dataclass
class DeviceResult:
    device_ip: str
    vlan_status: str
    port_status: Optional[str] = None
    trunk_status: Optional[str] = None
    role: Optional[str] = None
    overall_status: VerificationStatus = VerificationStatus.UNKNOWN

class NetworkVerifier:
    def __init__(self, config_file: str = "config.yaml"):
        self.nr = InitNornir(config_file=config_file)
        self.max_hops = 15
        
    def get_lldp_neighbors(self, task: Task) -> List[Dict]:
        """Collect LLDP neighbor information in a vendor-neutral way"""
        platform = task.host.platform
        
        # Enhanced command mapping for different platforms
        command_map = {
            "aruba_cx": "show lldp neighbors detail",
            "cisco_ios": "show lldp neighbors detail",
            "cisco_xe": "show lldp neighbors detail",
            "hp_comware": "display lldp neighbor-information",
            "juniper": "show lldp neighbors detail"
        }
        
        command = command_map.get(platform, "show lldp neighbors detail")
        
        logger.debug(f"Running on {task.host}: {command}")
        
        try:
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            # Handle different result types
            if isinstance(result.result, str):
                logger.warning(f"TextFSM parsing failed for {task.host}, attempting manual parsing")
                return self._parse_lldp_manually(result.result, platform)
            elif isinstance(result.result, dict):
                return [result.result]
            elif isinstance(result.result, list):
                return result.result
            else:
                logger.warning(f"No LLDP neighbors found on {task.host}")
                return []
                
        except Exception as e:
            logger.error(f"Error getting LLDP neighbors on {task.host}: {str(e)}")
            return []

    def _parse_lldp_manually(self, output: str, platform: str) -> List[Dict]:
        """Manual parsing fallback for when TextFSM fails"""
        neighbors = []
        
        try:
            # Basic regex patterns for common LLDP output formats
            if platform == "cisco_ios":
                # Cisco IOS LLDP format
                pattern = r'Device ID: (\S+).*?Local Intf: (\S+).*?Port id: (\S+)'
                matches = re.findall(pattern, output, re.DOTALL)
                
                for match in matches:
                    neighbors.append({
                        'neighbor': match[0],
                        'local_interface': match[1],
                        'neighbor_port': match[2]
                    })
            
            # Add more platform-specific parsing as needed
            
        except Exception as e:
            logger.error(f"Manual LLDP parsing failed: {str(e)}")
            
        return neighbors

    def find_uplink_port(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find the local interface connected to a neighbor with improved error handling"""
        platform = task.host.platform
        
        try:
            # Try LLDP first (most reliable)
            lldp_result = self._find_port_via_lldp(task, neighbor_ip, platform)
            if lldp_result:
                return lldp_result
            
            # Fall back to CDP for Cisco devices
            if platform.startswith("cisco"):
                cdp_result = self._find_port_via_cdp(task, neighbor_ip)
                if cdp_result:
                    return cdp_result
                    
            # Last resort: MAC address table lookup
            mac_result = self._find_port_via_mac(task, neighbor_ip)
            if mac_result:
                return mac_result
                
        except Exception as e:
            logger.error(f"Error finding uplink port on {task.host}: {str(e)}")
        
        return None

    def _find_port_via_lldp(self, task: Task, neighbor_ip: str, platform: str) -> Optional[str]:
        """Find port using LLDP"""
        try:
            neighbors = self.get_lldp_neighbors(task)
            
            for neighbor in neighbors:
                # Check multiple possible neighbor identifier fields
                neighbor_id = (neighbor.get('neighbor') or 
                             neighbor.get('mgmt_address') or 
                             neighbor.get('system_name'))
                
                if neighbor_id and (neighbor_id == neighbor_ip or 
                                  neighbor_id.startswith(neighbor_ip.split('.')[0])):
                    return neighbor.get('local_interface')
                    
        except Exception as e:
            logger.debug(f"LLDP port lookup failed: {str(e)}")
            
        return None

    def _find_port_via_cdp(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find port using CDP (Cisco devices)"""
        try:
            command = "show cdp neighbors detail"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if result.result:
                for neighbor in (result.result if isinstance(result.result, list) else [result.result]):
                    if neighbor.get('mgmt_address') == neighbor_ip:
                        return neighbor.get('local_port')
                        
        except Exception as e:
            logger.debug(f"CDP port lookup failed: {str(e)}")
            
        return None

    def _find_port_via_mac(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find port using MAC address table (least reliable)"""
        try:
            # This would require ARP table lookup first, then MAC table
            # Implementation depends on specific requirements
            pass
        except Exception as e:
            logger.debug(f"MAC table port lookup failed: {str(e)}")
            
        return None

    def verify_vlan_exists(self, task: Task, vlan_id: str) -> bool:
        """Check if VLAN exists with enhanced platform support"""
        platform = task.host.platform
        
        command_map = {
            "aruba_cx": f"show vlan {vlan_id}",
            "cisco_ios": f"show vlan id {vlan_id}",
            "cisco_xe": f"show vlan id {vlan_id}",
            "hp_comware": f"display vlan {vlan_id}",
            "juniper": f"show vlans {vlan_id}"
        }
        
        command = command_map.get(platform, f"show vlan id {vlan_id}")
        
        try:
            logger.debug(f"Running on {task.host}: {command}")
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if isinstance(result.result, str):
                # Check for common error messages
                error_indicators = ["invalid", "not found", "does not exist", "error"]
                return not any(indicator in result.result.lower() for indicator in error_indicators)
            
            return bool(result.result)
            
        except Exception as e:
            logger.error(f"Error checking VLAN on {task.host}: {str(e)}")
            return False

    def verify_access_vlan(self, task: Task, interface: str, vlan_id: str) -> bool:
        """Verify access port VLAN configuration with better error handling"""
        platform = task.host.platform
        
        try:
            # Method 1: Check VLAN membership
            if self._check_vlan_membership(task, interface, vlan_id, platform):
                return True
            
            # Method 2: Check interface configuration
            if self._check_interface_config(task, interface, vlan_id, platform):
                return True
            
            logger.debug(f"Access VLAN {vlan_id} not found on {interface}")
            return False
            
        except Exception as e:
            logger.error(f"Error checking access port on {task.host}: {str(e)}")
            return False

    def _check_vlan_membership(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check VLAN membership tables"""
        try:
            command_map = {
                "aruba_cx": f"show vlan {vlan_id}",
                "cisco_ios": f"show vlan id {vlan_id}",
                "cisco_xe": f"show vlan id {vlan_id}",
            }
            
            command = command_map.get(platform, f"show vlan id {vlan_id}")
            
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if result.result:
                for vlan in (result.result if isinstance(result.result, list) else [result.result]):
                    interfaces = vlan.get('interfaces', [])
                    if isinstance(interfaces, str):
                        interfaces = [interfaces]
                    
                    # Normalize interface names for comparison
                    normalized_interfaces = [self._normalize_interface_name(intf) for intf in interfaces]
                    normalized_target = self._normalize_interface_name(interface)
                    
                    if normalized_target in normalized_interfaces:
                        return True
                        
        except Exception as e:
            logger.debug(f"VLAN membership check failed: {str(e)}")
            
        return False

    def _check_interface_config(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check interface running configuration"""
        try:
            command = f"show running-config interface {interface}"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=False,
                enable=True
            )
            
            config = result.result.lower()
            
            # Platform-specific config patterns
            patterns = {
                "aruba_cx": [f"vlan access {vlan_id}"],
                "cisco_ios": [f"switchport access vlan {vlan_id}"],
                "cisco_xe": [f"switchport access vlan {vlan_id}"],
            }
            
            check_patterns = patterns.get(platform, [f"switchport access vlan {vlan_id}"])
            
            return any(pattern in config for pattern in check_patterns)
            
        except Exception as e:
            logger.debug(f"Interface config check failed: {str(e)}")
            
        return False

    def _normalize_interface_name(self, interface: str) -> str:
        """Normalize interface names for comparison"""
        # Handle common abbreviations
        interface = interface.replace("GigabitEthernet", "Gi")
        interface = interface.replace("FastEthernet", "Fa")
        interface = interface.replace("TenGigabitEthernet", "Te")
        
        # Remove spaces and convert to lowercase
        return interface.replace(" ", "").lower()

    def verify_trunk_vlan(self, task: Task, interface: str, vlan_id: str) -> bool:
        """Verify trunk allows the VLAN with comprehensive checking"""
        platform = task.host.platform
        
        try:
            # Method 1: Check switchport status
            if self._check_switchport_trunk(task, interface, vlan_id, platform):
                return True
            
            # Method 2: Check running configuration
            if self._check_trunk_config(task, interface, vlan_id, platform):
                return True
            
            return False
            
        except Exception as e:
            logger.error(f"Error checking trunk on {task.host}: {str(e)}")
            return False

    def _check_switchport_trunk(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check switchport trunk status"""
        try:
            command = f"show interfaces {interface} switchport"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if isinstance(result.result, str):
                # Parse raw output
                return self._parse_trunk_raw_output(result.result, vlan_id)
            
            if result.result and isinstance(result.result, list):
                sw_data = result.result[0]
                
                # Check if port is in trunk mode
                if sw_data.get('mode', '').lower() != 'trunk':
                    return False
                
                # Check allowed VLANs
                return self._check_allowed_vlans(sw_data, vlan_id)
                
        except Exception as e:
            logger.debug(f"Switchport trunk check failed: {str(e)}")
            
        return False

    def _parse_trunk_raw_output(self, output: str, vlan_id: str) -> bool:
        """Parse raw switchport output"""
        output_lower = output.lower()
        
        if "trunking" in output_lower:
            if "vlans allowed: all" in output_lower:
                return True
            if f"vlans allowed: {vlan_id}" in output_lower:
                return True
        
        return False

    def _check_allowed_vlans(self, switchport_data: Dict, vlan_id: str) -> bool:
        """Check if VLAN is in allowed VLAN list"""
        for field in ['trunking_vlans', 'vlans_allowed', 'allowed_vlans']:
            vlans = switchport_data.get(field, '')
            
            if vlans:
                if vlans.upper() == 'ALL':
                    return True
                if self._is_vlan_in_list(vlans, vlan_id):
                    return True
        
        return False

    def _check_trunk_config(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check trunk configuration in running config"""
        try:
            command = f"show running-config interface {interface}"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                enable=True
            )
            
            config = result.result.lower()
            
            # If trunk mode is configured but no allowed VLAN restrictions, assume all VLANs allowed
            if "switchport mode trunk" in config and "switchport trunk allowed vlan" not in config:
                return True
            
            # Check specific VLAN allowances
            if f"switchport trunk allowed vlan add {vlan_id}" in config:
                return True
            
            return False
            
        except Exception as e:
            logger.debug(f"Trunk config check failed: {str(e)}")
            
        return False

    def _is_vlan_in_list(self, vlan_str: str, target_vlan: str) -> bool:
        """Helper to safely parse VLAN lists (1,5,10-20,30)"""
        try:
            if not vlan_str:
                return False
                
            target_int = int(target_vlan)
            
            for part in str(vlan_str).split(','):
                part = part.strip()
                
                if '-' in part:
                    # Handle range (e.g., "10-20")
                    start, end = map(int, part.split('-'))
                    if start <= target_int <= end:
                        return True
                elif part.isdigit() and int(part) == target_int:
                    return True
                    
            return False
            
        except (ValueError, AttributeError) as e:
            logger.error(f"VLAN list parsing failed: {str(e)}")
            return False

    def trace_path_to_router(self, start_device: str) -> List[str]:
        """Trace path from edge switch to router using LLDP with improved logic"""
        logger.info("Starting path trace to router...")
        
        path = []
        current_device = start_device
        visited: Set[str] = set()
        
        # Get target router
        try:
            target_router = self.nr.inventory.hosts[start_device].data.get('router')
            if not target_router:
                logger.error(f"No router defined for {start_device}")
                return []
        except KeyError:
            logger.error(f"Device {start_device} not found in inventory")
            return []

        logger.info(f"Target router: {target_router}")

        while current_device and current_device not in visited and len(path) < self.max_hops:
            visited.add(current_device)
            path.append(current_device)
            
            logger.debug(f"Current device: {current_device}")
            logger.debug(f"Current path: {' -> '.join(path)}")
            
            # Check if we've reached the target router
            if current_device == target_router:
                logger.info(f"Reached target router: {current_device}")
                break
            
            # Get neighbors and find next hop
            next_hop = self._find_next_hop(current_device, target_router, visited)
            if not next_hop:
                logger.warning(f"No valid next hop found from {current_device}")
                break
                
            current_device = next_hop

        # Ensure router is in path
        if path and path[-1] != target_router:
            path.append(target_router)
            logger.debug(f"Added router {target_router} to path")

        logger.info(f"Final path: {' -> '.join(path)}")
        return path

    def _find_next_hop(self, current_device: str, target_router: str, visited: Set[str]) -> Optional[str]:
        """Find the next hop in the path"""
        try:
            neighbors_result = self.nr.filter(name=current_device).run(task=self.get_lldp_neighbors)
            neighbors = neighbors_result[current_device].result
            
            if not neighbors:
                logger.debug(f"No neighbors found for {current_device}")
                return None
            
            # Find unvisited neighbors
            possible_hops = []
            for neighbor in (neighbors if isinstance(neighbors, list) else [neighbors]):
                if isinstance(neighbor, dict):
                    neighbor_ip = self._extract_neighbor_ip(neighbor)
                    
                    if neighbor_ip and neighbor_ip not in visited:
                        # Try to resolve to inventory hostname
                        resolved_ip = self._resolve_neighbor_ip(neighbor_ip)
                        if resolved_ip:
                            possible_hops.append(resolved_ip)
            
            if not possible_hops:
                return None
            
            # Prioritize direct connection to router
            if target_router in possible_hops:
                return target_router
            
            # Prioritize devices that have the target router configured
            for hop in possible_hops:
                try:
                    if self.nr.inventory.hosts[hop].data.get('router') == target_router:
                        return hop
                except KeyError:
                    continue
            
            # Return first available hop
            return possible_hops[0]
            
        except Exception as e:
            logger.error(f"Error finding next hop from {current_device}: {str(e)}")
            return None

    def _extract_neighbor_ip(self, neighbor: Dict) -> Optional[str]:
        """Extract neighbor IP from LLDP data"""
        neighbor_ip = (neighbor.get('mgmt_address') or 
                      neighbor.get('neighbor') or 
                      neighbor.get('neighbor_name') or
                      neighbor.get('system_name'))
        
        if neighbor_ip and '.' not in neighbor_ip:
            # Handle hostname format
            neighbor_ip = neighbor_ip.split('.')[0]
        
        return neighbor_ip

    def _resolve_neighbor_ip(self, neighbor_ip: str) -> Optional[str]:
        """Resolve neighbor IP to inventory hostname"""
        # Direct match
        if neighbor_ip in self.nr.inventory.hosts:
            return neighbor_ip
        
        # Hostname match
        for hostname, host in self.nr.inventory.hosts.items():
            if (host.get('hostname', '') == neighbor_ip or 
                hostname.startswith(neighbor_ip)):
                return hostname
        
        return None

    def verify_vlan_path(self, initial_switch: str, target_port: str, vlan_id: str) -> Tuple[bool, str, List[str], Dict[str, DeviceResult]]:
        """Comprehensive VLAN path verification"""
        logger.info("Starting VLAN path verification")
        
        # Trace path
        path = self.trace_path_to_router(initial_switch)
        if not path:
            return False, "No path found to router", [], {}

        # Verify each device in path
        results = {}
        overall_success = True
        failure_reasons = []
        
        for i, device_ip in enumerate(path):
            logger.info(f"Verifying device {i+1}/{len(path)}: {device_ip}")
            
            result = DeviceResult(device_ip=device_ip, vlan_status="Unknown")
            
            # Check VLAN exists
            vlan_exists = self.nr.filter(name=device_ip).run(
                task=self.verify_vlan_exists,
                vlan_id=vlan_id
            )[device_ip].result
            
            if vlan_exists:
                result.vlan_status = "VLAN exists"
                logger.debug(f"VLAN {vlan_id} exists on {device_ip}")
            else:
                result.vlan_status = "VLAN missing"
                result.overall_status = VerificationStatus.FAIL
                overall_success = False
                failure_reasons.append(f"VLAN {vlan_id} missing on {device_ip}")
                logger.warning(f"VLAN {vlan_id} missing on {device_ip}")
            
            # First device: check access port
            if i == 0:
                access_ok = self.nr.filter(name=device_ip).run(
                    task=self.verify_access_vlan,
                    interface=target_port,
                    vlan_id=vlan_id
                )[device_ip].result
                
                if access_ok:
                    result.port_status = "Access port configured"
                    logger.debug(f"Access port {target_port} configured on {device_ip}")
                else:
                    result.port_status = f"Port {target_port} not in VLAN {vlan_id}"
                    result.overall_status = VerificationStatus.FAIL
                    overall_success = False
                    failure_reasons.append(f"Port {target_port} not in VLAN {vlan_id}")
                    logger.warning(f"Port {target_port} not in VLAN {vlan_id}")
            
            # Intermediate devices: check trunk ports
            elif i < len(path) - 1:
                next_device = path[i + 1]
                uplink_port = self.nr.filter(name=device_ip).run(
                    task=self.find_uplink_port,
                    neighbor_ip=next_device
                )[device_ip].result
                
                if uplink_port:
                    trunk_ok = self.nr.filter(name=device_ip).run(
                        task=self.verify_trunk_vlan,
                        interface=uplink_port,
                        vlan_id=vlan_id
                    )[device_ip].result
                    
                    if trunk_ok:
                        result.trunk_status = f"Trunk {uplink_port} allows VLAN"
                        logger.debug(f"Trunk {uplink_port} allows VLAN {vlan_id}")
                    else:
                        result.trunk_status = f"VLAN {vlan_id} blocked on {uplink_port}"
                        result.overall_status = VerificationStatus.FAIL
                        overall_success = False
                        failure_reasons.append(f"VLAN {vlan_id} blocked on {uplink_port}")
                        logger.warning(f"VLAN {vlan_id} blocked on {uplink_port}")
                else:
                    result.trunk_status = f"No uplink found to {next_device}"
                    result.overall_status = VerificationStatus.FAIL
                    overall_success = False
                    failure_reasons.append(f"No uplink found to {next_device}")
                    logger.warning(f"No uplink found to {next_device}")
            
            # Router endpoint
            else:
                result.role = "Router endpoint"
                logger.debug(f"Router endpoint: {device_ip}")
            
            # Set overall status if not already failed
            if result.overall_status == VerificationStatus.UNKNOWN:
                result.overall_status = VerificationStatus.PASS
            
            results[device_ip] = result

        # Generate summary message
        if overall_success:
            message = f"VLAN {vlan_id} path fully verified"
        else:
            message = f"VLAN path verification failed: {'; '.join(failure_reasons[:3])}"
        
        logger.info(f"Verification complete: {message}")
        return overall_success, message, path, results

    def visualize_path(self, path: List[str], verification_results: Dict[str, DeviceResult]):
        """Create enhanced visualization of the network path"""
        plt.ioff()
        fig, ax = plt.subplots(figsize=(18, 12))
        
        # Create graph
        G = nx.path_graph(path)
        
        # Position nodes
        pos = {node: (i * 3, 0) for i, node in enumerate(G.nodes())}
        
        # Prepare node colors and labels
        node_colors = []
        node_labels = {}
        status_labels = {}
        
        for node in G.nodes():
            result = verification_results.get(node)
            if not result:
                node_colors.append("gray")
                status_labels[node] = "No data"
                continue
            
            # Determine color based on status
            if result.overall_status == VerificationStatus.PASS:
                node_colors.append("lightgreen")
                status = "✓ PASS"
            elif result.overall_status == VerificationStatus.FAIL:
                node_colors.append("red")
                status = "✗ FAIL"
            else:
                node_colors.append("gray")
                status = "? UNKNOWN"
            
            # Create node label
            node_labels[node] = node
            
            # Create status label
            status_lines = [f"Status: {status}"]
            
            if result.vlan_status:
                status_lines.append(f"VLAN: {result.vlan_status}")
            
            if result.port_status:
                status_lines.append(f"Port: {result.port_status}")
            
            if result.trunk_status:
                status_lines.append(f"Trunk: {result.trunk_status}")
            
            if result.role:
                status_lines.append(f"Role: {result.role}")
            
            status_labels[node] = "\n".join(status_lines[:4])  # Limit to 4 lines
        
        # Draw network graph
        nx.draw_networkx_nodes(G, pos, node_color=node_colors, node_size=5000, 
                              edgecolors='black', linewidths=2)
        nx.draw_networkx_edges(G, pos, width=3, edge_color='steelblue', 
                              arrows=True, arrowstyle='-|>', arrowsize=30)
        
        # Add device labels (above nodes)
        name_pos = {k: (v[0], v[1] + 0.8) for k, v in pos.items()}
        nx.draw_networkx_labels(G, name_pos, labels=node_labels, font_size=10, 
                               font_weight="bold")
        
        # Add status labels (below nodes)
        status_pos = {k: (v[0], v[1] - 1.2) for k, v in pos.items()}
        nx.draw_networkx_labels(G, status_pos, labels=status_labels, font_size=8,
                               bbox=dict(facecolor='white', edgecolor='black',
                                       boxstyle='round,pad=0.5', alpha=0.9))
        
        # Add legend
        legend_elements = [
            plt.Line2D([0], [0], marker='o', color='w', label='Pass', 
                      markerfacecolor='lightgreen', markersize=15),
            plt.Line2D([0], [0], marker='o', color='w', label='Fail', 
                      markerfacecolor='red', markersize=15),
            plt.Line2D([0], [0], marker='o', color='w', label='Unknown', 
                      markerfacecolor='gray', markersize=15)
        ]
        
        plt.legend(handles=legend_elements, loc='upper right', fontsize=12, 
                  title="Verification Status", title_fontsize=14)
        
        plt.title("Network VLAN Path Verification Results", pad=40, fontsize=18, 
                 fontweight='bold')
        plt.axis('off')
        plt.tight_layout()
        plt.show(block=True)
        plt.ion()


def main():
    """Main function to run VLAN path verification"""
    # Configuration
    initial_switch = "172.17.57.243"
    target_port = "GigabitEthernet1/0/10"
    vlan_id = "5"
    
    # Create verifier instance
    verifier = NetworkVerifier(config_file="config.yaml")
    
    try:
        # Run verification
        success, message, path, results = verifier.verify_vlan_path(
            initial_switch, target_port, vlan_id
        )
        
        # Print results
        print("\n" + "="*60)
        print(f"VLAN PATH VERIFICATION {'SUCCEEDED' if success else 'FAILED'}")
        print("="*60)
        print(f"Initial Switch: {initial_switch}")
        print(f"Target Port: {target_port}")
        print(f"VLAN ID: {vlan_id}")
        print(f"Path: {' → '.join(path)}")
        print(f"Status: {message}")
        print("="*60)
        
        # Detailed results
        print("\nDETAILED RESULTS:")
        print("-" * 40)
        for device_ip, result in results.items():
            print(f"\nDevice: {device_ip}")
            print(f"  Overall Status: {result.overall_status.value.upper()}")
            print(f"  VLAN Status: {result.vlan_status}")
            if result.port_status:
                print(f"  Port Status: {result.port_status}")
            if result.trunk_status:
                print(f"  Trunk Status: {result.trunk_status}")
            if result.role:
                print(f"  Role: {result.role}")
        
        # Show visualization
        if path and results:
            print("\nGenerating network visualization...")
            verifier.visualize_path(path, results)
        
        return success
        
    except Exception as e:
        logger.error(f"Verification failed with error: {str(e)}")
        print(f"\nERROR: Verification failed - {str(e)}")
        return False
    
    finally:
        # Cleanup
        if hasattr(verifier, 'nr') and verifier.nr:
            verifier.nr.close_connections()


if __name__ == "__main__":
    import sys
    
    # Allow command line arguments
    if len(sys.argv) >= 4:
        initial_switch = sys.argv[1]
        target_port = sys.argv[2]
        vlan_id = sys.argv[3]
        
        verifier = NetworkVerifier()
        success, message, path, results = verifier.verify_vlan_path(
            initial_switch, target_port, vlan_id
        )
        
        if success:
            print(f"✓ VLAN {vlan_id} path verification successful")
            sys.exit(0)
        else:
            print(f"✗ VLAN {vlan_id} path verification failed: {message}")
            sys.exit(1)
    else:
        # Use default configuration
        success = main()
        sys.exit(0 if success else 1)
from nornir import InitNornir
from nornir_netmiko import netmiko_send_command
from nornir.core.task import Task, Result
from typing import Dict, List, Tuple, Optional, Set
import networkx as nx
import matplotlib.pyplot as plt
import re
import logging
from dataclasses import dataclass
from enum import Enum

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class VerificationStatus(Enum):
    PASS = "pass"
    FAIL = "fail"
    UNKNOWN = "unknown"

@dataclass
class DeviceResult:
    device_ip: str
    vlan_status: str
    port_status: Optional[str] = None
    trunk_status: Optional[str] = None
    role: Optional[str] = None
    overall_status: VerificationStatus = VerificationStatus.UNKNOWN

class NetworkVerifier:
    def __init__(self, config_file: str = "config.yaml"):
        self.nr = InitNornir(config_file=config_file)
        self.max_hops = 15
        
    def get_lldp_neighbors(self, task: Task) -> List[Dict]:
        """Collect LLDP neighbor information in a vendor-neutral way"""
        platform = task.host.platform
        
        # Enhanced command mapping for different platforms
        command_map = {
            "aruba_cx": "show lldp neighbors detail",
            "cisco_ios": "show lldp neighbors detail",
            "cisco_xe": "show lldp neighbors detail",
            "hp_comware": "display lldp neighbor-information",
            "juniper": "show lldp neighbors detail"
        }
        
        command = command_map.get(platform, "show lldp neighbors detail")
        
        logger.debug(f"Running on {task.host}: {command}")
        
        try:
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            # Handle different result types
            if isinstance(result.result, str):
                logger.warning(f"TextFSM parsing failed for {task.host}, attempting manual parsing")
                return self._parse_lldp_manually(result.result, platform)
            elif isinstance(result.result, dict):
                return [result.result]
            elif isinstance(result.result, list):
                return result.result
            else:
                logger.warning(f"No LLDP neighbors found on {task.host}")
                return []
                
        except Exception as e:
            logger.error(f"Error getting LLDP neighbors on {task.host}: {str(e)}")
            return []

    def _parse_lldp_manually(self, output: str, platform: str) -> List[Dict]:
        """Manual parsing fallback for when TextFSM fails"""
        neighbors = []
        
        try:
            # Basic regex patterns for common LLDP output formats
            if platform == "cisco_ios":
                # Cisco IOS LLDP format
                pattern = r'Device ID: (\S+).*?Local Intf: (\S+).*?Port id: (\S+)'
                matches = re.findall(pattern, output, re.DOTALL)
                
                for match in matches:
                    neighbors.append({
                        'neighbor': match[0],
                        'local_interface': match[1],
                        'neighbor_port': match[2]
                    })
            
            # Add more platform-specific parsing as needed
            
        except Exception as e:
            logger.error(f"Manual LLDP parsing failed: {str(e)}")
            
        return neighbors

    def find_uplink_port(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find the local interface connected to a neighbor with improved error handling"""
        platform = task.host.platform
        
        try:
            # Try LLDP first (most reliable)
            lldp_result = self._find_port_via_lldp(task, neighbor_ip, platform)
            if lldp_result:
                return lldp_result
            
            # Fall back to CDP for Cisco devices
            if platform.startswith("cisco"):
                cdp_result = self._find_port_via_cdp(task, neighbor_ip)
                if cdp_result:
                    return cdp_result
                    
            # Last resort: MAC address table lookup
            mac_result = self._find_port_via_mac(task, neighbor_ip)
            if mac_result:
                return mac_result
                
        except Exception as e:
            logger.error(f"Error finding uplink port on {task.host}: {str(e)}")
        
        return None

    def _find_port_via_lldp(self, task: Task, neighbor_ip: str, platform: str) -> Optional[str]:
        """Find port using LLDP"""
        try:
            neighbors = self.get_lldp_neighbors(task)
            
            for neighbor in neighbors:
                # Check multiple possible neighbor identifier fields
                neighbor_id = (neighbor.get('neighbor') or 
                             neighbor.get('mgmt_address') or 
                             neighbor.get('system_name'))
                
                if neighbor_id and (neighbor_id == neighbor_ip or 
                                  neighbor_id.startswith(neighbor_ip.split('.')[0])):
                    return neighbor.get('local_interface')
                    
        except Exception as e:
            logger.debug(f"LLDP port lookup failed: {str(e)}")
            
        return None

    def _find_port_via_cdp(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find port using CDP (Cisco devices)"""
        try:
            command = "show cdp neighbors detail"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if result.result:
                for neighbor in (result.result if isinstance(result.result, list) else [result.result]):
                    if neighbor.get('mgmt_address') == neighbor_ip:
                        return neighbor.get('local_port')
                        
        except Exception as e:
            logger.debug(f"CDP port lookup failed: {str(e)}")
            
        return None

    def _find_port_via_mac(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find port using MAC address table (least reliable)"""
        try:
            # This would require ARP table lookup first, then MAC table
            # Implementation depends on specific requirements
            pass
        except Exception as e:
            logger.debug(f"MAC table port lookup failed: {str(e)}")
            
        return None

    def verify_vlan_exists(self, task: Task, vlan_id: str) -> bool:
        """Check if VLAN exists with enhanced platform support"""
        platform = task.host.platform
        
        command_map = {
            "aruba_cx": f"show vlan {vlan_id}",
            "cisco_ios": f"show vlan id {vlan_id}",
            "cisco_xe": f"show vlan id {vlan_id}",
            "hp_comware": f"display vlan {vlan_id}",
            "juniper": f"show vlans {vlan_id}"
        }
        
        command = command_map.get(platform, f"show vlan id {vlan_id}")
        
        try:
            logger.debug(f"Running on {task.host}: {command}")
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if isinstance(result.result, str):
                # Check for common error messages
                error_indicators = ["invalid", "not found", "does not exist", "error"]
                return not any(indicator in result.result.lower() for indicator in error_indicators)
            
            return bool(result.result)
            
        except Exception as e:
            logger.error(f"Error checking VLAN on {task.host}: {str(e)}")
            return False

    def verify_access_vlan(self, task: Task, interface: str, vlan_id: str) -> bool:
        """Verify access port VLAN configuration with better error handling"""
        platform = task.host.platform
        
        try:
            # Method 1: Check VLAN membership
            if self._check_vlan_membership(task, interface, vlan_id, platform):
                return True
            
            # Method 2: Check interface configuration
            if self._check_interface_config(task, interface, vlan_id, platform):
                return True
            
            logger.debug(f"Access VLAN {vlan_id} not found on {interface}")
            return False
            
        except Exception as e:
            logger.error(f"Error checking access port on {task.host}: {str(e)}")
            return False

    def _check_vlan_membership(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check VLAN membership tables"""
        try:
            command_map = {
                "aruba_cx": f"show vlan {vlan_id}",
                "cisco_ios": f"show vlan id {vlan_id}",
                "cisco_xe": f"show vlan id {vlan_id}",
            }
            
            command = command_map.get(platform, f"show vlan id {vlan_id}")
            
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if result.result:
                for vlan in (result.result if isinstance(result.result, list) else [result.result]):
                    interfaces = vlan.get('interfaces', [])
                    if isinstance(interfaces, str):
                        interfaces = [interfaces]
                    
                    # Normalize interface names for comparison
                    normalized_interfaces = [self._normalize_interface_name(intf) for intf in interfaces]
                    normalized_target = self._normalize_interface_name(interface)
                    
                    if normalized_target in normalized_interfaces:
                        return True
                        
        except Exception as e:
            logger.debug(f"VLAN membership check failed: {str(e)}")
            
        return False

    def _check_interface_config(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check interface running configuration"""
        try:
            command = f"show running-config interface {interface}"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=False,
                enable=True
            )
            
            config = result.result.lower()
            
            # Platform-specific config patterns
            patterns = {
                "aruba_cx": [f"vlan access {vlan_id}"],
                "cisco_ios": [f"switchport access vlan {vlan_id}"],
                "cisco_xe": [f"switchport access vlan {vlan_id}"],
            }
            
            check_patterns = patterns.get(platform, [f"switchport access vlan {vlan_id}"])
            
            return any(pattern in config for pattern in check_patterns)
            
        except Exception as e:
            logger.debug(f"Interface config check failed: {str(e)}")
            
        return False

    def _normalize_interface_name(self, interface: str) -> str:
        """Normalize interface names for comparison"""
        # Handle common abbreviations
        interface = interface.replace("GigabitEthernet", "Gi")
        interface = interface.replace("FastEthernet", "Fa")
        interface = interface.replace("TenGigabitEthernet", "Te")
        
        # Remove spaces and convert to lowercase
        return interface.replace(" ", "").lower()

    def verify_trunk_vlan(self, task: Task, interface: str, vlan_id: str) -> bool:
        """Verify trunk allows the VLAN with comprehensive checking"""
        platform = task.host.platform
        
        try:
            # Method 1: Check switchport status
            if self._check_switchport_trunk(task, interface, vlan_id, platform):
                return True
            
            # Method 2: Check running configuration
            if self._check_trunk_config(task, interface, vlan_id, platform):
                return True
            
            return False
            
        except Exception as e:
            logger.error(f"Error checking trunk on {task.host}: {str(e)}")
            return False

    def _check_switchport_trunk(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check switchport trunk status"""
        try:
            command = f"show interfaces {interface} switchport"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if isinstance(result.result, str):
                # Parse raw output
                return self._parse_trunk_raw_output(result.result, vlan_id)
            
            if result.result and isinstance(result.result, list):
                sw_data = result.result[0]
                
                # Check if port is in trunk mode
                if sw_data.get('mode', '').lower() != 'trunk':
                    return False
                
                # Check allowed VLANs
                return self._check_allowed_vlans(sw_data, vlan_id)
                
        except Exception as e:
            logger.debug(f"Switchport trunk check failed: {str(e)}")
            
        return False

    def _parse_trunk_raw_output(self, output: str, vlan_id: str) -> bool:
        """Parse raw switchport output"""
        output_lower = output.lower()
        
        if "trunking" in output_lower:
            if "vlans allowed: all" in output_lower:
                return True
            if f"vlans allowed: {vlan_id}" in output_lower:
                return True
        
        return False

    def _check_allowed_vlans(self, switchport_data: Dict, vlan_id: str) -> bool:
        """Check if VLAN is in allowed VLAN list"""
        for field in ['trunking_vlans', 'vlans_allowed', 'allowed_vlans']:
            vlans = switchport_data.get(field, '')
            
            if vlans:
                if vlans.upper() == 'ALL':
                    return True
                if self._is_vlan_in_list(vlans, vlan_id):
                    return True
        
        return False

    def _check_trunk_config(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check trunk configuration in running config"""
        try:
            command = f"show running-config interface {interface}"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                enable=True
            )
            
            config = result.result.lower()
            
            # If trunk mode is configured but no allowed VLAN restrictions, assume all VLANs allowed
            if "switchport mode trunk" in config and "switchport trunk allowed vlan" not in config:
                return True
            
            # Check specific VLAN allowances
            if f"switchport trunk allowed vlan add {vlan_id}" in config:
                return True
            
            return False
            
        except Exception as e:
            logger.debug(f"Trunk config check failed: {str(e)}")
            
        return False

    def _is_vlan_in_list(self, vlan_str: str, target_vlan: str) -> bool:
        """Helper to safely parse VLAN lists (1,5,10-20,30)"""
        try:
            if not vlan_str:
                return False
                
            target_int = int(target_vlan)
            
            for part in str(vlan_str).split(','):
                part = part.strip()
                
                if '-' in part:
                    # Handle range (e.g., "10-20")
                    start, end = map(int, part.split('-'))
                    if start <= target_int <= end:
                        return True
                elif part.isdigit() and int(part) == target_int:
                    return True
                    
            return False
            
        except (ValueError, AttributeError) as e:
            logger.error(f"VLAN list parsing failed: {str(e)}")
            return False

    def trace_path_to_router(self, start_device: str) -> List[str]:
        """Trace path from edge switch to router using LLDP with improved logic"""
        logger.info("Starting path trace to router...")
        
        path = []
        current_device = start_device
        visited: Set[str] = set()
        
        # Get target router
        try:
            target_router = self.nr.inventory.hosts[start_device].data.get('router')
            if not target_router:
                logger.error(f"No router defined for {start_device}")
                return []
        except KeyError:
            logger.error(f"Device {start_device} not found in inventory")
            return []

        logger.info(f"Target router: {target_router}")

        while current_device and current_device not in visited and len(path) < self.max_hops:
            visited.add(current_device)
            path.append(current_device)
            
            logger.debug(f"Current device: {current_device}")
            logger.debug(f"Current path: {' -> '.join(path)}")
            
            # Check if we've reached the target router
            if current_device == target_router:
                logger.info(f"Reached target router: {current_device}")
                break
            
            # Get neighbors and find next hop
            next_hop = self._find_next_hop(current_device, target_router, visited)
            if not next_hop:
                logger.warning(f"No valid next hop found from {current_device}")
                break
                
            current_device = next_hop

        # Ensure router is in path
        if path and path[-1] != target_router:
            path.append(target_router)
            logger.debug(f"Added router {target_router} to path")

        logger.info(f"Final path: {' -> '.join(path)}")
        return path

    def _find_next_hop(self, current_device: str, target_router: str, visited: Set[str]) -> Optional[str]:
        """Find the next hop in the path"""
        try:
            neighbors_result = self.nr.filter(name=current_device).run(task=self.get_lldp_neighbors)
            neighbors = neighbors_result[current_device].result
            
            if not neighbors:
                logger.debug(f"No neighbors found for {current_device}")
                return None
            
            # Find unvisited neighbors
            possible_hops = []
            for neighbor in (neighbors if isinstance(neighbors, list) else [neighbors]):
                if isinstance(neighbor, dict):
                    neighbor_ip = self._extract_neighbor_ip(neighbor)
                    
                    if neighbor_ip and neighbor_ip not in visited:
                        # Try to resolve to inventory hostname
                        resolved_ip = self._resolve_neighbor_ip(neighbor_ip)
                        if resolved_ip:
                            possible_hops.append(resolved_ip)
            
            if not possible_hops:
                return None
            
            # Prioritize direct connection to router
            if target_router in possible_hops:
                return target_router
            
            # Prioritize devices that have the target router configured
            for hop in possible_hops:
                try:
                    if self.nr.inventory.hosts[hop].data.get('router') == target_router:
                        return hop
                except KeyError:
                    continue
            
            # Return first available hop
            return possible_hops[0]
            
        except Exception as e:
            logger.error(f"Error finding next hop from {current_device}: {str(e)}")
            return None

    def _extract_neighbor_ip(self, neighbor: Dict) -> Optional[str]:
        """Extract neighbor IP from LLDP data"""
        neighbor_ip = (neighbor.get('mgmt_address') or 
                      neighbor.get('neighbor') or 
                      neighbor.get('neighbor_name') or
                      neighbor.get('system_name'))
        
        if neighbor_ip and '.' not in neighbor_ip:
            # Handle hostname format
            neighbor_ip = neighbor_ip.split('.')[0]
        
        return neighbor_ip

    def _resolve_neighbor_ip(self, neighbor_ip: str) -> Optional[str]:
        """Resolve neighbor IP to inventory hostname"""
        # Direct match
        if neighbor_ip in self.nr.inventory.hosts:
            return neighbor_ip
        
        # Hostname match
        for hostname, host in self.nr.inventory.hosts.items():
            if (host.get('hostname', '') == neighbor_ip or 
                hostname.startswith(neighbor_ip)):
                return hostname
        
        return None

    def verify_vlan_path(self, initial_switch: str, target_port: str, vlan_id: str) -> Tuple[bool, str, List[str], Dict[str, DeviceResult]]:
        """Comprehensive VLAN path verification"""
        logger.info("Starting VLAN path verification")
        
        # Trace path
        path = self.trace_path_to_router(initial_switch)
        if not path:
            return False, "No path found to router", [], {}

        # Verify each device in path
        results = {}
        overall_success = True
        failure_reasons = []
        
        for i, device_ip in enumerate(path):
            logger.info(f"Verifying device {i+1}/{len(path)}: {device_ip}")
            
            result = DeviceResult(device_ip=device_ip, vlan_status="Unknown")
            
            # Check VLAN exists
            vlan_exists = self.nr.filter(name=device_ip).run(
                task=self.verify_vlan_exists,
                vlan_id=vlan_id
            )[device_ip].result
            
            if vlan_exists:
                result.vlan_status = "VLAN exists"
                logger.debug(f"VLAN {vlan_id} exists on {device_ip}")
            else:
                result.vlan_status = "VLAN missing"
                result.overall_status = VerificationStatus.FAIL
                overall_success = False
                failure_reasons.append(f"VLAN {vlan_id} missing on {device_ip}")
                logger.warning(f"VLAN {vlan_id} missing on {device_ip}")
            
            # First device: check access port
            if i == 0:
                access_ok = self.nr.filter(name=device_ip).run(
                    task=self.verify_access_vlan,
                    interface=target_port,
                    vlan_id=vlan_id
                )[device_ip].result
                
                if access_ok:
                    result.port_status = "Access port configured"
                    logger.debug(f"Access port {target_port} configured on {device_ip}")
                else:
                    result.port_status = f"Port {target_port} not in VLAN {vlan_id}"
                    result.overall_status = VerificationStatus.FAIL
                    overall_success = False
                    failure_reasons.append(f"Port {target_port} not in VLAN {vlan_id}")
                    logger.warning(f"Port {target_port} not in VLAN {vlan_id}")
            
            # Intermediate devices: check trunk ports
            elif i < len(path) - 1:
                next_device = path[i + 1]
                uplink_port = self.nr.filter(name=device_ip).run(
                    task=self.find_uplink_port,
                    neighbor_ip=next_device
                )[device_ip].result
                
                if uplink_port:
                    trunk_ok = self.nr.filter(name=device_ip).run(
                        task=self.verify_trunk_vlan,
                        interface=uplink_port,
                        vlan_id=vlan_id
                    )[device_ip].result
                    
                    if trunk_ok:
                        result.trunk_status = f"Trunk {uplink_port} allows VLAN"
                        logger.debug(f"Trunk {uplink_port} allows VLAN {vlan_id}")
                    else:
                        result.trunk_status = f"VLAN {vlan_id} blocked on {uplink_port}"
                        result.overall_status = VerificationStatus.FAIL
                        overall_success = False
                        failure_reasons.append(f"VLAN {vlan_id} blocked on {uplink_port}")
                        logger.warning(f"VLAN {vlan_id} blocked on {uplink_port}")
                else:
                    result.trunk_status = f"No uplink found to {next_device}"
                    result.overall_status = VerificationStatus.FAIL
                    overall_success = False
                    failure_reasons.append(f"No uplink found to {next_device}")
                    logger.warning(f"No uplink found to {next_device}")
            
            # Router endpoint
            else:
                result.role = "Router endpoint"
                logger.debug(f"Router endpoint: {device_ip}")
            
            # Set overall status if not already failed
            if result.overall_status == VerificationStatus.UNKNOWN:
                result.overall_status = VerificationStatus.PASS
            
            results[device_ip] = result

        # Generate summary message
        if overall_success:
            message = f"VLAN {vlan_id} path fully verified"
        else:
            message = f"VLAN path verification failed: {'; '.join(failure_reasons[:3])}"
        
        logger.info(f"Verification complete: {message}")
        return overall_success, message, path, results

    def visualize_path(self, path: List[str], verification_results: Dict[str, DeviceResult]):
        """Create enhanced visualization of the network path"""
        plt.ioff()
        fig, ax = plt.subplots(figsize=(18, 12))
        
        # Create graph
        G = nx.path_graph(path)
        
        # Position nodes
        pos = {node: (i * 3, 0) for i, node in enumerate(G.nodes())}
        
        # Prepare node colors and labels
        node_colors = []
        node_labels = {}
        status_labels = {}
        
        for node in G.nodes():
            result = verification_results.get(node)
            if not result:
                node_colors.append("gray")
                status_labels[node] = "No data"
                continue
            
            # Determine color based on status
            if result.overall_status == VerificationStatus.PASS:
                node_colors.append("lightgreen")
                status = "✓ PASS"
            elif result.overall_status == VerificationStatus.FAIL:
                node_colors.append("red")
                status = "✗ FAIL"
            else:
                node_colors.append("gray")
                status = "? UNKNOWN"
            
            # Create node label
            node_labels[node] = node
            
            # Create status label
            status_lines = [f"Status: {status}"]
            
            if result.vlan_status:
                status_lines.append(f"VLAN: {result.vlan_status}")
            
            if result.port_status:
                status_lines.append(f"Port: {result.port_status}")
            
            if result.trunk_status:
                status_lines.append(f"Trunk: {result.trunk_status}")
            
            if result.role:
                status_lines.append(f"Role: {result.role}")
            
            status_labels[node] = "\n".join(status_lines[:4])  # Limit to 4 lines
        
        # Draw network graph
        nx.draw_networkx_nodes(G, pos, node_color=node_colors, node_size=5000, 
                              edgecolors='black', linewidths=2)
        nx.draw_networkx_edges(G, pos, width=3, edge_color='steelblue', 
                              arrows=True, arrowstyle='-|>', arrowsize=30)
        
        # Add device labels (above nodes)
        name_pos = {k: (v[0], v[1] + 0.8) for k, v in pos.items()}
        nx.draw_networkx_labels(G, name_pos, labels=node_labels, font_size=10, 
                               font_weight="bold")
        
        # Add status labels (below nodes)
        status_pos = {k: (v[0], v[1] - 1.2) for k, v in pos.items()}
        nx.draw_networkx_labels(G, status_pos, labels=status_labels, font_size=8,
                               bbox=dict(facecolor='white', edgecolor='black',
                                       boxstyle='round,pad=0.5', alpha=0.9))
        
        # Add legend
        legend_elements = [
            plt.Line2D([0], [0], marker='o', color='w', label='Pass', 
                      markerfacecolor='lightgreen', markersize=15),
            plt.Line2D([0], [0], marker='o', color='w', label='Fail', 
                      markerfacecolor='red', markersize=15),
            plt.Line2D([0], [0], marker='o', color='w', label='Unknown', 
                      markerfacecolor='gray', markersize=15)
        ]
        
        plt.legend(handles=legend_elements, loc='upper right', fontsize=12, 
                  title="Verification Status", title_fontsize=14)
        
        plt.title("Network VLAN Path Verification Results", pad=40, fontsize=18, 
                 fontweight='bold')
        plt.axis('off')
        plt.tight_layout()
        plt.show(block=True)
        plt.ion()


def main():
    """Main function to run VLAN path verification"""
    # Configuration
    initial_switch = "172.17.57.243"
    target_port = "GigabitEthernet1/0/10"
    vlan_id = "5"
    
    # Create verifier instance
    verifier = NetworkVerifier(config_file="config.yaml")
    
    try:
        # Run verification
        success, message, path, results = verifier.verify_vlan_path(
            initial_switch, target_port, vlan_id
        )
        
        # Print results
        print("\n" + "="*60)
        print(f"VLAN PATH VERIFICATION {'SUCCEEDED' if success else 'FAILED'}")
        print("="*60)
        print(f"Initial Switch: {initial_switch}")
        print(f"Target Port: {target_port}")
        print(f"VLAN ID: {vlan_id}")
        print(f"Path: {' → '.join(path)}")
        print(f"Status: {message}")
        print("="*60)
        
        # Detailed results
        print("\nDETAILED RESULTS:")
        print("-" * 40)
        for device_ip, result in results.items():
            print(f"\nDevice: {device_ip}")
            print(f"  Overall Status: {result.overall_status.value.upper()}")
            print(f"  VLAN Status: {result.vlan_status}")
            if result.port_status:
                print(f"  Port Status: {result.port_status}")
            if result.trunk_status:
                print(f"  Trunk Status: {result.trunk_status}")
            if result.role:
                print(f"  Role: {result.role}")
        
        # Show visualization
        if path and results:
            print("\nGenerating network visualization...")
            verifier.visualize_path(path, results)
        
        return success
        
    except Exception as e:
        logger.error(f"Verification failed with error: {str(e)}")
        print(f"\nERROR: Verification failed - {str(e)}")
        return False
    
    finally:
        # Cleanup
        if hasattr(verifier, 'nr') and verifier.nr:
            verifier.nr.close_connections()


if __name__ == "__main__":
    import sys
    
    # Allow command line arguments
    if len(sys.argv) >= 4:
        initial_switch = sys.argv[1]
        target_port = sys.argv[2]
        vlan_id = sys.argv[3]
        
        verifier = NetworkVerifier()
        success, message, path, results = verifier.verify_vlan_path(
            initial_switch, target_port, vlan_id
        )
        
        if success:
            print(f"✓ VLAN {vlan_id} path verification successful")
            sys.exit(0)
        else:
            print(f"✗ VLAN {vlan_id} path verification failed: {message}")
            sys.exit(1)
    else:
        # Use default configuration
        success = main()
        sys.exit(0 if success else 1)lk_vlan_path(start_switch, access_interface, vlan_id, target_router)
from nornir import InitNornir
from nornir_netmiko import netmiko_send_command
from nornir.core.task import Task, Result
from typing import Dict, List, Tuple, Optional, Set
import networkx as nx
import matplotlib.pyplot as plt
import re
import logging
from dataclasses import dataclass
from enum import Enum

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class VerificationStatus(Enum):
    PASS = "pass"
    FAIL = "fail"
    UNKNOWN = "unknown"

@dataclass
class DeviceResult:
    device_ip: str
    vlan_status: str
    port_status: Optional[str] = None
    trunk_status: Optional[str] = None
    role: Optional[str] = None
    overall_status: VerificationStatus = VerificationStatus.UNKNOWN

class NetworkVerifier:
    def __init__(self, config_file: str = "config.yaml"):
        self.nr = InitNornir(config_file=config_file)
        self.max_hops = 15
        
    def get_lldp_neighbors(self, task: Task) -> List[Dict]:
        """Collect LLDP neighbor information in a vendor-neutral way"""
        platform = task.host.platform
        
        # Enhanced command mapping for different platforms
        command_map = {
            "aruba_cx": "show lldp neighbors detail",
            "cisco_ios": "show lldp neighbors detail",
            "cisco_xe": "show lldp neighbors detail",
            "hp_comware": "display lldp neighbor-information",
            "juniper": "show lldp neighbors detail"
        }
        
        command = command_map.get(platform, "show lldp neighbors detail")
        
        logger.debug(f"Running on {task.host}: {command}")
        
        try:
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            # Handle different result types
            if isinstance(result.result, str):
                logger.warning(f"TextFSM parsing failed for {task.host}, attempting manual parsing")
                return self._parse_lldp_manually(result.result, platform)
            elif isinstance(result.result, dict):
                return [result.result]
            elif isinstance(result.result, list):
                return result.result
            else:
                logger.warning(f"No LLDP neighbors found on {task.host}")
                return []
                
        except Exception as e:
            logger.error(f"Error getting LLDP neighbors on {task.host}: {str(e)}")
            return []

    def _parse_lldp_manually(self, output: str, platform: str) -> List[Dict]:
        """Manual parsing fallback for when TextFSM fails"""
        neighbors = []
        
        try:
            # Basic regex patterns for common LLDP output formats
            if platform == "cisco_ios":
                # Cisco IOS LLDP format
                pattern = r'Device ID: (\S+).*?Local Intf: (\S+).*?Port id: (\S+)'
                matches = re.findall(pattern, output, re.DOTALL)
                
                for match in matches:
                    neighbors.append({
                        'neighbor': match[0],
                        'local_interface': match[1],
                        'neighbor_port': match[2]
                    })
            
            # Add more platform-specific parsing as needed
            
        except Exception as e:
            logger.error(f"Manual LLDP parsing failed: {str(e)}")
            
        return neighbors

    def find_uplink_port(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find the local interface connected to a neighbor with improved error handling"""
        platform = task.host.platform
        
        try:
            # Try LLDP first (most reliable)
            lldp_result = self._find_port_via_lldp(task, neighbor_ip, platform)
            if lldp_result:
                return lldp_result
            
            # Fall back to CDP for Cisco devices
            if platform.startswith("cisco"):
                cdp_result = self._find_port_via_cdp(task, neighbor_ip)
                if cdp_result:
                    return cdp_result
                    
            # Last resort: MAC address table lookup
            mac_result = self._find_port_via_mac(task, neighbor_ip)
            if mac_result:
                return mac_result
                
        except Exception as e:
            logger.error(f"Error finding uplink port on {task.host}: {str(e)}")
        
        return None

    def _find_port_via_lldp(self, task: Task, neighbor_ip: str, platform: str) -> Optional[str]:
        """Find port using LLDP"""
        try:
            neighbors = self.get_lldp_neighbors(task)
            
            for neighbor in neighbors:
                # Check multiple possible neighbor identifier fields
                neighbor_id = (neighbor.get('neighbor') or 
                             neighbor.get('mgmt_address') or 
                             neighbor.get('system_name'))
                
                if neighbor_id and (neighbor_id == neighbor_ip or 
                                  neighbor_id.startswith(neighbor_ip.split('.')[0])):
                    return neighbor.get('local_interface')
                    
        except Exception as e:
            logger.debug(f"LLDP port lookup failed: {str(e)}")
            
        return None

    def _find_port_via_cdp(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find port using CDP (Cisco devices)"""
        try:
            command = "show cdp neighbors detail"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if result.result:
                for neighbor in (result.result if isinstance(result.result, list) else [result.result]):
                    if neighbor.get('mgmt_address') == neighbor_ip:
                        return neighbor.get('local_port')
                        
        except Exception as e:
            logger.debug(f"CDP port lookup failed: {str(e)}")
            
        return None

    def _find_port_via_mac(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find port using MAC address table (least reliable)"""
        try:
            # This would require ARP table lookup first, then MAC table
            # Implementation depends on specific requirements
            pass
        except Exception as e:
            logger.debug(f"MAC table port lookup failed: {str(e)}")
            
        return None

    def verify_vlan_exists(self, task: Task, vlan_id: str) -> bool:
        """Check if VLAN exists with enhanced platform support"""
        platform = task.host.platform
        
        command_map = {
            "aruba_cx": f"show vlan {vlan_id}",
            "cisco_ios": f"show vlan id {vlan_id}",
            "cisco_xe": f"show vlan id {vlan_id}",
            "hp_comware": f"display vlan {vlan_id}",
            "juniper": f"show vlans {vlan_id}"
        }
        
        command = command_map.get(platform, f"show vlan id {vlan_id}")
        
        try:
            logger.debug(f"Running on {task.host}: {command}")
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if isinstance(result.result, str):
                # Check for common error messages
                error_indicators = ["invalid", "not found", "does not exist", "error"]
                return not any(indicator in result.result.lower() for indicator in error_indicators)
            
            return bool(result.result)
            
        except Exception as e:
            logger.error(f"Error checking VLAN on {task.host}: {str(e)}")
            return False

    def verify_access_vlan(self, task: Task, interface: str, vlan_id: str) -> bool:
        """Verify access port VLAN configuration with better error handling"""
        platform = task.host.platform
        
        try:
            # Method 1: Check VLAN membership
            if self._check_vlan_membership(task, interface, vlan_id, platform):
                return True
            
            # Method 2: Check interface configuration
            if self._check_interface_config(task, interface, vlan_id, platform):
                return True
            
            logger.debug(f"Access VLAN {vlan_id} not found on {interface}")
            return False
            
        except Exception as e:
            logger.error(f"Error checking access port on {task.host}: {str(e)}")
            return False

    def _check_vlan_membership(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check VLAN membership tables"""
        try:
            command_map = {
                "aruba_cx": f"show vlan {vlan_id}",
                "cisco_ios": f"show vlan id {vlan_id}",
                "cisco_xe": f"show vlan id {vlan_id}",
            }
            
            command = command_map.get(platform, f"show vlan id {vlan_id}")
            
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if result.result:
                for vlan in (result.result if isinstance(result.result, list) else [result.result]):
                    interfaces = vlan.get('interfaces', [])
                    if isinstance(interfaces, str):
                        interfaces = [interfaces]
                    
                    # Normalize interface names for comparison
                    normalized_interfaces = [self._normalize_interface_name(intf) for intf in interfaces]
                    normalized_target = self._normalize_interface_name(interface)
                    
                    if normalized_target in normalized_interfaces:
                        return True
                        
        except Exception as e:
            logger.debug(f"VLAN membership check failed: {str(e)}")
            
        return False

    def _check_interface_config(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check interface running configuration"""
        try:
            command = f"show running-config interface {interface}"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=False,
                enable=True
            )
            
            config = result.result.lower()
            
            # Platform-specific config patterns
            patterns = {
                "aruba_cx": [f"vlan access {vlan_id}"],
                "cisco_ios": [f"switchport access vlan {vlan_id}"],
                "cisco_xe": [f"switchport access vlan {vlan_id}"],
            }
            
            check_patterns = patterns.get(platform, [f"switchport access vlan {vlan_id}"])
            
            return any(pattern in config for pattern in check_patterns)
            
        except Exception as e:
            logger.debug(f"Interface config check failed: {str(e)}")
            
        return False

    def _normalize_interface_name(self, interface: str) -> str:
        """Normalize interface names for comparison"""
        # Handle common abbreviations
        interface = interface.replace("GigabitEthernet", "Gi")
        interface = interface.replace("FastEthernet", "Fa")
        interface = interface.replace("TenGigabitEthernet", "Te")
        
        # Remove spaces and convert to lowercase
        return interface.replace(" ", "").lower()

    def verify_trunk_vlan(self, task: Task, interface: str, vlan_id: str) -> bool:
        """Verify trunk allows the VLAN with comprehensive checking"""
        platform = task.host.platform
        
        try:
            # Method 1: Check switchport status
            if self._check_switchport_trunk(task, interface, vlan_id, platform):
                return True
            
            # Method 2: Check running configuration
            if self._check_trunk_config(task, interface, vlan_id, platform):
                return True
            
            return False
            
        except Exception as e:
            logger.error(f"Error checking trunk on {task.host}: {str(e)}")
            return False

    def _check_switchport_trunk(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check switchport trunk status"""
        try:
            command = f"show interfaces {interface} switchport"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if isinstance(result.result, str):
                # Parse raw output
                return self._parse_trunk_raw_output(result.result, vlan_id)
            
            if result.result and isinstance(result.result, list):
                sw_data = result.result[0]
                
                # Check if port is in trunk mode
                if sw_data.get('mode', '').lower() != 'trunk':
                    return False
                
                # Check allowed VLANs
                return self._check_allowed_vlans(sw_data, vlan_id)
                
        except Exception as e:
            logger.debug(f"Switchport trunk check failed: {str(e)}")
            
        return False

    def _parse_trunk_raw_output(self, output: str, vlan_id: str) -> bool:
        """Parse raw switchport output"""
        output_lower = output.lower()
        
        if "trunking" in output_lower:
            if "vlans allowed: all" in output_lower:
                return True
            if f"vlans allowed: {vlan_id}" in output_lower:
                return True
        
        return False

    def _check_allowed_vlans(self, switchport_data: Dict, vlan_id: str) -> bool:
        """Check if VLAN is in allowed VLAN list"""
        for field in ['trunking_vlans', 'vlans_allowed', 'allowed_vlans']:
            vlans = switchport_data.get(field, '')
            
            if vlans:
                if vlans.upper() == 'ALL':
                    return True
                if self._is_vlan_in_list(vlans, vlan_id):
                    return True
        
        return False

    def _check_trunk_config(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check trunk configuration in running config"""
        try:
            command = f"show running-config interface {interface}"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                enable=True
            )
            
            config = result.result.lower()
            
            # If trunk mode is configured but no allowed VLAN restrictions, assume all VLANs allowed
            if "switchport mode trunk" in config and "switchport trunk allowed vlan" not in config:
                return True
            
            # Check specific VLAN allowances
            if f"switchport trunk allowed vlan add {vlan_id}" in config:
                return True
            
            return False
            
        except Exception as e:
            logger.debug(f"Trunk config check failed: {str(e)}")
            
        return False

    def _is_vlan_in_list(self, vlan_str: str, target_vlan: str) -> bool:
        """Helper to safely parse VLAN lists (1,5,10-20,30)"""
        try:
            if not vlan_str:
                return False
                
            target_int = int(target_vlan)
            
            for part in str(vlan_str).split(','):
                part = part.strip()
                
                if '-' in part:
                    # Handle range (e.g., "10-20")
                    start, end = map(int, part.split('-'))
                    if start <= target_int <= end:
                        return True
                elif part.isdigit() and int(part) == target_int:
                    return True
                    
            return False
            
        except (ValueError, AttributeError) as e:
            logger.error(f"VLAN list parsing failed: {str(e)}")
            return False

    def trace_path_to_router(self, start_device: str) -> List[str]:
        """Trace path from edge switch to router using LLDP with improved logic"""
        logger.info("Starting path trace to router...")
        
        path = []
        current_device = start_device
        visited: Set[str] = set()
        
        # Get target router
        try:
            target_router = self.nr.inventory.hosts[start_device].data.get('router')
            if not target_router:
                logger.error(f"No router defined for {start_device}")
                return []
        except KeyError:
            logger.error(f"Device {start_device} not found in inventory")
            return []

        logger.info(f"Target router: {target_router}")

        while current_device and current_device not in visited and len(path) < self.max_hops:
            visited.add(current_device)
            path.append(current_device)
            
            logger.debug(f"Current device: {current_device}")
            logger.debug(f"Current path: {' -> '.join(path)}")
            
            # Check if we've reached the target router
            if current_device == target_router:
                logger.info(f"Reached target router: {current_device}")
                break
            
            # Get neighbors and find next hop
            next_hop = self._find_next_hop(current_device, target_router, visited)
            if not next_hop:
                logger.warning(f"No valid next hop found from {current_device}")
                break
                
            current_device = next_hop

        # Ensure router is in path
        if path and path[-1] != target_router:
            path.append(target_router)
            logger.debug(f"Added router {target_router} to path")

        logger.info(f"Final path: {' -> '.join(path)}")
        return path

    def _find_next_hop(self, current_device: str, target_router: str, visited: Set[str]) -> Optional[str]:
        """Find the next hop in the path"""
        try:
            neighbors_result = self.nr.filter(name=current_device).run(task=self.get_lldp_neighbors)
            neighbors = neighbors_result[current_device].result
            
            if not neighbors:
                logger.debug(f"No neighbors found for {current_device}")
                return None
            
            # Find unvisited neighbors
            possible_hops = []
            for neighbor in (neighbors if isinstance(neighbors, list) else [neighbors]):
                if isinstance(neighbor, dict):
                    neighbor_ip = self._extract_neighbor_ip(neighbor)
                    
                    if neighbor_ip and neighbor_ip not in visited:
                        # Try to resolve to inventory hostname
                        resolved_ip = self._resolve_neighbor_ip(neighbor_ip)
                        if resolved_ip:
                            possible_hops.append(resolved_ip)
            
            if not possible_hops:
                return None
            
            # Prioritize direct connection to router
            if target_router in possible_hops:
                return target_router
            
            # Prioritize devices that have the target router configured
            for hop in possible_hops:
                try:
                    if self.nr.inventory.hosts[hop].data.get('router') == target_router:
                        return hop
                except KeyError:
                    continue
            
            # Return first available hop
            return possible_hops[0]
            
        except Exception as e:
            logger.error(f"Error finding next hop from {current_device}: {str(e)}")
            return None

    def _extract_neighbor_ip(self, neighbor: Dict) -> Optional[str]:
        """Extract neighbor IP from LLDP data"""
        neighbor_ip = (neighbor.get('mgmt_address') or 
                      neighbor.get('neighbor') or 
                      neighbor.get('neighbor_name') or
                      neighbor.get('system_name'))
        
        if neighbor_ip and '.' not in neighbor_ip:
            # Handle hostname format
            neighbor_ip = neighbor_ip.split('.')[0]
        
        return neighbor_ip

    def _resolve_neighbor_ip(self, neighbor_ip: str) -> Optional[str]:
        """Resolve neighbor IP to inventory hostname"""
        # Direct match
        if neighbor_ip in self.nr.inventory.hosts:
            return neighbor_ip
        
        # Hostname match
        for hostname, host in self.nr.inventory.hosts.items():
            if (host.get('hostname', '') == neighbor_ip or 
                hostname.startswith(neighbor_ip)):
                return hostname
        
        return None

    def verify_vlan_path(self, initial_switch: str, target_port: str, vlan_id: str) -> Tuple[bool, str, List[str], Dict[str, DeviceResult]]:
        """Comprehensive VLAN path verification"""
        logger.info("Starting VLAN path verification")
        
        # Trace path
        path = self.trace_path_to_router(initial_switch)
        if not path:
            return False, "No path found to router", [], {}

        # Verify each device in path
        results = {}
        overall_success = True
        failure_reasons = []
        
        for i, device_ip in enumerate(path):
            logger.info(f"Verifying device {i+1}/{len(path)}: {device_ip}")
            
            result = DeviceResult(device_ip=device_ip, vlan_status="Unknown")
            
            # Check VLAN exists
            vlan_exists = self.nr.filter(name=device_ip).run(
                task=self.verify_vlan_exists,
                vlan_id=vlan_id
            )[device_ip].result
            
            if vlan_exists:
                result.vlan_status = "VLAN exists"
                logger.debug(f"VLAN {vlan_id} exists on {device_ip}")
            else:
                result.vlan_status = "VLAN missing"
                result.overall_status = VerificationStatus.FAIL
                overall_success = False
                failure_reasons.append(f"VLAN {vlan_id} missing on {device_ip}")
                logger.warning(f"VLAN {vlan_id} missing on {device_ip}")
            
            # First device: check access port
            if i == 0:
                access_ok = self.nr.filter(name=device_ip).run(
                    task=self.verify_access_vlan,
                    interface=target_port,
                    vlan_id=vlan_id
                )[device_ip].result
                
                if access_ok:
                    result.port_status = "Access port configured"
                    logger.debug(f"Access port {target_port} configured on {device_ip}")
                else:
                    result.port_status = f"Port {target_port} not in VLAN {vlan_id}"
                    result.overall_status = VerificationStatus.FAIL
                    overall_success = False
                    failure_reasons.append(f"Port {target_port} not in VLAN {vlan_id}")
                    logger.warning(f"Port {target_port} not in VLAN {vlan_id}")
            
            # Intermediate devices: check trunk ports
            elif i < len(path) - 1:
                next_device = path[i + 1]
                uplink_port = self.nr.filter(name=device_ip).run(
                    task=self.find_uplink_port,
                    neighbor_ip=next_device
                )[device_ip].result
                
                if uplink_port:
                    trunk_ok = self.nr.filter(name=device_ip).run(
                        task=self.verify_trunk_vlan,
                        interface=uplink_port,
                        vlan_id=vlan_id
                    )[device_ip].result
                    
                    if trunk_ok:
                        result.trunk_status = f"Trunk {uplink_port} allows VLAN"
                        logger.debug(f"Trunk {uplink_port} allows VLAN {vlan_id}")
                    else:
                        result.trunk_status = f"VLAN {vlan_id} blocked on {uplink_port}"
                        result.overall_status = VerificationStatus.FAIL
                        overall_success = False
                        failure_reasons.append(f"VLAN {vlan_id} blocked on {uplink_port}")
                        logger.warning(f"VLAN {vlan_id} blocked on {uplink_port}")
                else:
                    result.trunk_status = f"No uplink found to {next_device}"
                    result.overall_status = VerificationStatus.FAIL
                    overall_success = False
                    failure_reasons.append(f"No uplink found to {next_device}")
                    logger.warning(f"No uplink found to {next_device}")
            
            # Router endpoint
            else:
                result.role = "Router endpoint"
                logger.debug(f"Router endpoint: {device_ip}")
            
            # Set overall status if not already failed
            if result.overall_status == VerificationStatus.UNKNOWN:
                result.overall_status = VerificationStatus.PASS
            
            results[device_ip] = result

        # Generate summary message
        if overall_success:
            message = f"VLAN {vlan_id} path fully verified"
        else:
            message = f"VLAN path verification failed: {'; '.join(failure_reasons[:3])}"
        
        logger.info(f"Verification complete: {message}")
        return overall_success, message, path, results

    def visualize_path(self, path: List[str], verification_results: Dict[str, DeviceResult]):
        """Create enhanced visualization of the network path"""
        plt.ioff()
        fig, ax = plt.subplots(figsize=(18, 12))
        
        # Create graph
        G = nx.path_graph(path)
        
        # Position nodes
        pos = {node: (i * 3, 0) for i, node in enumerate(G.nodes())}
        
        # Prepare node colors and labels
        node_colors = []
        node_labels = {}
        status_labels = {}
        
        for node in G.nodes():
            result = verification_results.get(node)
            if not result:
                node_colors.append("gray")
                status_labels[node] = "No data"
                continue
            
            # Determine color based on status
            if result.overall_status == VerificationStatus.PASS:
                node_colors.append("lightgreen")
                status = "✓ PASS"
            elif result.overall_status == VerificationStatus.FAIL:
                node_colors.append("red")
                status = "✗ FAIL"
            else:
                node_colors.append("gray")
                status = "? UNKNOWN"
            
            # Create node label
            node_labels[node] = node
            
            # Create status label
            status_lines = [f"Status: {status}"]
            
            if result.vlan_status:
                status_lines.append(f"VLAN: {result.vlan_status}")
            
            if result.port_status:
                status_lines.append(f"Port: {result.port_status}")
            
            if result.trunk_status:
                status_lines.append(f"Trunk: {result.trunk_status}")
            
            if result.role:
                status_lines.append(f"Role: {result.role}")
            
            status_labels[node] = "\n".join(status_lines[:4])  # Limit to 4 lines
        
        # Draw network graph
        nx.draw_networkx_nodes(G, pos, node_color=node_colors, node_size=5000, 
                              edgecolors='black', linewidths=2)
        nx.draw_networkx_edges(G, pos, width=3, edge_color='steelblue', 
                              arrows=True, arrowstyle='-|>', arrowsize=30)
        
        # Add device labels (above nodes)
        name_pos = {k: (v[0], v[1] + 0.8) for k, v in pos.items()}
        nx.draw_networkx_labels(G, name_pos, labels=node_labels, font_size=10, 
                               font_weight="bold")
        
        # Add status labels (below nodes)
        status_pos = {k: (v[0], v[1] - 1.2) for k, v in pos.items()}
        nx.draw_networkx_labels(G, status_pos, labels=status_labels, font_size=8,
                               bbox=dict(facecolor='white', edgecolor='black',
                                       boxstyle='round,pad=0.5', alpha=0.9))
        
        # Add legend
        legend_elements = [
            plt.Line2D([0], [0], marker='o', color='w', label='Pass', 
                      markerfacecolor='lightgreen', markersize=15),
            plt.Line2D([0], [0], marker='o', color='w', label='Fail', 
                      markerfacecolor='red', markersize=15),
            plt.Line2D([0], [0], marker='o', color='w', label='Unknown', 
                      markerfacecolor='gray', markersize=15)
        ]
        
        plt.legend(handles=legend_elements, loc='upper right', fontsize=12, 
                  title="Verification Status", title_fontsize=14)
        
        plt.title("Network VLAN Path Verification Results", pad=40, fontsize=18, 
                 fontweight='bold')
        plt.axis('off')
        plt.tight_layout()
        plt.show(block=True)
        plt.ion()


def main():
    """Main function to run VLAN path verification"""
    # Configuration
    initial_switch = "172.17.57.243"
    target_port = "GigabitEthernet1/0/10"
    vlan_id = "5"
    
    # Create verifier instance
    verifier = NetworkVerifier(config_file="config.yaml")
    
    try:
        # Run verification
        success, message, path, results = verifier.verify_vlan_path(
            initial_switch, target_port, vlan_id
        )
        
        # Print results
        print("\n" + "="*60)
        print(f"VLAN PATH VERIFICATION {'SUCCEEDED' if success else 'FAILED'}")
        print("="*60)
        print(f"Initial Switch: {initial_switch}")
        print(f"Target Port: {target_port}")
        print(f"VLAN ID: {vlan_id}")
        print(f"Path: {' → '.join(path)}")
        print(f"Status: {message}")
        print("="*60)
        
        # Detailed results
        print("\nDETAILED RESULTS:")
        print("-" * 40)
        for device_ip, result in results.items():
            print(f"\nDevice: {device_ip}")
            print(f"  Overall Status: {result.overall_status.value.upper()}")
            print(f"  VLAN Status: {result.vlan_status}")
            if result.port_status:
                print(f"  Port Status: {result.port_status}")
            if result.trunk_status:
                print(f"  Trunk Status: {result.trunk_status}")
            if result.role:
                print(f"  Role: {result.role}")
        
        # Show visualization
        if path and results:
            print("\nGenerating network visualization...")
            verifier.visualize_path(path, results)
        
        return success
        
    except Exception as e:
        logger.error(f"Verification failed with error: {str(e)}")
        print(f"\nERROR: Verification failed - {str(e)}")
        return False
    
    finally:
        # Cleanup
        if hasattr(verifier, 'nr') and verifier.nr:
            verifier.nr.close_connections()


if __name__ == "__main__":
    import sys
    
    # Allow command line arguments
    if len(sys.argv) >= 4:
        initial_switch = sys.argv[1]
        target_port = sys.argv[2]
        vlan_id = sys.argv[3]
        
        verifier = NetworkVerifier()
        success, message, path, results = verifier.verify_vlan_path(
            initial_switch, target_port, vlan_id
        )
        
        if success:
            print(f"✓ VLAN {vlan_id} path verification successful")
            sys.exit(0)
        else:
            print(f"✗ VLAN {vlan_id} path verification failed: {message}")
            sys.exit(1)
    else:
        # Use default configuration
        success = main()
        sys.exit(0 if success else 1)ss else "FAILURE")
from nornir import InitNornir
from nornir_netmiko import netmiko_send_command
from nornir.core.task import Task, Result
from typing import Dict, List, Tuple, Optional, Set
import networkx as nx
import matplotlib.pyplot as plt
import re
import logging
from dataclasses import dataclass
from enum import Enum

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class VerificationStatus(Enum):
    PASS = "pass"
    FAIL = "fail"
    UNKNOWN = "unknown"

@dataclass
class DeviceResult:
    device_ip: str
    vlan_status: str
    port_status: Optional[str] = None
    trunk_status: Optional[str] = None
    role: Optional[str] = None
    overall_status: VerificationStatus = VerificationStatus.UNKNOWN

class NetworkVerifier:
    def __init__(self, config_file: str = "config.yaml"):
        self.nr = InitNornir(config_file=config_file)
        self.max_hops = 15
        
    def get_lldp_neighbors(self, task: Task) -> List[Dict]:
        """Collect LLDP neighbor information in a vendor-neutral way"""
        platform = task.host.platform
        
        # Enhanced command mapping for different platforms
        command_map = {
            "aruba_cx": "show lldp neighbors detail",
            "cisco_ios": "show lldp neighbors detail",
            "cisco_xe": "show lldp neighbors detail",
            "hp_comware": "display lldp neighbor-information",
            "juniper": "show lldp neighbors detail"
        }
        
        command = command_map.get(platform, "show lldp neighbors detail")
        
        logger.debug(f"Running on {task.host}: {command}")
        
        try:
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            # Handle different result types
            if isinstance(result.result, str):
                logger.warning(f"TextFSM parsing failed for {task.host}, attempting manual parsing")
                return self._parse_lldp_manually(result.result, platform)
            elif isinstance(result.result, dict):
                return [result.result]
            elif isinstance(result.result, list):
                return result.result
            else:
                logger.warning(f"No LLDP neighbors found on {task.host}")
                return []
                
        except Exception as e:
            logger.error(f"Error getting LLDP neighbors on {task.host}: {str(e)}")
            return []

    def _parse_lldp_manually(self, output: str, platform: str) -> List[Dict]:
        """Manual parsing fallback for when TextFSM fails"""
        neighbors = []
        
        try:
            # Basic regex patterns for common LLDP output formats
            if platform == "cisco_ios":
                # Cisco IOS LLDP format
                pattern = r'Device ID: (\S+).*?Local Intf: (\S+).*?Port id: (\S+)'
                matches = re.findall(pattern, output, re.DOTALL)
                
                for match in matches:
                    neighbors.append({
                        'neighbor': match[0],
                        'local_interface': match[1],
                        'neighbor_port': match[2]
                    })
            
            # Add more platform-specific parsing as needed
            
        except Exception as e:
            logger.error(f"Manual LLDP parsing failed: {str(e)}")
            
        return neighbors

    def find_uplink_port(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find the local interface connected to a neighbor with improved error handling"""
        platform = task.host.platform
        
        try:
            # Try LLDP first (most reliable)
            lldp_result = self._find_port_via_lldp(task, neighbor_ip, platform)
            if lldp_result:
                return lldp_result
            
            # Fall back to CDP for Cisco devices
            if platform.startswith("cisco"):
                cdp_result = self._find_port_via_cdp(task, neighbor_ip)
                if cdp_result:
                    return cdp_result
                    
            # Last resort: MAC address table lookup
            mac_result = self._find_port_via_mac(task, neighbor_ip)
            if mac_result:
                return mac_result
                
        except Exception as e:
            logger.error(f"Error finding uplink port on {task.host}: {str(e)}")
        
        return None

    def _find_port_via_lldp(self, task: Task, neighbor_ip: str, platform: str) -> Optional[str]:
        """Find port using LLDP"""
        try:
            neighbors = self.get_lldp_neighbors(task)
            
            for neighbor in neighbors:
                # Check multiple possible neighbor identifier fields
                neighbor_id = (neighbor.get('neighbor') or 
                             neighbor.get('mgmt_address') or 
                             neighbor.get('system_name'))
                
                if neighbor_id and (neighbor_id == neighbor_ip or 
                                  neighbor_id.startswith(neighbor_ip.split('.')[0])):
                    return neighbor.get('local_interface')
                    
        except Exception as e:
            logger.debug(f"LLDP port lookup failed: {str(e)}")
            
        return None

    def _find_port_via_cdp(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find port using CDP (Cisco devices)"""
        try:
            command = "show cdp neighbors detail"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if result.result:
                for neighbor in (result.result if isinstance(result.result, list) else [result.result]):
                    if neighbor.get('mgmt_address') == neighbor_ip:
                        return neighbor.get('local_port')
                        
        except Exception as e:
            logger.debug(f"CDP port lookup failed: {str(e)}")
            
        return None

    def _find_port_via_mac(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find port using MAC address table (least reliable)"""
        try:
            # This would require ARP table lookup first, then MAC table
            # Implementation depends on specific requirements
            pass
        except Exception as e:
            logger.debug(f"MAC table port lookup failed: {str(e)}")
            
        return None

    def verify_vlan_exists(self, task: Task, vlan_id: str) -> bool:
        """Check if VLAN exists with enhanced platform support"""
        platform = task.host.platform
        
        command_map = {
            "aruba_cx": f"show vlan {vlan_id}",
            "cisco_ios": f"show vlan id {vlan_id}",
            "cisco_xe": f"show vlan id {vlan_id}",
            "hp_comware": f"display vlan {vlan_id}",
            "juniper": f"show vlans {vlan_id}"
        }
        
        command = command_map.get(platform, f"show vlan id {vlan_id}")
        
        try:
            logger.debug(f"Running on {task.host}: {command}")
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if isinstance(result.result, str):
                # Check for common error messages
                error_indicators = ["invalid", "not found", "does not exist", "error"]
                return not any(indicator in result.result.lower() for indicator in error_indicators)
            
            return bool(result.result)
            
        except Exception as e:
            logger.error(f"Error checking VLAN on {task.host}: {str(e)}")
            return False

    def verify_access_vlan(self, task: Task, interface: str, vlan_id: str) -> bool:
        """Verify access port VLAN configuration with better error handling"""
        platform = task.host.platform
        
        try:
            # Method 1: Check VLAN membership
            if self._check_vlan_membership(task, interface, vlan_id, platform):
                return True
            
            # Method 2: Check interface configuration
            if self._check_interface_config(task, interface, vlan_id, platform):
                return True
            
            logger.debug(f"Access VLAN {vlan_id} not found on {interface}")
            return False
            
        except Exception as e:
            logger.error(f"Error checking access port on {task.host}: {str(e)}")
            return False

    def _check_vlan_membership(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check VLAN membership tables"""
        try:
            command_map = {
                "aruba_cx": f"show vlan {vlan_id}",
                "cisco_ios": f"show vlan id {vlan_id}",
                "cisco_xe": f"show vlan id {vlan_id}",
            }
            
            command = command_map.get(platform, f"show vlan id {vlan_id}")
            
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if result.result:
                for vlan in (result.result if isinstance(result.result, list) else [result.result]):
                    interfaces = vlan.get('interfaces', [])
                    if isinstance(interfaces, str):
                        interfaces = [interfaces]
                    
                    # Normalize interface names for comparison
                    normalized_interfaces = [self._normalize_interface_name(intf) for intf in interfaces]
                    normalized_target = self._normalize_interface_name(interface)
                    
                    if normalized_target in normalized_interfaces:
                        return True
                        
        except Exception as e:
            logger.debug(f"VLAN membership check failed: {str(e)}")
            
        return False

    def _check_interface_config(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check interface running configuration"""
        try:
            command = f"show running-config interface {interface}"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=False,
                enable=True
            )
            
            config = result.result.lower()
            
            # Platform-specific config patterns
            patterns = {
                "aruba_cx": [f"vlan access {vlan_id}"],
                "cisco_ios": [f"switchport access vlan {vlan_id}"],
                "cisco_xe": [f"switchport access vlan {vlan_id}"],
            }
            
            check_patterns = patterns.get(platform, [f"switchport access vlan {vlan_id}"])
            
            return any(pattern in config for pattern in check_patterns)
            
        except Exception as e:
            logger.debug(f"Interface config check failed: {str(e)}")
            
        return False

    def _normalize_interface_name(self, interface: str) -> str:
        """Normalize interface names for comparison"""
        # Handle common abbreviations
        interface = interface.replace("GigabitEthernet", "Gi")
        interface = interface.replace("FastEthernet", "Fa")
        interface = interface.replace("TenGigabitEthernet", "Te")
        
        # Remove spaces and convert to lowercase
        return interface.replace(" ", "").lower()

    def verify_trunk_vlan(self, task: Task, interface: str, vlan_id: str) -> bool:
        """Verify trunk allows the VLAN with comprehensive checking"""
        platform = task.host.platform
        
        try:
            # Method 1: Check switchport status
            if self._check_switchport_trunk(task, interface, vlan_id, platform):
                return True
            
            # Method 2: Check running configuration
            if self._check_trunk_config(task, interface, vlan_id, platform):
                return True
            
            return False
            
        except Exception as e:
            logger.error(f"Error checking trunk on {task.host}: {str(e)}")
            return False

    def _check_switchport_trunk(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check switchport trunk status"""
        try:
            command = f"show interfaces {interface} switchport"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if isinstance(result.result, str):
                # Parse raw output
                return self._parse_trunk_raw_output(result.result, vlan_id)
            
            if result.result and isinstance(result.result, list):
                sw_data = result.result[0]
                
                # Check if port is in trunk mode
                if sw_data.get('mode', '').lower() != 'trunk':
                    return False
                
                # Check allowed VLANs
                return self._check_allowed_vlans(sw_data, vlan_id)
                
        except Exception as e:
            logger.debug(f"Switchport trunk check failed: {str(e)}")
            
        return False

    def _parse_trunk_raw_output(self, output: str, vlan_id: str) -> bool:
        """Parse raw switchport output"""
        output_lower = output.lower()
        
        if "trunking" in output_lower:
            if "vlans allowed: all" in output_lower:
                return True
            if f"vlans allowed: {vlan_id}" in output_lower:
                return True
        
        return False

    def _check_allowed_vlans(self, switchport_data: Dict, vlan_id: str) -> bool:
        """Check if VLAN is in allowed VLAN list"""
        for field in ['trunking_vlans', 'vlans_allowed', 'allowed_vlans']:
            vlans = switchport_data.get(field, '')
            
            if vlans:
                if vlans.upper() == 'ALL':
                    return True
                if self._is_vlan_in_list(vlans, vlan_id):
                    return True
        
        return False

    def _check_trunk_config(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check trunk configuration in running config"""
        try:
            command = f"show running-config interface {interface}"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                enable=True
            )
            
            config = result.result.lower()
            
            # If trunk mode is configured but no allowed VLAN restrictions, assume all VLANs allowed
            if "switchport mode trunk" in config and "switchport trunk allowed vlan" not in config:
                return True
            
            # Check specific VLAN allowances
            if f"switchport trunk allowed vlan add {vlan_id}" in config:
                return True
            
            return False
            
        except Exception as e:
            logger.debug(f"Trunk config check failed: {str(e)}")
            
        return False

    def _is_vlan_in_list(self, vlan_str: str, target_vlan: str) -> bool:
        """Helper to safely parse VLAN lists (1,5,10-20,30)"""
        try:
            if not vlan_str:
                return False
                
            target_int = int(target_vlan)
            
            for part in str(vlan_str).split(','):
                part = part.strip()
                
                if '-' in part:
                    # Handle range (e.g., "10-20")
                    start, end = map(int, part.split('-'))
                    if start <= target_int <= end:
                        return True
                elif part.isdigit() and int(part) == target_int:
                    return True
                    
            return False
            
        except (ValueError, AttributeError) as e:
            logger.error(f"VLAN list parsing failed: {str(e)}")
            return False

    def trace_path_to_router(self, start_device: str) -> List[str]:
        """Trace path from edge switch to router using LLDP with improved logic"""
        logger.info("Starting path trace to router...")
        
        path = []
        current_device = start_device
        visited: Set[str] = set()
        
        # Get target router
        try:
            target_router = self.nr.inventory.hosts[start_device].data.get('router')
            if not target_router:
                logger.error(f"No router defined for {start_device}")
                return []
        except KeyError:
            logger.error(f"Device {start_device} not found in inventory")
            return []

        logger.info(f"Target router: {target_router}")

        while current_device and current_device not in visited and len(path) < self.max_hops:
            visited.add(current_device)
            path.append(current_device)
            
            logger.debug(f"Current device: {current_device}")
            logger.debug(f"Current path: {' -> '.join(path)}")
            
            # Check if we've reached the target router
            if current_device == target_router:
                logger.info(f"Reached target router: {current_device}")
                break
            
            # Get neighbors and find next hop
            next_hop = self._find_next_hop(current_device, target_router, visited)
            if not next_hop:
                logger.warning(f"No valid next hop found from {current_device}")
                break
                
            current_device = next_hop

        # Ensure router is in path
        if path and path[-1] != target_router:
            path.append(target_router)
            logger.debug(f"Added router {target_router} to path")

        logger.info(f"Final path: {' -> '.join(path)}")
        return path

    def _find_next_hop(self, current_device: str, target_router: str, visited: Set[str]) -> Optional[str]:
        """Find the next hop in the path"""
        try:
            neighbors_result = self.nr.filter(name=current_device).run(task=self.get_lldp_neighbors)
            neighbors = neighbors_result[current_device].result
            
            if not neighbors:
                logger.debug(f"No neighbors found for {current_device}")
                return None
            
            # Find unvisited neighbors
            possible_hops = []
            for neighbor in (neighbors if isinstance(neighbors, list) else [neighbors]):
                if isinstance(neighbor, dict):
                    neighbor_ip = self._extract_neighbor_ip(neighbor)
                    
                    if neighbor_ip and neighbor_ip not in visited:
                        # Try to resolve to inventory hostname
                        resolved_ip = self._resolve_neighbor_ip(neighbor_ip)
                        if resolved_ip:
                            possible_hops.append(resolved_ip)
            
            if not possible_hops:
                return None
            
            # Prioritize direct connection to router
            if target_router in possible_hops:
                return target_router
            
            # Prioritize devices that have the target router configured
            for hop in possible_hops:
                try:
                    if self.nr.inventory.hosts[hop].data.get('router') == target_router:
                        return hop
                except KeyError:
                    continue
            
            # Return first available hop
            return possible_hops[0]
            
        except Exception as e:
            logger.error(f"Error finding next hop from {current_device}: {str(e)}")
            return None

    def _extract_neighbor_ip(self, neighbor: Dict) -> Optional[str]:
        """Extract neighbor IP from LLDP data"""
        neighbor_ip = (neighbor.get('mgmt_address') or 
                      neighbor.get('neighbor') or 
                      neighbor.get('neighbor_name') or
                      neighbor.get('system_name'))
        
        if neighbor_ip and '.' not in neighbor_ip:
            # Handle hostname format
            neighbor_ip = neighbor_ip.split('.')[0]
        
        return neighbor_ip

    def _resolve_neighbor_ip(self, neighbor_ip: str) -> Optional[str]:
        """Resolve neighbor IP to inventory hostname"""
        # Direct match
        if neighbor_ip in self.nr.inventory.hosts:
            return neighbor_ip
        
        # Hostname match
        for hostname, host in self.nr.inventory.hosts.items():
            if (host.get('hostname', '') == neighbor_ip or 
                hostname.startswith(neighbor_ip)):
                return hostname
        
        return None

    def verify_vlan_path(self, initial_switch: str, target_port: str, vlan_id: str) -> Tuple[bool, str, List[str], Dict[str, DeviceResult]]:
        """Comprehensive VLAN path verification"""
        logger.info("Starting VLAN path verification")
        
        # Trace path
        path = self.trace_path_to_router(initial_switch)
        if not path:
            return False, "No path found to router", [], {}

        # Verify each device in path
        results = {}
        overall_success = True
        failure_reasons = []
        
        for i, device_ip in enumerate(path):
            logger.info(f"Verifying device {i+1}/{len(path)}: {device_ip}")
            
            result = DeviceResult(device_ip=device_ip, vlan_status="Unknown")
            
            # Check VLAN exists
            vlan_exists = self.nr.filter(name=device_ip).run(
                task=self.verify_vlan_exists,
                vlan_id=vlan_id
            )[device_ip].result
            
            if vlan_exists:
                result.vlan_status = "VLAN exists"
                logger.debug(f"VLAN {vlan_id} exists on {device_ip}")
            else:
                result.vlan_status = "VLAN missing"
                result.overall_status = VerificationStatus.FAIL
                overall_success = False
                failure_reasons.append(f"VLAN {vlan_id} missing on {device_ip}")
                logger.warning(f"VLAN {vlan_id} missing on {device_ip}")
            
            # First device: check access port
            if i == 0:
                access_ok = self.nr.filter(name=device_ip).run(
                    task=self.verify_access_vlan,
                    interface=target_port,
                    vlan_id=vlan_id
                )[device_ip].result
                
                if access_ok:
                    result.port_status = "Access port configured"
                    logger.debug(f"Access port {target_port} configured on {device_ip}")
                else:
                    result.port_status = f"Port {target_port} not in VLAN {vlan_id}"
                    result.overall_status = VerificationStatus.FAIL
                    overall_success = False
                    failure_reasons.append(f"Port {target_port} not in VLAN {vlan_id}")
                    logger.warning(f"Port {target_port} not in VLAN {vlan_id}")
            
            # Intermediate devices: check trunk ports
            elif i < len(path) - 1:
                next_device = path[i + 1]
                uplink_port = self.nr.filter(name=device_ip).run(
                    task=self.find_uplink_port,
                    neighbor_ip=next_device
                )[device_ip].result
                
                if uplink_port:
                    trunk_ok = self.nr.filter(name=device_ip).run(
                        task=self.verify_trunk_vlan,
                        interface=uplink_port,
                        vlan_id=vlan_id
                    )[device_ip].result
                    
                    if trunk_ok:
                        result.trunk_status = f"Trunk {uplink_port} allows VLAN"
                        logger.debug(f"Trunk {uplink_port} allows VLAN {vlan_id}")
                    else:
                        result.trunk_status = f"VLAN {vlan_id} blocked on {uplink_port}"
                        result.overall_status = VerificationStatus.FAIL
                        overall_success = False
                        failure_reasons.append(f"VLAN {vlan_id} blocked on {uplink_port}")
                        logger.warning(f"VLAN {vlan_id} blocked on {uplink_port}")
                else:
                    result.trunk_status = f"No uplink found to {next_device}"
                    result.overall_status = VerificationStatus.FAIL
                    overall_success = False
                    failure_reasons.append(f"No uplink found to {next_device}")
                    logger.warning(f"No uplink found to {next_device}")
            
            # Router endpoint
            else:
                result.role = "Router endpoint"
                logger.debug(f"Router endpoint: {device_ip}")
            
            # Set overall status if not already failed
            if result.overall_status == VerificationStatus.UNKNOWN:
                result.overall_status = VerificationStatus.PASS
            
            results[device_ip] = result

        # Generate summary message
        if overall_success:
            message = f"VLAN {vlan_id} path fully verified"
        else:
            message = f"VLAN path verification failed: {'; '.join(failure_reasons[:3])}"
        
        logger.info(f"Verification complete: {message}")
        return overall_success, message, path, results

    def visualize_path(self, path: List[str], verification_results: Dict[str, DeviceResult]):
        """Create enhanced visualization of the network path"""
        plt.ioff()
        fig, ax = plt.subplots(figsize=(18, 12))
        
        # Create graph
        G = nx.path_graph(path)
        
        # Position nodes
        pos = {node: (i * 3, 0) for i, node in enumerate(G.nodes())}
        
        # Prepare node colors and labels
        node_colors = []
        node_labels = {}
        status_labels = {}
        
        for node in G.nodes():
            result = verification_results.get(node)
            if not result:
                node_colors.append("gray")
                status_labels[node] = "No data"
                continue
            
            # Determine color based on status
            if result.overall_status == VerificationStatus.PASS:
                node_colors.append("lightgreen")
                status = "✓ PASS"
            elif result.overall_status == VerificationStatus.FAIL:
                node_colors.append("red")
                status = "✗ FAIL"
            else:
                node_colors.append("gray")
                status = "? UNKNOWN"
            
            # Create node label
            node_labels[node] = node
            
            # Create status label
            status_lines = [f"Status: {status}"]
            
            if result.vlan_status:
                status_lines.append(f"VLAN: {result.vlan_status}")
            
            if result.port_status:
                status_lines.append(f"Port: {result.port_status}")
            
            if result.trunk_status:
                status_lines.append(f"Trunk: {result.trunk_status}")
            
            if result.role:
                status_lines.append(f"Role: {result.role}")
            
            status_labels[node] = "\n".join(status_lines[:4])  # Limit to 4 lines
        
        # Draw network graph
        nx.draw_networkx_nodes(G, pos, node_color=node_colors, node_size=5000, 
                              edgecolors='black', linewidths=2)
        nx.draw_networkx_edges(G, pos, width=3, edge_color='steelblue', 
                              arrows=True, arrowstyle='-|>', arrowsize=30)
        
        # Add device labels (above nodes)
        name_pos = {k: (v[0], v[1] + 0.8) for k, v in pos.items()}
        nx.draw_networkx_labels(G, name_pos, labels=node_labels, font_size=10, 
                               font_weight="bold")
        
        # Add status labels (below nodes)
        status_pos = {k: (v[0], v[1] - 1.2) for k, v in pos.items()}
        nx.draw_networkx_labels(G, status_pos, labels=status_labels, font_size=8,
                               bbox=dict(facecolor='white', edgecolor='black',
                                       boxstyle='round,pad=0.5', alpha=0.9))
        
        # Add legend
        legend_elements = [
            plt.Line2D([0], [0], marker='o', color='w', label='Pass', 
                      markerfacecolor='lightgreen', markersize=15),
            plt.Line2D([0], [0], marker='o', color='w', label='Fail', 
                      markerfacecolor='red', markersize=15),
            plt.Line2D([0], [0], marker='o', color='w', label='Unknown', 
                      markerfacecolor='gray', markersize=15)
        ]
        
        plt.legend(handles=legend_elements, loc='upper right', fontsize=12, 
                  title="Verification Status", title_fontsize=14)
        
        plt.title("Network VLAN Path Verification Results", pad=40, fontsize=18, 
                 fontweight='bold')
        plt.axis('off')
        plt.tight_layout()
        plt.show(block=True)
        plt.ion()


def main():
    """Main function to run VLAN path verification"""
    # Configuration
    initial_switch = "172.17.57.243"
    target_port = "GigabitEthernet1/0/10"
    vlan_id = "5"
    
    # Create verifier instance
    verifier = NetworkVerifier(config_file="config.yaml")
    
    try:
        # Run verification
        success, message, path, results = verifier.verify_vlan_path(
            initial_switch, target_port, vlan_id
        )
        
        # Print results
        print("\n" + "="*60)
        print(f"VLAN PATH VERIFICATION {'SUCCEEDED' if success else 'FAILED'}")
        print("="*60)
        print(f"Initial Switch: {initial_switch}")
        print(f"Target Port: {target_port}")
        print(f"VLAN ID: {vlan_id}")
        print(f"Path: {' → '.join(path)}")
        print(f"Status: {message}")
        print("="*60)
        
        # Detailed results
        print("\nDETAILED RESULTS:")
        print("-" * 40)
        for device_ip, result in results.items():
            print(f"\nDevice: {device_ip}")
            print(f"  Overall Status: {result.overall_status.value.upper()}")
            print(f"  VLAN Status: {result.vlan_status}")
            if result.port_status:
                print(f"  Port Status: {result.port_status}")
            if result.trunk_status:
                print(f"  Trunk Status: {result.trunk_status}")
            if result.role:
                print(f"  Role: {result.role}")
        
        # Show visualization
        if path and results:
            print("\nGenerating network visualization...")
            verifier.visualize_path(path, results)
        
        return success
        
    except Exception as e:
        logger.error(f"Verification failed with error: {str(e)}")
        print(f"\nERROR: Verification failed - {str(e)}")
        return False
    
    finally:
        # Cleanup
        if hasattr(verifier, 'nr') and verifier.nr:
            verifier.nr.close_connections()


if __name__ == "__main__":
    import sys
    
    # Allow command line arguments
    if len(sys.argv) >= 4:
        initial_switch = sys.argv[1]
        target_port = sys.argv[2]
        vlan_id = sys.argv[3]
        
        verifier = NetworkVerifier()
        success, message, path, results = verifier.verify_vlan_path(
            initial_switch, target_port, vlan_id
        )
        
        if success:
            print(f"✓ VLAN {vlan_id} path verification successful")
            sys.exit(0)
        else:
            print(f"✗ VLAN {vlan_id} path verification failed: {message}")
            sys.exit(1)
    else:
        # Use default configuration
        success = main()
        sys.exit(0 if success else 1)
from nornir import InitNornir
from nornir_netmiko import netmiko_send_command
from nornir.core.task import Task, Result
from typing import Dict, List, Tuple, Optional, Set
import networkx as nx
import matplotlib.pyplot as plt
import re
import logging
from dataclasses import dataclass
from enum import Enum

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class VerificationStatus(Enum):
    PASS = "pass"
    FAIL = "fail"
    UNKNOWN = "unknown"

@dataclass
class DeviceResult:
    device_ip: str
    vlan_status: str
    port_status: Optional[str] = None
    trunk_status: Optional[str] = None
    role: Optional[str] = None
    overall_status: VerificationStatus = VerificationStatus.UNKNOWN

class NetworkVerifier:
    def __init__(self, config_file: str = "config.yaml"):
        self.nr = InitNornir(config_file=config_file)
        self.max_hops = 15
        
    def get_lldp_neighbors(self, task: Task) -> List[Dict]:
        """Collect LLDP neighbor information in a vendor-neutral way"""
        platform = task.host.platform
        
        # Enhanced command mapping for different platforms
        command_map = {
            "aruba_cx": "show lldp neighbors detail",
            "cisco_ios": "show lldp neighbors detail",
            "cisco_xe": "show lldp neighbors detail",
            "hp_comware": "display lldp neighbor-information",
            "juniper": "show lldp neighbors detail"
        }
        
        command = command_map.get(platform, "show lldp neighbors detail")
        
        logger.debug(f"Running on {task.host}: {command}")
        
        try:
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            # Handle different result types
            if isinstance(result.result, str):
                logger.warning(f"TextFSM parsing failed for {task.host}, attempting manual parsing")
                return self._parse_lldp_manually(result.result, platform)
            elif isinstance(result.result, dict):
                return [result.result]
            elif isinstance(result.result, list):
                return result.result
            else:
                logger.warning(f"No LLDP neighbors found on {task.host}")
                return []
                
        except Exception as e:
            logger.error(f"Error getting LLDP neighbors on {task.host}: {str(e)}")
            return []

    def _parse_lldp_manually(self, output: str, platform: str) -> List[Dict]:
        """Manual parsing fallback for when TextFSM fails"""
        neighbors = []
        
        try:
            # Basic regex patterns for common LLDP output formats
            if platform == "cisco_ios":
                # Cisco IOS LLDP format
                pattern = r'Device ID: (\S+).*?Local Intf: (\S+).*?Port id: (\S+)'
                matches = re.findall(pattern, output, re.DOTALL)
                
                for match in matches:
                    neighbors.append({
                        'neighbor': match[0],
                        'local_interface': match[1],
                        'neighbor_port': match[2]
                    })
            
            # Add more platform-specific parsing as needed
            
        except Exception as e:
            logger.error(f"Manual LLDP parsing failed: {str(e)}")
            
        return neighbors

    def find_uplink_port(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find the local interface connected to a neighbor with improved error handling"""
        platform = task.host.platform
        
        try:
            # Try LLDP first (most reliable)
            lldp_result = self._find_port_via_lldp(task, neighbor_ip, platform)
            if lldp_result:
                return lldp_result
            
            # Fall back to CDP for Cisco devices
            if platform.startswith("cisco"):
                cdp_result = self._find_port_via_cdp(task, neighbor_ip)
                if cdp_result:
                    return cdp_result
                    
            # Last resort: MAC address table lookup
            mac_result = self._find_port_via_mac(task, neighbor_ip)
            if mac_result:
                return mac_result
                
        except Exception as e:
            logger.error(f"Error finding uplink port on {task.host}: {str(e)}")
        
        return None

    def _find_port_via_lldp(self, task: Task, neighbor_ip: str, platform: str) -> Optional[str]:
        """Find port using LLDP"""
        try:
            neighbors = self.get_lldp_neighbors(task)
            
            for neighbor in neighbors:
                # Check multiple possible neighbor identifier fields
                neighbor_id = (neighbor.get('neighbor') or 
                             neighbor.get('mgmt_address') or 
                             neighbor.get('system_name'))
                
                if neighbor_id and (neighbor_id == neighbor_ip or 
                                  neighbor_id.startswith(neighbor_ip.split('.')[0])):
                    return neighbor.get('local_interface')
                    
        except Exception as e:
            logger.debug(f"LLDP port lookup failed: {str(e)}")
            
        return None

    def _find_port_via_cdp(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find port using CDP (Cisco devices)"""
        try:
            command = "show cdp neighbors detail"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if result.result:
                for neighbor in (result.result if isinstance(result.result, list) else [result.result]):
                    if neighbor.get('mgmt_address') == neighbor_ip:
                        return neighbor.get('local_port')
                        
        except Exception as e:
            logger.debug(f"CDP port lookup failed: {str(e)}")
            
        return None

    def _find_port_via_mac(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find port using MAC address table (least reliable)"""
        try:
            # This would require ARP table lookup first, then MAC table
            # Implementation depends on specific requirements
            pass
        except Exception as e:
            logger.debug(f"MAC table port lookup failed: {str(e)}")
            
        return None

    def verify_vlan_exists(self, task: Task, vlan_id: str) -> bool:
        """Check if VLAN exists with enhanced platform support"""
        platform = task.host.platform
        
        command_map = {
            "aruba_cx": f"show vlan {vlan_id}",
            "cisco_ios": f"show vlan id {vlan_id}",
            "cisco_xe": f"show vlan id {vlan_id}",
            "hp_comware": f"display vlan {vlan_id}",
            "juniper": f"show vlans {vlan_id}"
        }
        
        command = command_map.get(platform, f"show vlan id {vlan_id}")
        
        try:
            logger.debug(f"Running on {task.host}: {command}")
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if isinstance(result.result, str):
                # Check for common error messages
                error_indicators = ["invalid", "not found", "does not exist", "error"]
                return not any(indicator in result.result.lower() for indicator in error_indicators)
            
            return bool(result.result)
            
        except Exception as e:
            logger.error(f"Error checking VLAN on {task.host}: {str(e)}")
            return False

    def verify_access_vlan(self, task: Task, interface: str, vlan_id: str) -> bool:
        """Verify access port VLAN configuration with better error handling"""
        platform = task.host.platform
        
        try:
            # Method 1: Check VLAN membership
            if self._check_vlan_membership(task, interface, vlan_id, platform):
                return True
            
            # Method 2: Check interface configuration
            if self._check_interface_config(task, interface, vlan_id, platform):
                return True
            
            logger.debug(f"Access VLAN {vlan_id} not found on {interface}")
            return False
            
        except Exception as e:
            logger.error(f"Error checking access port on {task.host}: {str(e)}")
            return False

    def _check_vlan_membership(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check VLAN membership tables"""
        try:
            command_map = {
                "aruba_cx": f"show vlan {vlan_id}",
                "cisco_ios": f"show vlan id {vlan_id}",
                "cisco_xe": f"show vlan id {vlan_id}",
            }
            
            command = command_map.get(platform, f"show vlan id {vlan_id}")
            
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if result.result:
                for vlan in (result.result if isinstance(result.result, list) else [result.result]):
                    interfaces = vlan.get('interfaces', [])
                    if isinstance(interfaces, str):
                        interfaces = [interfaces]
                    
                    # Normalize interface names for comparison
                    normalized_interfaces = [self._normalize_interface_name(intf) for intf in interfaces]
                    normalized_target = self._normalize_interface_name(interface)
                    
                    if normalized_target in normalized_interfaces:
                        return True
                        
        except Exception as e:
            logger.debug(f"VLAN membership check failed: {str(e)}")
            
        return False

    def _check_interface_config(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check interface running configuration"""
        try:
            command = f"show running-config interface {interface}"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=False,
                enable=True
            )
            
            config = result.result.lower()
            
            # Platform-specific config patterns
            patterns = {
                "aruba_cx": [f"vlan access {vlan_id}"],
                "cisco_ios": [f"switchport access vlan {vlan_id}"],
                "cisco_xe": [f"switchport access vlan {vlan_id}"],
            }
            
            check_patterns = patterns.get(platform, [f"switchport access vlan {vlan_id}"])
            
            return any(pattern in config for pattern in check_patterns)
            
        except Exception as e:
            logger.debug(f"Interface config check failed: {str(e)}")
            
        return False

    def _normalize_interface_name(self, interface: str) -> str:
        """Normalize interface names for comparison"""
        # Handle common abbreviations
        interface = interface.replace("GigabitEthernet", "Gi")
        interface = interface.replace("FastEthernet", "Fa")
        interface = interface.replace("TenGigabitEthernet", "Te")
        
        # Remove spaces and convert to lowercase
        return interface.replace(" ", "").lower()

    def verify_trunk_vlan(self, task: Task, interface: str, vlan_id: str) -> bool:
        """Verify trunk allows the VLAN with comprehensive checking"""
        platform = task.host.platform
        
        try:
            # Method 1: Check switchport status
            if self._check_switchport_trunk(task, interface, vlan_id, platform):
                return True
            
            # Method 2: Check running configuration
            if self._check_trunk_config(task, interface, vlan_id, platform):
                return True
            
            return False
            
        except Exception as e:
            logger.error(f"Error checking trunk on {task.host}: {str(e)}")
            return False

    def _check_switchport_trunk(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check switchport trunk status"""
        try:
            command = f"show interfaces {interface} switchport"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if isinstance(result.result, str):
                # Parse raw output
                return self._parse_trunk_raw_output(result.result, vlan_id)
            
            if result.result and isinstance(result.result, list):
                sw_data = result.result[0]
                
                # Check if port is in trunk mode
                if sw_data.get('mode', '').lower() != 'trunk':
                    return False
                
                # Check allowed VLANs
                return self._check_allowed_vlans(sw_data, vlan_id)
                
        except Exception as e:
            logger.debug(f"Switchport trunk check failed: {str(e)}")
            
        return False

    def _parse_trunk_raw_output(self, output: str, vlan_id: str) -> bool:
        """Parse raw switchport output"""
        output_lower = output.lower()
        
        if "trunking" in output_lower:
            if "vlans allowed: all" in output_lower:
                return True
            if f"vlans allowed: {vlan_id}" in output_lower:
                return True
        
        return False

    def _check_allowed_vlans(self, switchport_data: Dict, vlan_id: str) -> bool:
        """Check if VLAN is in allowed VLAN list"""
        for field in ['trunking_vlans', 'vlans_allowed', 'allowed_vlans']:
            vlans = switchport_data.get(field, '')
            
            if vlans:
                if vlans.upper() == 'ALL':
                    return True
                if self._is_vlan_in_list(vlans, vlan_id):
                    return True
        
        return False

    def _check_trunk_config(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check trunk configuration in running config"""
        try:
            command = f"show running-config interface {interface}"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                enable=True
            )
            
            config = result.result.lower()
            
            # If trunk mode is configured but no allowed VLAN restrictions, assume all VLANs allowed
            if "switchport mode trunk" in config and "switchport trunk allowed vlan" not in config:
                return True
            
            # Check specific VLAN allowances
            if f"switchport trunk allowed vlan add {vlan_id}" in config:
                return True
            
            return False
            
        except Exception as e:
            logger.debug(f"Trunk config check failed: {str(e)}")
            
        return False

    def _is_vlan_in_list(self, vlan_str: str, target_vlan: str) -> bool:
        """Helper to safely parse VLAN lists (1,5,10-20,30)"""
        try:
            if not vlan_str:
                return False
                
            target_int = int(target_vlan)
            
            for part in str(vlan_str).split(','):
                part = part.strip()
                
                if '-' in part:
                    # Handle range (e.g., "10-20")
                    start, end = map(int, part.split('-'))
                    if start <= target_int <= end:
                        return True
                elif part.isdigit() and int(part) == target_int:
                    return True
                    
            return False
            
        except (ValueError, AttributeError) as e:
            logger.error(f"VLAN list parsing failed: {str(e)}")
            return False

    def trace_path_to_router(self, start_device: str) -> List[str]:
        """Trace path from edge switch to router using LLDP with improved logic"""
        logger.info("Starting path trace to router...")
        
        path = []
        current_device = start_device
        visited: Set[str] = set()
        
        # Get target router
        try:
            target_router = self.nr.inventory.hosts[start_device].data.get('router')
            if not target_router:
                logger.error(f"No router defined for {start_device}")
                return []
        except KeyError:
            logger.error(f"Device {start_device} not found in inventory")
            return []

        logger.info(f"Target router: {target_router}")

        while current_device and current_device not in visited and len(path) < self.max_hops:
            visited.add(current_device)
            path.append(current_device)
            
            logger.debug(f"Current device: {current_device}")
            logger.debug(f"Current path: {' -> '.join(path)}")
            
            # Check if we've reached the target router
            if current_device == target_router:
                logger.info(f"Reached target router: {current_device}")
                break
            
            # Get neighbors and find next hop
            next_hop = self._find_next_hop(current_device, target_router, visited)
            if not next_hop:
                logger.warning(f"No valid next hop found from {current_device}")
                break
                
            current_device = next_hop

        # Ensure router is in path
        if path and path[-1] != target_router:
            path.append(target_router)
            logger.debug(f"Added router {target_router} to path")

        logger.info(f"Final path: {' -> '.join(path)}")
        return path

    def _find_next_hop(self, current_device: str, target_router: str, visited: Set[str]) -> Optional[str]:
        """Find the next hop in the path"""
        try:
            neighbors_result = self.nr.filter(name=current_device).run(task=self.get_lldp_neighbors)
            neighbors = neighbors_result[current_device].result
            
            if not neighbors:
                logger.debug(f"No neighbors found for {current_device}")
                return None
            
            # Find unvisited neighbors
            possible_hops = []
            for neighbor in (neighbors if isinstance(neighbors, list) else [neighbors]):
                if isinstance(neighbor, dict):
                    neighbor_ip = self._extract_neighbor_ip(neighbor)
                    
                    if neighbor_ip and neighbor_ip not in visited:
                        # Try to resolve to inventory hostname
                        resolved_ip = self._resolve_neighbor_ip(neighbor_ip)
                        if resolved_ip:
                            possible_hops.append(resolved_ip)
            
            if not possible_hops:
                return None
            
            # Prioritize direct connection to router
            if target_router in possible_hops:
                return target_router
            
            # Prioritize devices that have the target router configured
            for hop in possible_hops:
                try:
                    if self.nr.inventory.hosts[hop].data.get('router') == target_router:
                        return hop
                except KeyError:
                    continue
            
            # Return first available hop
            return possible_hops[0]
            
        except Exception as e:
            logger.error(f"Error finding next hop from {current_device}: {str(e)}")
            return None

    def _extract_neighbor_ip(self, neighbor: Dict) -> Optional[str]:
        """Extract neighbor IP from LLDP data"""
        neighbor_ip = (neighbor.get('mgmt_address') or 
                      neighbor.get('neighbor') or 
                      neighbor.get('neighbor_name') or
                      neighbor.get('system_name'))
        
        if neighbor_ip and '.' not in neighbor_ip:
            # Handle hostname format
            neighbor_ip = neighbor_ip.split('.')[0]
        
        return neighbor_ip

    def _resolve_neighbor_ip(self, neighbor_ip: str) -> Optional[str]:
        """Resolve neighbor IP to inventory hostname"""
        # Direct match
        if neighbor_ip in self.nr.inventory.hosts:
            return neighbor_ip
        
        # Hostname match
        for hostname, host in self.nr.inventory.hosts.items():
            if (host.get('hostname', '') == neighbor_ip or 
                hostname.startswith(neighbor_ip)):
                return hostname
        
        return None

    def verify_vlan_path(self, initial_switch: str, target_port: str, vlan_id: str) -> Tuple[bool, str, List[str], Dict[str, DeviceResult]]:
        """Comprehensive VLAN path verification"""
        logger.info("Starting VLAN path verification")
        
        # Trace path
        path = self.trace_path_to_router(initial_switch)
        if not path:
            return False, "No path found to router", [], {}

        # Verify each device in path
        results = {}
        overall_success = True
        failure_reasons = []
        
        for i, device_ip in enumerate(path):
            logger.info(f"Verifying device {i+1}/{len(path)}: {device_ip}")
            
            result = DeviceResult(device_ip=device_ip, vlan_status="Unknown")
            
            # Check VLAN exists
            vlan_exists = self.nr.filter(name=device_ip).run(
                task=self.verify_vlan_exists,
                vlan_id=vlan_id
            )[device_ip].result
            
            if vlan_exists:
                result.vlan_status = "VLAN exists"
                logger.debug(f"VLAN {vlan_id} exists on {device_ip}")
            else:
                result.vlan_status = "VLAN missing"
                result.overall_status = VerificationStatus.FAIL
                overall_success = False
                failure_reasons.append(f"VLAN {vlan_id} missing on {device_ip}")
                logger.warning(f"VLAN {vlan_id} missing on {device_ip}")
            
            # First device: check access port
            if i == 0:
                access_ok = self.nr.filter(name=device_ip).run(
                    task=self.verify_access_vlan,
                    interface=target_port,
                    vlan_id=vlan_id
                )[device_ip].result
                
                if access_ok:
                    result.port_status = "Access port configured"
                    logger.debug(f"Access port {target_port} configured on {device_ip}")
                else:
                    result.port_status = f"Port {target_port} not in VLAN {vlan_id}"
                    result.overall_status = VerificationStatus.FAIL
                    overall_success = False
                    failure_reasons.append(f"Port {target_port} not in VLAN {vlan_id}")
                    logger.warning(f"Port {target_port} not in VLAN {vlan_id}")
            
            # Intermediate devices: check trunk ports
            elif i < len(path) - 1:
                next_device = path[i + 1]
                uplink_port = self.nr.filter(name=device_ip).run(
                    task=self.find_uplink_port,
                    neighbor_ip=next_device
                )[device_ip].result
                
                if uplink_port:
                    trunk_ok = self.nr.filter(name=device_ip).run(
                        task=self.verify_trunk_vlan,
                        interface=uplink_port,
                        vlan_id=vlan_id
                    )[device_ip].result
                    
                    if trunk_ok:
                        result.trunk_status = f"Trunk {uplink_port} allows VLAN"
                        logger.debug(f"Trunk {uplink_port} allows VLAN {vlan_id}")
                    else:
                        result.trunk_status = f"VLAN {vlan_id} blocked on {uplink_port}"
                        result.overall_status = VerificationStatus.FAIL
                        overall_success = False
                        failure_reasons.append(f"VLAN {vlan_id} blocked on {uplink_port}")
                        logger.warning(f"VLAN {vlan_id} blocked on {uplink_port}")
                else:
                    result.trunk_status = f"No uplink found to {next_device}"
                    result.overall_status = VerificationStatus.FAIL
                    overall_success = False
                    failure_reasons.append(f"No uplink found to {next_device}")
                    logger.warning(f"No uplink found to {next_device}")
            
            # Router endpoint
            else:
                result.role = "Router endpoint"
                logger.debug(f"Router endpoint: {device_ip}")
            
            # Set overall status if not already failed
            if result.overall_status == VerificationStatus.UNKNOWN:
                result.overall_status = VerificationStatus.PASS
            
            results[device_ip] = result

        # Generate summary message
        if overall_success:
            message = f"VLAN {vlan_id} path fully verified"
        else:
            message = f"VLAN path verification failed: {'; '.join(failure_reasons[:3])}"
        
        logger.info(f"Verification complete: {message}")
        return overall_success, message, path, results

    def visualize_path(self, path: List[str], verification_results: Dict[str, DeviceResult]):
        """Create enhanced visualization of the network path"""
        plt.ioff()
        fig, ax = plt.subplots(figsize=(18, 12))
        
        # Create graph
        G = nx.path_graph(path)
        
        # Position nodes
        pos = {node: (i * 3, 0) for i, node in enumerate(G.nodes())}
        
        # Prepare node colors and labels
        node_colors = []
        node_labels = {}
        status_labels = {}
        
        for node in G.nodes():
            result = verification_results.get(node)
            if not result:
                node_colors.append("gray")
                status_labels[node] = "No data"
                continue
            
            # Determine color based on status
            if result.overall_status == VerificationStatus.PASS:
                node_colors.append("lightgreen")
                status = "✓ PASS"
            elif result.overall_status == VerificationStatus.FAIL:
                node_colors.append("red")
                status = "✗ FAIL"
            else:
                node_colors.append("gray")
                status = "? UNKNOWN"
            
            # Create node label
            node_labels[node] = node
            
            # Create status label
            status_lines = [f"Status: {status}"]
            
            if result.vlan_status:
                status_lines.append(f"VLAN: {result.vlan_status}")
            
            if result.port_status:
                status_lines.append(f"Port: {result.port_status}")
            
            if result.trunk_status:
                status_lines.append(f"Trunk: {result.trunk_status}")
            
            if result.role:
                status_lines.append(f"Role: {result.role}")
            
            status_labels[node] = "\n".join(status_lines[:4])  # Limit to 4 lines
        
        # Draw network graph
        nx.draw_networkx_nodes(G, pos, node_color=node_colors, node_size=5000, 
                              edgecolors='black', linewidths=2)
        nx.draw_networkx_edges(G, pos, width=3, edge_color='steelblue', 
                              arrows=True, arrowstyle='-|>', arrowsize=30)
        
        # Add device labels (above nodes)
        name_pos = {k: (v[0], v[1] + 0.8) for k, v in pos.items()}
        nx.draw_networkx_labels(G, name_pos, labels=node_labels, font_size=10, 
                               font_weight="bold")
        
        # Add status labels (below nodes)
        status_pos = {k: (v[0], v[1] - 1.2) for k, v in pos.items()}
        nx.draw_networkx_labels(G, status_pos, labels=status_labels, font_size=8,
                               bbox=dict(facecolor='white', edgecolor='black',
                                       boxstyle='round,pad=0.5', alpha=0.9))
        
        # Add legend
        legend_elements = [
            plt.Line2D([0], [0], marker='o', color='w', label='Pass', 
                      markerfacecolor='lightgreen', markersize=15),
            plt.Line2D([0], [0], marker='o', color='w', label='Fail', 
                      markerfacecolor='red', markersize=15),
            plt.Line2D([0], [0], marker='o', color='w', label='Unknown', 
                      markerfacecolor='gray', markersize=15)
        ]
        
        plt.legend(handles=legend_elements, loc='upper right', fontsize=12, 
                  title="Verification Status", title_fontsize=14)
        
        plt.title("Network VLAN Path Verification Results", pad=40, fontsize=18, 
                 fontweight='bold')
        plt.axis('off')
        plt.tight_layout()
        plt.show(block=True)
        plt.ion()


def main():
    """Main function to run VLAN path verification"""
    # Configuration
    initial_switch = "172.17.57.243"
    target_port = "GigabitEthernet1/0/10"
    vlan_id = "5"
    
    # Create verifier instance
    verifier = NetworkVerifier(config_file="config.yaml")
    
    try:
        # Run verification
        success, message, path, results = verifier.verify_vlan_path(
            initial_switch, target_port, vlan_id
        )
        
        # Print results
        print("\n" + "="*60)
        print(f"VLAN PATH VERIFICATION {'SUCCEEDED' if success else 'FAILED'}")
        print("="*60)
        print(f"Initial Switch: {initial_switch}")
        print(f"Target Port: {target_port}")
        print(f"VLAN ID: {vlan_id}")
        print(f"Path: {' → '.join(path)}")
        print(f"Status: {message}")
        print("="*60)
        
        # Detailed results
        print("\nDETAILED RESULTS:")
        print("-" * 40)
        for device_ip, result in results.items():
            print(f"\nDevice: {device_ip}")
            print(f"  Overall Status: {result.overall_status.value.upper()}")
            print(f"  VLAN Status: {result.vlan_status}")
            if result.port_status:
                print(f"  Port Status: {result.port_status}")
            if result.trunk_status:
                print(f"  Trunk Status: {result.trunk_status}")
            if result.role:
                print(f"  Role: {result.role}")
        
        # Show visualization
        if path and results:
            print("\nGenerating network visualization...")
            verifier.visualize_path(path, results)
        
        return success
        
    except Exception as e:
        logger.error(f"Verification failed with error: {str(e)}")
        print(f"\nERROR: Verification failed - {str(e)}")
        return False
    
    finally:
        # Cleanup
        if hasattr(verifier, 'nr') and verifier.nr:
            verifier.nr.close_connections()


if __name__ == "__main__":
    import sys
    
    # Allow command line arguments
    if len(sys.argv) >= 4:
        initial_switch = sys.argv[1]
        target_port = sys.argv[2]
        vlan_id = sys.argv[3]
        
        verifier = NetworkVerifier()
        success, message, path, results = verifier.verify_vlan_path(
            initial_switch, target_port, vlan_id
        )
        
        if success:
            print(f"✓ VLAN {vlan_id} path verification successful")
            sys.exit(0)
        else:
            print(f"✗ VLAN {vlan_id} path verification failed: {message}")
            sys.exit(1)
    else:
        # Use default configuration
        success = main()
        sys.exit(0 if success else 1)
from nornir import InitNornir
from nornir_netmiko import netmiko_send_command
from nornir.core.task import Task, Result
from typing import Dict, List, Tuple, Optional, Set
import networkx as nx
import matplotlib.pyplot as plt
import re
import logging
from dataclasses import dataclass
from enum import Enum

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class VerificationStatus(Enum):
    PASS = "pass"
    FAIL = "fail"
    UNKNOWN = "unknown"

@dataclass
class DeviceResult:
    device_ip: str
    vlan_status: str
    port_status: Optional[str] = None
    trunk_status: Optional[str] = None
    role: Optional[str] = None
    overall_status: VerificationStatus = VerificationStatus.UNKNOWN

class NetworkVerifier:
    def __init__(self, config_file: str = "config.yaml"):
        self.nr = InitNornir(config_file=config_file)
        self.max_hops = 15
        
    def get_lldp_neighbors(self, task: Task) -> List[Dict]:
        """Collect LLDP neighbor information in a vendor-neutral way"""
        platform = task.host.platform
        
        # Enhanced command mapping for different platforms
        command_map = {
            "aruba_cx": "show lldp neighbors detail",
            "cisco_ios": "show lldp neighbors detail",
            "cisco_xe": "show lldp neighbors detail",
            "hp_comware": "display lldp neighbor-information",
            "juniper": "show lldp neighbors detail"
        }
        
        command = command_map.get(platform, "show lldp neighbors detail")
        
        logger.debug(f"Running on {task.host}: {command}")
        
        try:
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            # Handle different result types
            if isinstance(result.result, str):
                logger.warning(f"TextFSM parsing failed for {task.host}, attempting manual parsing")
                return self._parse_lldp_manually(result.result, platform)
            elif isinstance(result.result, dict):
                return [result.result]
            elif isinstance(result.result, list):
                return result.result
            else:
                logger.warning(f"No LLDP neighbors found on {task.host}")
                return []
                
        except Exception as e:
            logger.error(f"Error getting LLDP neighbors on {task.host}: {str(e)}")
            return []

    def _parse_lldp_manually(self, output: str, platform: str) -> List[Dict]:
        """Manual parsing fallback for when TextFSM fails"""
        neighbors = []
        
        try:
            # Basic regex patterns for common LLDP output formats
            if platform == "cisco_ios":
                # Cisco IOS LLDP format
                pattern = r'Device ID: (\S+).*?Local Intf: (\S+).*?Port id: (\S+)'
                matches = re.findall(pattern, output, re.DOTALL)
                
                for match in matches:
                    neighbors.append({
                        'neighbor': match[0],
                        'local_interface': match[1],
                        'neighbor_port': match[2]
                    })
            
            # Add more platform-specific parsing as needed
            
        except Exception as e:
            logger.error(f"Manual LLDP parsing failed: {str(e)}")
            
        return neighbors

    def find_uplink_port(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find the local interface connected to a neighbor with improved error handling"""
        platform = task.host.platform
        
        try:
            # Try LLDP first (most reliable)
            lldp_result = self._find_port_via_lldp(task, neighbor_ip, platform)
            if lldp_result:
                return lldp_result
            
            # Fall back to CDP for Cisco devices
            if platform.startswith("cisco"):
                cdp_result = self._find_port_via_cdp(task, neighbor_ip)
                if cdp_result:
                    return cdp_result
                    
            # Last resort: MAC address table lookup
            mac_result = self._find_port_via_mac(task, neighbor_ip)
            if mac_result:
                return mac_result
                
        except Exception as e:
            logger.error(f"Error finding uplink port on {task.host}: {str(e)}")
        
        return None

    def _find_port_via_lldp(self, task: Task, neighbor_ip: str, platform: str) -> Optional[str]:
        """Find port using LLDP"""
        try:
            neighbors = self.get_lldp_neighbors(task)
            
            for neighbor in neighbors:
                # Check multiple possible neighbor identifier fields
                neighbor_id = (neighbor.get('neighbor') or 
                             neighbor.get('mgmt_address') or 
                             neighbor.get('system_name'))
                
                if neighbor_id and (neighbor_id == neighbor_ip or 
                                  neighbor_id.startswith(neighbor_ip.split('.')[0])):
                    return neighbor.get('local_interface')
                    
        except Exception as e:
            logger.debug(f"LLDP port lookup failed: {str(e)}")
            
        return None

    def _find_port_via_cdp(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find port using CDP (Cisco devices)"""
        try:
            command = "show cdp neighbors detail"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if result.result:
                for neighbor in (result.result if isinstance(result.result, list) else [result.result]):
                    if neighbor.get('mgmt_address') == neighbor_ip:
                        return neighbor.get('local_port')
                        
        except Exception as e:
            logger.debug(f"CDP port lookup failed: {str(e)}")
            
        return None

    def _find_port_via_mac(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find port using MAC address table (least reliable)"""
        try:
            # This would require ARP table lookup first, then MAC table
            # Implementation depends on specific requirements
            pass
        except Exception as e:
            logger.debug(f"MAC table port lookup failed: {str(e)}")
            
        return None

    def verify_vlan_exists(self, task: Task, vlan_id: str) -> bool:
        """Check if VLAN exists with enhanced platform support"""
        platform = task.host.platform
        
        command_map = {
            "aruba_cx": f"show vlan {vlan_id}",
            "cisco_ios": f"show vlan id {vlan_id}",
            "cisco_xe": f"show vlan id {vlan_id}",
            "hp_comware": f"display vlan {vlan_id}",
            "juniper": f"show vlans {vlan_id}"
        }
        
        command = command_map.get(platform, f"show vlan id {vlan_id}")
        
        try:
            logger.debug(f"Running on {task.host}: {command}")
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if isinstance(result.result, str):
                # Check for common error messages
                error_indicators = ["invalid", "not found", "does not exist", "error"]
                return not any(indicator in result.result.lower() for indicator in error_indicators)
            
            return bool(result.result)
            
        except Exception as e:
            logger.error(f"Error checking VLAN on {task.host}: {str(e)}")
            return False

    def verify_access_vlan(self, task: Task, interface: str, vlan_id: str) -> bool:
        """Verify access port VLAN configuration with better error handling"""
        platform = task.host.platform
        
        try:
            # Method 1: Check VLAN membership
            if self._check_vlan_membership(task, interface, vlan_id, platform):
                return True
            
            # Method 2: Check interface configuration
            if self._check_interface_config(task, interface, vlan_id, platform):
                return True
            
            logger.debug(f"Access VLAN {vlan_id} not found on {interface}")
            return False
            
        except Exception as e:
            logger.error(f"Error checking access port on {task.host}: {str(e)}")
            return False

    def _check_vlan_membership(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check VLAN membership tables"""
        try:
            command_map = {
                "aruba_cx": f"show vlan {vlan_id}",
                "cisco_ios": f"show vlan id {vlan_id}",
                "cisco_xe": f"show vlan id {vlan_id}",
            }
            
            command = command_map.get(platform, f"show vlan id {vlan_id}")
            
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if result.result:
                for vlan in (result.result if isinstance(result.result, list) else [result.result]):
                    interfaces = vlan.get('interfaces', [])
                    if isinstance(interfaces, str):
                        interfaces = [interfaces]
                    
                    # Normalize interface names for comparison
                    normalized_interfaces = [self._normalize_interface_name(intf) for intf in interfaces]
                    normalized_target = self._normalize_interface_name(interface)
                    
                    if normalized_target in normalized_interfaces:
                        return True
                        
        except Exception as e:
            logger.debug(f"VLAN membership check failed: {str(e)}")
            
        return False

    def _check_interface_config(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check interface running configuration"""
        try:
            command = f"show running-config interface {interface}"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=False,
                enable=True
            )
            
            config = result.result.lower()
            
            # Platform-specific config patterns
            patterns = {
                "aruba_cx": [f"vlan access {vlan_id}"],
                "cisco_ios": [f"switchport access vlan {vlan_id}"],
                "cisco_xe": [f"switchport access vlan {vlan_id}"],
            }
            
            check_patterns = patterns.get(platform, [f"switchport access vlan {vlan_id}"])
            
            return any(pattern in config for pattern in check_patterns)
            
        except Exception as e:
            logger.debug(f"Interface config check failed: {str(e)}")
            
        return False

    def _normalize_interface_name(self, interface: str) -> str:
        """Normalize interface names for comparison"""
        # Handle common abbreviations
        interface = interface.replace("GigabitEthernet", "Gi")
        interface = interface.replace("FastEthernet", "Fa")
        interface = interface.replace("TenGigabitEthernet", "Te")
        
        # Remove spaces and convert to lowercase
        return interface.replace(" ", "").lower()

    def verify_trunk_vlan(self, task: Task, interface: str, vlan_id: str) -> bool:
        """Verify trunk allows the VLAN with comprehensive checking"""
        platform = task.host.platform
        
        try:
            # Method 1: Check switchport status
            if self._check_switchport_trunk(task, interface, vlan_id, platform):
                return True
            
            # Method 2: Check running configuration
            if self._check_trunk_config(task, interface, vlan_id, platform):
                return True
            
            return False
            
        except Exception as e:
            logger.error(f"Error checking trunk on {task.host}: {str(e)}")
            return False

    def _check_switchport_trunk(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check switchport trunk status"""
        try:
            command = f"show interfaces {interface} switchport"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if isinstance(result.result, str):
                # Parse raw output
                return self._parse_trunk_raw_output(result.result, vlan_id)
            
            if result.result and isinstance(result.result, list):
                sw_data = result.result[0]
                
                # Check if port is in trunk mode
                if sw_data.get('mode', '').lower() != 'trunk':
                    return False
                
                # Check allowed VLANs
                return self._check_allowed_vlans(sw_data, vlan_id)
                
        except Exception as e:
            logger.debug(f"Switchport trunk check failed: {str(e)}")
            
        return False

    def _parse_trunk_raw_output(self, output: str, vlan_id: str) -> bool:
        """Parse raw switchport output"""
        output_lower = output.lower()
        
        if "trunking" in output_lower:
            if "vlans allowed: all" in output_lower:
                return True
            if f"vlans allowed: {vlan_id}" in output_lower:
                return True
        
        return False

    def _check_allowed_vlans(self, switchport_data: Dict, vlan_id: str) -> bool:
        """Check if VLAN is in allowed VLAN list"""
        for field in ['trunking_vlans', 'vlans_allowed', 'allowed_vlans']:
            vlans = switchport_data.get(field, '')
            
            if vlans:
                if vlans.upper() == 'ALL':
                    return True
                if self._is_vlan_in_list(vlans, vlan_id):
                    return True
        
        return False

    def _check_trunk_config(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check trunk configuration in running config"""
        try:
            command = f"show running-config interface {interface}"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                enable=True
            )
            
            config = result.result.lower()
            
            # If trunk mode is configured but no allowed VLAN restrictions, assume all VLANs allowed
            if "switchport mode trunk" in config and "switchport trunk allowed vlan" not in config:
                return True
            
            # Check specific VLAN allowances
            if f"switchport trunk allowed vlan add {vlan_id}" in config:
                return True
            
            return False
            
        except Exception as e:
            logger.debug(f"Trunk config check failed: {str(e)}")
            
        return False

    def _is_vlan_in_list(self, vlan_str: str, target_vlan: str) -> bool:
        """Helper to safely parse VLAN lists (1,5,10-20,30)"""
        try:
            if not vlan_str:
                return False
                
            target_int = int(target_vlan)
            
            for part in str(vlan_str).split(','):
                part = part.strip()
                
                if '-' in part:
                    # Handle range (e.g., "10-20")
                    start, end = map(int, part.split('-'))
                    if start <= target_int <= end:
                        return True
                elif part.isdigit() and int(part) == target_int:
                    return True
                    
            return False
            
        except (ValueError, AttributeError) as e:
            logger.error(f"VLAN list parsing failed: {str(e)}")
            return False

    def trace_path_to_router(self, start_device: str) -> List[str]:
        """Trace path from edge switch to router using LLDP with improved logic"""
        logger.info("Starting path trace to router...")
        
        path = []
        current_device = start_device
        visited: Set[str] = set()
        
        # Get target router
        try:
            target_router = self.nr.inventory.hosts[start_device].data.get('router')
            if not target_router:
                logger.error(f"No router defined for {start_device}")
                return []
        except KeyError:
            logger.error(f"Device {start_device} not found in inventory")
            return []

        logger.info(f"Target router: {target_router}")

        while current_device and current_device not in visited and len(path) < self.max_hops:
            visited.add(current_device)
            path.append(current_device)
            
            logger.debug(f"Current device: {current_device}")
            logger.debug(f"Current path: {' -> '.join(path)}")
            
            # Check if we've reached the target router
            if current_device == target_router:
                logger.info(f"Reached target router: {current_device}")
                break
            
            # Get neighbors and find next hop
            next_hop = self._find_next_hop(current_device, target_router, visited)
            if not next_hop:
                logger.warning(f"No valid next hop found from {current_device}")
                break
                
            current_device = next_hop

        # Ensure router is in path
        if path and path[-1] != target_router:
            path.append(target_router)
            logger.debug(f"Added router {target_router} to path")

        logger.info(f"Final path: {' -> '.join(path)}")
        return path

    def _find_next_hop(self, current_device: str, target_router: str, visited: Set[str]) -> Optional[str]:
        """Find the next hop in the path"""
        try:
            neighbors_result = self.nr.filter(name=current_device).run(task=self.get_lldp_neighbors)
            neighbors = neighbors_result[current_device].result
            
            if not neighbors:
                logger.debug(f"No neighbors found for {current_device}")
                return None
            
            # Find unvisited neighbors
            possible_hops = []
            for neighbor in (neighbors if isinstance(neighbors, list) else [neighbors]):
                if isinstance(neighbor, dict):
                    neighbor_ip = self._extract_neighbor_ip(neighbor)
                    
                    if neighbor_ip and neighbor_ip not in visited:
                        # Try to resolve to inventory hostname
                        resolved_ip = self._resolve_neighbor_ip(neighbor_ip)
                        if resolved_ip:
                            possible_hops.append(resolved_ip)
            
            if not possible_hops:
                return None
            
            # Prioritize direct connection to router
            if target_router in possible_hops:
                return target_router
            
            # Prioritize devices that have the target router configured
            for hop in possible_hops:
                try:
                    if self.nr.inventory.hosts[hop].data.get('router') == target_router:
                        return hop
                except KeyError:
                    continue
            
            # Return first available hop
            return possible_hops[0]
            
        except Exception as e:
            logger.error(f"Error finding next hop from {current_device}: {str(e)}")
            return None

    def _extract_neighbor_ip(self, neighbor: Dict) -> Optional[str]:
        """Extract neighbor IP from LLDP data"""
        neighbor_ip = (neighbor.get('mgmt_address') or 
                      neighbor.get('neighbor') or 
                      neighbor.get('neighbor_name') or
                      neighbor.get('system_name'))
        
        if neighbor_ip and '.' not in neighbor_ip:
            # Handle hostname format
            neighbor_ip = neighbor_ip.split('.')[0]
        
        return neighbor_ip

    def _resolve_neighbor_ip(self, neighbor_ip: str) -> Optional[str]:
        """Resolve neighbor IP to inventory hostname"""
        # Direct match
        if neighbor_ip in self.nr.inventory.hosts:
            return neighbor_ip
        
        # Hostname match
        for hostname, host in self.nr.inventory.hosts.items():
            if (host.get('hostname', '') == neighbor_ip or 
                hostname.startswith(neighbor_ip)):
                return hostname
        
        return None

    def verify_vlan_path(self, initial_switch: str, target_port: str, vlan_id: str) -> Tuple[bool, str, List[str], Dict[str, DeviceResult]]:
        """Comprehensive VLAN path verification"""
        logger.info("Starting VLAN path verification")
        
        # Trace path
        path = self.trace_path_to_router(initial_switch)
        if not path:
            return False, "No path found to router", [], {}

        # Verify each device in path
        results = {}
        overall_success = True
        failure_reasons = []
        
        for i, device_ip in enumerate(path):
            logger.info(f"Verifying device {i+1}/{len(path)}: {device_ip}")
            
            result = DeviceResult(device_ip=device_ip, vlan_status="Unknown")
            
            # Check VLAN exists
            vlan_exists = self.nr.filter(name=device_ip).run(
                task=self.verify_vlan_exists,
                vlan_id=vlan_id
            )[device_ip].result
            
            if vlan_exists:
                result.vlan_status = "VLAN exists"
                logger.debug(f"VLAN {vlan_id} exists on {device_ip}")
            else:
                result.vlan_status = "VLAN missing"
                result.overall_status = VerificationStatus.FAIL
                overall_success = False
                failure_reasons.append(f"VLAN {vlan_id} missing on {device_ip}")
                logger.warning(f"VLAN {vlan_id} missing on {device_ip}")
            
            # First device: check access port
            if i == 0:
                access_ok = self.nr.filter(name=device_ip).run(
                    task=self.verify_access_vlan,
                    interface=target_port,
                    vlan_id=vlan_id
                )[device_ip].result
                
                if access_ok:
                    result.port_status = "Access port configured"
                    logger.debug(f"Access port {target_port} configured on {device_ip}")
                else:
                    result.port_status = f"Port {target_port} not in VLAN {vlan_id}"
                    result.overall_status = VerificationStatus.FAIL
                    overall_success = False
                    failure_reasons.append(f"Port {target_port} not in VLAN {vlan_id}")
                    logger.warning(f"Port {target_port} not in VLAN {vlan_id}")
            
            # Intermediate devices: check trunk ports
            elif i < len(path) - 1:
                next_device = path[i + 1]
                uplink_port = self.nr.filter(name=device_ip).run(
                    task=self.find_uplink_port,
                    neighbor_ip=next_device
                )[device_ip].result
                
                if uplink_port:
                    trunk_ok = self.nr.filter(name=device_ip).run(
                        task=self.verify_trunk_vlan,
                        interface=uplink_port,
                        vlan_id=vlan_id
                    )[device_ip].result
                    
                    if trunk_ok:
                        result.trunk_status = f"Trunk {uplink_port} allows VLAN"
                        logger.debug(f"Trunk {uplink_port} allows VLAN {vlan_id}")
                    else:
                        result.trunk_status = f"VLAN {vlan_id} blocked on {uplink_port}"
                        result.overall_status = VerificationStatus.FAIL
                        overall_success = False
                        failure_reasons.append(f"VLAN {vlan_id} blocked on {uplink_port}")
                        logger.warning(f"VLAN {vlan_id} blocked on {uplink_port}")
                else:
                    result.trunk_status = f"No uplink found to {next_device}"
                    result.overall_status = VerificationStatus.FAIL
                    overall_success = False
                    failure_reasons.append(f"No uplink found to {next_device}")
                    logger.warning(f"No uplink found to {next_device}")
            
            # Router endpoint
            else:
                result.role = "Router endpoint"
                logger.debug(f"Router endpoint: {device_ip}")
            
            # Set overall status if not already failed
            if result.overall_status == VerificationStatus.UNKNOWN:
                result.overall_status = VerificationStatus.PASS
            
            results[device_ip] = result

        # Generate summary message
        if overall_success:
            message = f"VLAN {vlan_id} path fully verified"
        else:
            message = f"VLAN path verification failed: {'; '.join(failure_reasons[:3])}"
        
        logger.info(f"Verification complete: {message}")
        return overall_success, message, path, results

    def visualize_path(self, path: List[str], verification_results: Dict[str, DeviceResult]):
        """Create enhanced visualization of the network path"""
        plt.ioff()
        fig, ax = plt.subplots(figsize=(18, 12))
        
        # Create graph
        G = nx.path_graph(path)
        
        # Position nodes
        pos = {node: (i * 3, 0) for i, node in enumerate(G.nodes())}
        
        # Prepare node colors and labels
        node_colors = []
        node_labels = {}
        status_labels = {}
        
        for node in G.nodes():
            result = verification_results.get(node)
            if not result:
                node_colors.append("gray")
                status_labels[node] = "No data"
                continue
            
            # Determine color based on status
            if result.overall_status == VerificationStatus.PASS:
                node_colors.append("lightgreen")
                status = "✓ PASS"
            elif result.overall_status == VerificationStatus.FAIL:
                node_colors.append("red")
                status = "✗ FAIL"
            else:
                node_colors.append("gray")
                status = "? UNKNOWN"
            
            # Create node label
            node_labels[node] = node
            
            # Create status label
            status_lines = [f"Status: {status}"]
            
            if result.vlan_status:
                status_lines.append(f"VLAN: {result.vlan_status}")
            
            if result.port_status:
                status_lines.append(f"Port: {result.port_status}")
            
            if result.trunk_status:
                status_lines.append(f"Trunk: {result.trunk_status}")
            
            if result.role:
                status_lines.append(f"Role: {result.role}")
            
            status_labels[node] = "\n".join(status_lines[:4])  # Limit to 4 lines
        
        # Draw network graph
        nx.draw_networkx_nodes(G, pos, node_color=node_colors, node_size=5000, 
                              edgecolors='black', linewidths=2)
        nx.draw_networkx_edges(G, pos, width=3, edge_color='steelblue', 
                              arrows=True, arrowstyle='-|>', arrowsize=30)
        
        # Add device labels (above nodes)
        name_pos = {k: (v[0], v[1] + 0.8) for k, v in pos.items()}
        nx.draw_networkx_labels(G, name_pos, labels=node_labels, font_size=10, 
                               font_weight="bold")
        
        # Add status labels (below nodes)
        status_pos = {k: (v[0], v[1] - 1.2) for k, v in pos.items()}
        nx.draw_networkx_labels(G, status_pos, labels=status_labels, font_size=8,
                               bbox=dict(facecolor='white', edgecolor='black',
                                       boxstyle='round,pad=0.5', alpha=0.9))
        
        # Add legend
        legend_elements = [
            plt.Line2D([0], [0], marker='o', color='w', label='Pass', 
                      markerfacecolor='lightgreen', markersize=15),
            plt.Line2D([0], [0], marker='o', color='w', label='Fail', 
                      markerfacecolor='red', markersize=15),
            plt.Line2D([0], [0], marker='o', color='w', label='Unknown', 
                      markerfacecolor='gray', markersize=15)
        ]
        
        plt.legend(handles=legend_elements, loc='upper right', fontsize=12, 
                  title="Verification Status", title_fontsize=14)
        
        plt.title("Network VLAN Path Verification Results", pad=40, fontsize=18, 
                 fontweight='bold')
        plt.axis('off')
        plt.tight_layout()
        plt.show(block=True)
        plt.ion()


def main():
    """Main function to run VLAN path verification"""
    # Configuration
    initial_switch = "172.17.57.243"
    target_port = "GigabitEthernet1/0/10"
    vlan_id = "5"
    
    # Create verifier instance
    verifier = NetworkVerifier(config_file="config.yaml")
    
    try:
        # Run verification
        success, message, path, results = verifier.verify_vlan_path(
            initial_switch, target_port, vlan_id
        )
        
        # Print results
        print("\n" + "="*60)
        print(f"VLAN PATH VERIFICATION {'SUCCEEDED' if success else 'FAILED'}")
        print("="*60)
        print(f"Initial Switch: {initial_switch}")
        print(f"Target Port: {target_port}")
        print(f"VLAN ID: {vlan_id}")
        print(f"Path: {' → '.join(path)}")
        print(f"Status: {message}")
        print("="*60)
        
        # Detailed results
        print("\nDETAILED RESULTS:")
        print("-" * 40)
        for device_ip, result in results.items():
            print(f"\nDevice: {device_ip}")
            print(f"  Overall Status: {result.overall_status.value.upper()}")
            print(f"  VLAN Status: {result.vlan_status}")
            if result.port_status:
                print(f"  Port Status: {result.port_status}")
            if result.trunk_status:
                print(f"  Trunk Status: {result.trunk_status}")
            if result.role:
                print(f"  Role: {result.role}")
        
        # Show visualization
        if path and results:
            print("\nGenerating network visualization...")
            verifier.visualize_path(path, results)
        
        return success
        
    except Exception as e:
        logger.error(f"Verification failed with error: {str(e)}")
        print(f"\nERROR: Verification failed - {str(e)}")
        return False
    
    finally:
        # Cleanup
        if hasattr(verifier, 'nr') and verifier.nr:
            verifier.nr.close_connections()


if __name__ == "__main__":
    import sys
    
    # Allow command line arguments
    if len(sys.argv) >= 4:
        initial_switch = sys.argv[1]
        target_port = sys.argv[2]
        vlan_id = sys.argv[3]
        
        verifier = NetworkVerifier()
        success, message, path, results = verifier.verify_vlan_path(
            initial_switch, target_port, vlan_id
        )
        
        if success:
            print(f"✓ VLAN {vlan_id} path verification successful")
            sys.exit(0)
        else:
            print(f"✗ VLAN {vlan_id} path verification failed: {message}")
            sys.exit(1)
    else:
        # Use default configuration
        success = main()
        sys.exit(0 if success else 1)
from nornir import InitNornir
from nornir_netmiko import netmiko_send_command
from nornir.core.task import Task, Result
from typing import Dict, List, Tuple, Optional, Set
import networkx as nx
import matplotlib.pyplot as plt
import re
import logging
from dataclasses import dataclass
from enum import Enum

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class VerificationStatus(Enum):
    PASS = "pass"
    FAIL = "fail"
    UNKNOWN = "unknown"

@dataclass
class DeviceResult:
    device_ip: str
    vlan_status: str
    port_status: Optional[str] = None
    trunk_status: Optional[str] = None
    role: Optional[str] = None
    overall_status: VerificationStatus = VerificationStatus.UNKNOWN

class NetworkVerifier:
    def __init__(self, config_file: str = "config.yaml"):
        self.nr = InitNornir(config_file=config_file)
        self.max_hops = 15
        
    def get_lldp_neighbors(self, task: Task) -> List[Dict]:
        """Collect LLDP neighbor information in a vendor-neutral way"""
        platform = task.host.platform
        
        # Enhanced command mapping for different platforms
        command_map = {
            "aruba_cx": "show lldp neighbors detail",
            "cisco_ios": "show lldp neighbors detail",
            "cisco_xe": "show lldp neighbors detail",
            "hp_comware": "display lldp neighbor-information",
            "juniper": "show lldp neighbors detail"
        }
        
        command = command_map.get(platform, "show lldp neighbors detail")
        
        logger.debug(f"Running on {task.host}: {command}")
        
        try:
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            # Handle different result types
            if isinstance(result.result, str):
                logger.warning(f"TextFSM parsing failed for {task.host}, attempting manual parsing")
                return self._parse_lldp_manually(result.result, platform)
            elif isinstance(result.result, dict):
                return [result.result]
            elif isinstance(result.result, list):
                return result.result
            else:
                logger.warning(f"No LLDP neighbors found on {task.host}")
                return []
                
        except Exception as e:
            logger.error(f"Error getting LLDP neighbors on {task.host}: {str(e)}")
            return []

    def _parse_lldp_manually(self, output: str, platform: str) -> List[Dict]:
        """Manual parsing fallback for when TextFSM fails"""
        neighbors = []
        
        try:
            # Basic regex patterns for common LLDP output formats
            if platform == "cisco_ios":
                # Cisco IOS LLDP format
                pattern = r'Device ID: (\S+).*?Local Intf: (\S+).*?Port id: (\S+)'
                matches = re.findall(pattern, output, re.DOTALL)
                
                for match in matches:
                    neighbors.append({
                        'neighbor': match[0],
                        'local_interface': match[1],
                        'neighbor_port': match[2]
                    })
            
            # Add more platform-specific parsing as needed
            
        except Exception as e:
            logger.error(f"Manual LLDP parsing failed: {str(e)}")
            
        return neighbors

    def find_uplink_port(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find the local interface connected to a neighbor with improved error handling"""
        platform = task.host.platform
        
        try:
            # Try LLDP first (most reliable)
            lldp_result = self._find_port_via_lldp(task, neighbor_ip, platform)
            if lldp_result:
                return lldp_result
            
            # Fall back to CDP for Cisco devices
            if platform.startswith("cisco"):
                cdp_result = self._find_port_via_cdp(task, neighbor_ip)
                if cdp_result:
                    return cdp_result
                    
            # Last resort: MAC address table lookup
            mac_result = self._find_port_via_mac(task, neighbor_ip)
            if mac_result:
                return mac_result
                
        except Exception as e:
            logger.error(f"Error finding uplink port on {task.host}: {str(e)}")
        
        return None

    def _find_port_via_lldp(self, task: Task, neighbor_ip: str, platform: str) -> Optional[str]:
        """Find port using LLDP"""
        try:
            neighbors = self.get_lldp_neighbors(task)
            
            for neighbor in neighbors:
                # Check multiple possible neighbor identifier fields
                neighbor_id = (neighbor.get('neighbor') or 
                             neighbor.get('mgmt_address') or 
                             neighbor.get('system_name'))
                
                if neighbor_id and (neighbor_id == neighbor_ip or 
                                  neighbor_id.startswith(neighbor_ip.split('.')[0])):
                    return neighbor.get('local_interface')
                    
        except Exception as e:
            logger.debug(f"LLDP port lookup failed: {str(e)}")
            
        return None

    def _find_port_via_cdp(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find port using CDP (Cisco devices)"""
        try:
            command = "show cdp neighbors detail"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if result.result:
                for neighbor in (result.result if isinstance(result.result, list) else [result.result]):
                    if neighbor.get('mgmt_address') == neighbor_ip:
                        return neighbor.get('local_port')
                        
        except Exception as e:
            logger.debug(f"CDP port lookup failed: {str(e)}")
            
        return None

    def _find_port_via_mac(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find port using MAC address table (least reliable)"""
        try:
            # This would require ARP table lookup first, then MAC table
            # Implementation depends on specific requirements
            pass
        except Exception as e:
            logger.debug(f"MAC table port lookup failed: {str(e)}")
            
        return None

    def verify_vlan_exists(self, task: Task, vlan_id: str) -> bool:
        """Check if VLAN exists with enhanced platform support"""
        platform = task.host.platform
        
        command_map = {
            "aruba_cx": f"show vlan {vlan_id}",
            "cisco_ios": f"show vlan id {vlan_id}",
            "cisco_xe": f"show vlan id {vlan_id}",
            "hp_comware": f"display vlan {vlan_id}",
            "juniper": f"show vlans {vlan_id}"
        }
        
        command = command_map.get(platform, f"show vlan id {vlan_id}")
        
        try:
            logger.debug(f"Running on {task.host}: {command}")
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if isinstance(result.result, str):
                # Check for common error messages
                error_indicators = ["invalid", "not found", "does not exist", "error"]
                return not any(indicator in result.result.lower() for indicator in error_indicators)
            
            return bool(result.result)
            
        except Exception as e:
            logger.error(f"Error checking VLAN on {task.host}: {str(e)}")
            return False

    def verify_access_vlan(self, task: Task, interface: str, vlan_id: str) -> bool:
        """Verify access port VLAN configuration with better error handling"""
        platform = task.host.platform
        
        try:
            # Method 1: Check VLAN membership
            if self._check_vlan_membership(task, interface, vlan_id, platform):
                return True
            
            # Method 2: Check interface configuration
            if self._check_interface_config(task, interface, vlan_id, platform):
                return True
            
            logger.debug(f"Access VLAN {vlan_id} not found on {interface}")
            return False
            
        except Exception as e:
            logger.error(f"Error checking access port on {task.host}: {str(e)}")
            return False

    def _check_vlan_membership(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check VLAN membership tables"""
        try:
            command_map = {
                "aruba_cx": f"show vlan {vlan_id}",
                "cisco_ios": f"show vlan id {vlan_id}",
                "cisco_xe": f"show vlan id {vlan_id}",
            }
            
            command = command_map.get(platform, f"show vlan id {vlan_id}")
            
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if result.result:
                for vlan in (result.result if isinstance(result.result, list) else [result.result]):
                    interfaces = vlan.get('interfaces', [])
                    if isinstance(interfaces, str):
                        interfaces = [interfaces]
                    
                    # Normalize interface names for comparison
                    normalized_interfaces = [self._normalize_interface_name(intf) for intf in interfaces]
                    normalized_target = self._normalize_interface_name(interface)
                    
                    if normalized_target in normalized_interfaces:
                        return True
                        
        except Exception as e:
            logger.debug(f"VLAN membership check failed: {str(e)}")
            
        return False

    def _check_interface_config(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check interface running configuration"""
        try:
            command = f"show running-config interface {interface}"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=False,
                enable=True
            )
            
            config = result.result.lower()
            
            # Platform-specific config patterns
            patterns = {
                "aruba_cx": [f"vlan access {vlan_id}"],
                "cisco_ios": [f"switchport access vlan {vlan_id}"],
                "cisco_xe": [f"switchport access vlan {vlan_id}"],
            }
            
            check_patterns = patterns.get(platform, [f"switchport access vlan {vlan_id}"])
            
            return any(pattern in config for pattern in check_patterns)
            
        except Exception as e:
            logger.debug(f"Interface config check failed: {str(e)}")
            
        return False

    def _normalize_interface_name(self, interface: str) -> str:
        """Normalize interface names for comparison"""
        # Handle common abbreviations
        interface = interface.replace("GigabitEthernet", "Gi")
        interface = interface.replace("FastEthernet", "Fa")
        interface = interface.replace("TenGigabitEthernet", "Te")
        
        # Remove spaces and convert to lowercase
        return interface.replace(" ", "").lower()

    def verify_trunk_vlan(self, task: Task, interface: str, vlan_id: str) -> bool:
        """Verify trunk allows the VLAN with comprehensive checking"""
        platform = task.host.platform
        
        try:
            # Method 1: Check switchport status
            if self._check_switchport_trunk(task, interface, vlan_id, platform):
                return True
            
            # Method 2: Check running configuration
            if self._check_trunk_config(task, interface, vlan_id, platform):
                return True
            
            return False
            
        except Exception as e:
            logger.error(f"Error checking trunk on {task.host}: {str(e)}")
            return False

    def _check_switchport_trunk(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check switchport trunk status"""
        try:
            command = f"show interfaces {interface} switchport"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if isinstance(result.result, str):
                # Parse raw output
                return self._parse_trunk_raw_output(result.result, vlan_id)
            
            if result.result and isinstance(result.result, list):
                sw_data = result.result[0]
                
                # Check if port is in trunk mode
                if sw_data.get('mode', '').lower() != 'trunk':
                    return False
                
                # Check allowed VLANs
                return self._check_allowed_vlans(sw_data, vlan_id)
                
        except Exception as e:
            logger.debug(f"Switchport trunk check failed: {str(e)}")
            
        return False

    def _parse_trunk_raw_output(self, output: str, vlan_id: str) -> bool:
        """Parse raw switchport output"""
        output_lower = output.lower()
        
        if "trunking" in output_lower:
            if "vlans allowed: all" in output_lower:
                return True
            if f"vlans allowed: {vlan_id}" in output_lower:
                return True
        
        return False

    def _check_allowed_vlans(self, switchport_data: Dict, vlan_id: str) -> bool:
        """Check if VLAN is in allowed VLAN list"""
        for field in ['trunking_vlans', 'vlans_allowed', 'allowed_vlans']:
            vlans = switchport_data.get(field, '')
            
            if vlans:
                if vlans.upper() == 'ALL':
                    return True
                if self._is_vlan_in_list(vlans, vlan_id):
                    return True
        
        return False

    def _check_trunk_config(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check trunk configuration in running config"""
        try:
            command = f"show running-config interface {interface}"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                enable=True
            )
            
            config = result.result.lower()
            
            # If trunk mode is configured but no allowed VLAN restrictions, assume all VLANs allowed
            if "switchport mode trunk" in config and "switchport trunk allowed vlan" not in config:
                return True
            
            # Check specific VLAN allowances
            if f"switchport trunk allowed vlan add {vlan_id}" in config:
                return True
            
            return False
            
        except Exception as e:
            logger.debug(f"Trunk config check failed: {str(e)}")
            
        return False

    def _is_vlan_in_list(self, vlan_str: str, target_vlan: str) -> bool:
        """Helper to safely parse VLAN lists (1,5,10-20,30)"""
        try:
            if not vlan_str:
                return False
                
            target_int = int(target_vlan)
            
            for part in str(vlan_str).split(','):
                part = part.strip()
                
                if '-' in part:
                    # Handle range (e.g., "10-20")
                    start, end = map(int, part.split('-'))
                    if start <= target_int <= end:
                        return True
                elif part.isdigit() and int(part) == target_int:
                    return True
                    
            return False
            
        except (ValueError, AttributeError) as e:
            logger.error(f"VLAN list parsing failed: {str(e)}")
            return False

    def trace_path_to_router(self, start_device: str) -> List[str]:
        """Trace path from edge switch to router using LLDP with improved logic"""
        logger.info("Starting path trace to router...")
        
        path = []
        current_device = start_device
        visited: Set[str] = set()
        
        # Get target router
        try:
            target_router = self.nr.inventory.hosts[start_device].data.get('router')
            if not target_router:
                logger.error(f"No router defined for {start_device}")
                return []
        except KeyError:
            logger.error(f"Device {start_device} not found in inventory")
            return []

        logger.info(f"Target router: {target_router}")

        while current_device and current_device not in visited and len(path) < self.max_hops:
            visited.add(current_device)
            path.append(current_device)
            
            logger.debug(f"Current device: {current_device}")
            logger.debug(f"Current path: {' -> '.join(path)}")
            
            # Check if we've reached the target router
            if current_device == target_router:
                logger.info(f"Reached target router: {current_device}")
                break
            
            # Get neighbors and find next hop
            next_hop = self._find_next_hop(current_device, target_router, visited)
            if not next_hop:
                logger.warning(f"No valid next hop found from {current_device}")
                break
                
            current_device = next_hop

        # Ensure router is in path
        if path and path[-1] != target_router:
            path.append(target_router)
            logger.debug(f"Added router {target_router} to path")

        logger.info(f"Final path: {' -> '.join(path)}")
        return path

    def _find_next_hop(self, current_device: str, target_router: str, visited: Set[str]) -> Optional[str]:
        """Find the next hop in the path"""
        try:
            neighbors_result = self.nr.filter(name=current_device).run(task=self.get_lldp_neighbors)
            neighbors = neighbors_result[current_device].result
            
            if not neighbors:
                logger.debug(f"No neighbors found for {current_device}")
                return None
            
            # Find unvisited neighbors
            possible_hops = []
            for neighbor in (neighbors if isinstance(neighbors, list) else [neighbors]):
                if isinstance(neighbor, dict):
                    neighbor_ip = self._extract_neighbor_ip(neighbor)
                    
                    if neighbor_ip and neighbor_ip not in visited:
                        # Try to resolve to inventory hostname
                        resolved_ip = self._resolve_neighbor_ip(neighbor_ip)
                        if resolved_ip:
                            possible_hops.append(resolved_ip)
            
            if not possible_hops:
                return None
            
            # Prioritize direct connection to router
            if target_router in possible_hops:
                return target_router
            
            # Prioritize devices that have the target router configured
            for hop in possible_hops:
                try:
                    if self.nr.inventory.hosts[hop].data.get('router') == target_router:
                        return hop
                except KeyError:
                    continue
            
            # Return first available hop
            return possible_hops[0]
            
        except Exception as e:
            logger.error(f"Error finding next hop from {current_device}: {str(e)}")
            return None

    def _extract_neighbor_ip(self, neighbor: Dict) -> Optional[str]:
        """Extract neighbor IP from LLDP data"""
        neighbor_ip = (neighbor.get('mgmt_address') or 
                      neighbor.get('neighbor') or 
                      neighbor.get('neighbor_name') or
                      neighbor.get('system_name'))
        
        if neighbor_ip and '.' not in neighbor_ip:
            # Handle hostname format
            neighbor_ip = neighbor_ip.split('.')[0]
        
        return neighbor_ip

    def _resolve_neighbor_ip(self, neighbor_ip: str) -> Optional[str]:
        """Resolve neighbor IP to inventory hostname"""
        # Direct match
        if neighbor_ip in self.nr.inventory.hosts:
            return neighbor_ip
        
        # Hostname match
        for hostname, host in self.nr.inventory.hosts.items():
            if (host.get('hostname', '') == neighbor_ip or 
                hostname.startswith(neighbor_ip)):
                return hostname
        
        return None

    def verify_vlan_path(self, initial_switch: str, target_port: str, vlan_id: str) -> Tuple[bool, str, List[str], Dict[str, DeviceResult]]:
        """Comprehensive VLAN path verification"""
        logger.info("Starting VLAN path verification")
        
        # Trace path
        path = self.trace_path_to_router(initial_switch)
        if not path:
            return False, "No path found to router", [], {}

        # Verify each device in path
        results = {}
        overall_success = True
        failure_reasons = []
        
        for i, device_ip in enumerate(path):
            logger.info(f"Verifying device {i+1}/{len(path)}: {device_ip}")
            
            result = DeviceResult(device_ip=device_ip, vlan_status="Unknown")
            
            # Check VLAN exists
            vlan_exists = self.nr.filter(name=device_ip).run(
                task=self.verify_vlan_exists,
                vlan_id=vlan_id
            )[device_ip].result
            
            if vlan_exists:
                result.vlan_status = "VLAN exists"
                logger.debug(f"VLAN {vlan_id} exists on {device_ip}")
            else:
                result.vlan_status = "VLAN missing"
                result.overall_status = VerificationStatus.FAIL
                overall_success = False
                failure_reasons.append(f"VLAN {vlan_id} missing on {device_ip}")
                logger.warning(f"VLAN {vlan_id} missing on {device_ip}")
            
            # First device: check access port
            if i == 0:
                access_ok = self.nr.filter(name=device_ip).run(
                    task=self.verify_access_vlan,
                    interface=target_port,
                    vlan_id=vlan_id
                )[device_ip].result
                
                if access_ok:
                    result.port_status = "Access port configured"
                    logger.debug(f"Access port {target_port} configured on {device_ip}")
                else:
                    result.port_status = f"Port {target_port} not in VLAN {vlan_id}"
                    result.overall_status = VerificationStatus.FAIL
                    overall_success = False
                    failure_reasons.append(f"Port {target_port} not in VLAN {vlan_id}")
                    logger.warning(f"Port {target_port} not in VLAN {vlan_id}")
            
            # Intermediate devices: check trunk ports
            elif i < len(path) - 1:
                next_device = path[i + 1]
                uplink_port = self.nr.filter(name=device_ip).run(
                    task=self.find_uplink_port,
                    neighbor_ip=next_device
                )[device_ip].result
                
                if uplink_port:
                    trunk_ok = self.nr.filter(name=device_ip).run(
                        task=self.verify_trunk_vlan,
                        interface=uplink_port,
                        vlan_id=vlan_id
                    )[device_ip].result
                    
                    if trunk_ok:
                        result.trunk_status = f"Trunk {uplink_port} allows VLAN"
                        logger.debug(f"Trunk {uplink_port} allows VLAN {vlan_id}")
                    else:
                        result.trunk_status = f"VLAN {vlan_id} blocked on {uplink_port}"
                        result.overall_status = VerificationStatus.FAIL
                        overall_success = False
                        failure_reasons.append(f"VLAN {vlan_id} blocked on {uplink_port}")
                        logger.warning(f"VLAN {vlan_id} blocked on {uplink_port}")
                else:
                    result.trunk_status = f"No uplink found to {next_device}"
                    result.overall_status = VerificationStatus.FAIL
                    overall_success = False
                    failure_reasons.append(f"No uplink found to {next_device}")
                    logger.warning(f"No uplink found to {next_device}")
            
            # Router endpoint
            else:
                result.role = "Router endpoint"
                logger.debug(f"Router endpoint: {device_ip}")
            
            # Set overall status if not already failed
            if result.overall_status == VerificationStatus.UNKNOWN:
                result.overall_status = VerificationStatus.PASS
            
            results[device_ip] = result

        # Generate summary message
        if overall_success:
            message = f"VLAN {vlan_id} path fully verified"
        else:
            message = f"VLAN path verification failed: {'; '.join(failure_reasons[:3])}"
        
        logger.info(f"Verification complete: {message}")
        return overall_success, message, path, results

    def visualize_path(self, path: List[str], verification_results: Dict[str, DeviceResult]):
        """Create enhanced visualization of the network path"""
        plt.ioff()
        fig, ax = plt.subplots(figsize=(18, 12))
        
        # Create graph
        G = nx.path_graph(path)
        
        # Position nodes
        pos = {node: (i * 3, 0) for i, node in enumerate(G.nodes())}
        
        # Prepare node colors and labels
        node_colors = []
        node_labels = {}
        status_labels = {}
        
        for node in G.nodes():
            result = verification_results.get(node)
            if not result:
                node_colors.append("gray")
                status_labels[node] = "No data"
                continue
            
            # Determine color based on status
            if result.overall_status == VerificationStatus.PASS:
                node_colors.append("lightgreen")
                status = "✓ PASS"
            elif result.overall_status == VerificationStatus.FAIL:
                node_colors.append("red")
                status = "✗ FAIL"
            else:
                node_colors.append("gray")
                status = "? UNKNOWN"
            
            # Create node label
            node_labels[node] = node
            
            # Create status label
            status_lines = [f"Status: {status}"]
            
            if result.vlan_status:
                status_lines.append(f"VLAN: {result.vlan_status}")
            
            if result.port_status:
                status_lines.append(f"Port: {result.port_status}")
            
            if result.trunk_status:
                status_lines.append(f"Trunk: {result.trunk_status}")
            
            if result.role:
                status_lines.append(f"Role: {result.role}")
            
            status_labels[node] = "\n".join(status_lines[:4])  # Limit to 4 lines
        
        # Draw network graph
        nx.draw_networkx_nodes(G, pos, node_color=node_colors, node_size=5000, 
                              edgecolors='black', linewidths=2)
        nx.draw_networkx_edges(G, pos, width=3, edge_color='steelblue', 
                              arrows=True, arrowstyle='-|>', arrowsize=30)
        
        # Add device labels (above nodes)
        name_pos = {k: (v[0], v[1] + 0.8) for k, v in pos.items()}
        nx.draw_networkx_labels(G, name_pos, labels=node_labels, font_size=10, 
                               font_weight="bold")
        
        # Add status labels (below nodes)
        status_pos = {k: (v[0], v[1] - 1.2) for k, v in pos.items()}
        nx.draw_networkx_labels(G, status_pos, labels=status_labels, font_size=8,
                               bbox=dict(facecolor='white', edgecolor='black',
                                       boxstyle='round,pad=0.5', alpha=0.9))
        
        # Add legend
        legend_elements = [
            plt.Line2D([0], [0], marker='o', color='w', label='Pass', 
                      markerfacecolor='lightgreen', markersize=15),
            plt.Line2D([0], [0], marker='o', color='w', label='Fail', 
                      markerfacecolor='red', markersize=15),
            plt.Line2D([0], [0], marker='o', color='w', label='Unknown', 
                      markerfacecolor='gray', markersize=15)
        ]
        
        plt.legend(handles=legend_elements, loc='upper right', fontsize=12, 
                  title="Verification Status", title_fontsize=14)
        
        plt.title("Network VLAN Path Verification Results", pad=40, fontsize=18, 
                 fontweight='bold')
        plt.axis('off')
        plt.tight_layout()
        plt.show(block=True)
        plt.ion()


def main():
    """Main function to run VLAN path verification"""
    # Configuration
    initial_switch = "172.17.57.243"
    target_port = "GigabitEthernet1/0/10"
    vlan_id = "5"
    
    # Create verifier instance
    verifier = NetworkVerifier(config_file="config.yaml")
    
    try:
        # Run verification
        success, message, path, results = verifier.verify_vlan_path(
            initial_switch, target_port, vlan_id
        )
        
        # Print results
        print("\n" + "="*60)
        print(f"VLAN PATH VERIFICATION {'SUCCEEDED' if success else 'FAILED'}")
        print("="*60)
        print(f"Initial Switch: {initial_switch}")
        print(f"Target Port: {target_port}")
        print(f"VLAN ID: {vlan_id}")
        print(f"Path: {' → '.join(path)}")
        print(f"Status: {message}")
        print("="*60)
        
        # Detailed results
        print("\nDETAILED RESULTS:")
        print("-" * 40)
        for device_ip, result in results.items():
            print(f"\nDevice: {device_ip}")
            print(f"  Overall Status: {result.overall_status.value.upper()}")
            print(f"  VLAN Status: {result.vlan_status}")
            if result.port_status:
                print(f"  Port Status: {result.port_status}")
            if result.trunk_status:
                print(f"  Trunk Status: {result.trunk_status}")
            if result.role:
                print(f"  Role: {result.role}")
        
        # Show visualization
        if path and results:
            print("\nGenerating network visualization...")
            verifier.visualize_path(path, results)
        
        return success
        
    except Exception as e:
        logger.error(f"Verification failed with error: {str(e)}")
        print(f"\nERROR: Verification failed - {str(e)}")
        return False
    
    finally:
        # Cleanup
        if hasattr(verifier, 'nr') and verifier.nr:
            verifier.nr.close_connections()


if __name__ == "__main__":
    import sys
    
    # Allow command line arguments
    if len(sys.argv) >= 4:
        initial_switch = sys.argv[1]
        target_port = sys.argv[2]
        vlan_id = sys.argv[3]
        
        verifier = NetworkVerifier()
        success, message, path, results = verifier.verify_vlan_path(
            initial_switch, target_port, vlan_id
        )
        
        if success:
            print(f"✓ VLAN {vlan_id} path verification successful")
            sys.exit(0)
        else:
            print(f"✗ VLAN {vlan_id} path verification failed: {message}")
            sys.exit(1)
    else:
        # Use default configuration
        success = main()
        sys.exit(0 if success else 1)
from nornir import InitNornir
from nornir_netmiko import netmiko_send_command
from nornir.core.task import Task, Result
from typing import Dict, List, Tuple, Optional, Set
import networkx as nx
import matplotlib.pyplot as plt
import re
import logging
from dataclasses import dataclass
from enum import Enum

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class VerificationStatus(Enum):
    PASS = "pass"
    FAIL = "fail"
    UNKNOWN = "unknown"

@dataclass
class DeviceResult:
    device_ip: str
    vlan_status: str
    port_status: Optional[str] = None
    trunk_status: Optional[str] = None
    role: Optional[str] = None
    overall_status: VerificationStatus = VerificationStatus.UNKNOWN

class NetworkVerifier:
    def __init__(self, config_file: str = "config.yaml"):
        self.nr = InitNornir(config_file=config_file)
        self.max_hops = 15
        
    def get_lldp_neighbors(self, task: Task) -> List[Dict]:
        """Collect LLDP neighbor information in a vendor-neutral way"""
        platform = task.host.platform
        
        # Enhanced command mapping for different platforms
        command_map = {
            "aruba_cx": "show lldp neighbors detail",
            "cisco_ios": "show lldp neighbors detail",
            "cisco_xe": "show lldp neighbors detail",
            "hp_comware": "display lldp neighbor-information",
            "juniper": "show lldp neighbors detail"
        }
        
        command = command_map.get(platform, "show lldp neighbors detail")
        
        logger.debug(f"Running on {task.host}: {command}")
        
        try:
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            # Handle different result types
            if isinstance(result.result, str):
                logger.warning(f"TextFSM parsing failed for {task.host}, attempting manual parsing")
                return self._parse_lldp_manually(result.result, platform)
            elif isinstance(result.result, dict):
                return [result.result]
            elif isinstance(result.result, list):
                return result.result
            else:
                logger.warning(f"No LLDP neighbors found on {task.host}")
                return []
                
        except Exception as e:
            logger.error(f"Error getting LLDP neighbors on {task.host}: {str(e)}")
            return []

    def _parse_lldp_manually(self, output: str, platform: str) -> List[Dict]:
        """Manual parsing fallback for when TextFSM fails"""
        neighbors = []
        
        try:
            # Basic regex patterns for common LLDP output formats
            if platform == "cisco_ios":
                # Cisco IOS LLDP format
                pattern = r'Device ID: (\S+).*?Local Intf: (\S+).*?Port id: (\S+)'
                matches = re.findall(pattern, output, re.DOTALL)
                
                for match in matches:
                    neighbors.append({
                        'neighbor': match[0],
                        'local_interface': match[1],
                        'neighbor_port': match[2]
                    })
            
            # Add more platform-specific parsing as needed
            
        except Exception as e:
            logger.error(f"Manual LLDP parsing failed: {str(e)}")
            
        return neighbors

    def find_uplink_port(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find the local interface connected to a neighbor with improved error handling"""
        platform = task.host.platform
        
        try:
            # Try LLDP first (most reliable)
            lldp_result = self._find_port_via_lldp(task, neighbor_ip, platform)
            if lldp_result:
                return lldp_result
            
            # Fall back to CDP for Cisco devices
            if platform.startswith("cisco"):
                cdp_result = self._find_port_via_cdp(task, neighbor_ip)
                if cdp_result:
                    return cdp_result
                    
            # Last resort: MAC address table lookup
            mac_result = self._find_port_via_mac(task, neighbor_ip)
            if mac_result:
                return mac_result
                
        except Exception as e:
            logger.error(f"Error finding uplink port on {task.host}: {str(e)}")
        
        return None

    def _find_port_via_lldp(self, task: Task, neighbor_ip: str, platform: str) -> Optional[str]:
        """Find port using LLDP"""
        try:
            neighbors = self.get_lldp_neighbors(task)
            
            for neighbor in neighbors:
                # Check multiple possible neighbor identifier fields
                neighbor_id = (neighbor.get('neighbor') or 
                             neighbor.get('mgmt_address') or 
                             neighbor.get('system_name'))
                
                if neighbor_id and (neighbor_id == neighbor_ip or 
                                  neighbor_id.startswith(neighbor_ip.split('.')[0])):
                    return neighbor.get('local_interface')
                    
        except Exception as e:
            logger.debug(f"LLDP port lookup failed: {str(e)}")
            
        return None

    def _find_port_via_cdp(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find port using CDP (Cisco devices)"""
        try:
            command = "show cdp neighbors detail"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if result.result:
                for neighbor in (result.result if isinstance(result.result, list) else [result.result]):
                    if neighbor.get('mgmt_address') == neighbor_ip:
                        return neighbor.get('local_port')
                        
        except Exception as e:
            logger.debug(f"CDP port lookup failed: {str(e)}")
            
        return None

    def _find_port_via_mac(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find port using MAC address table (least reliable)"""
        try:
            # This would require ARP table lookup first, then MAC table
            # Implementation depends on specific requirements
            pass
        except Exception as e:
            logger.debug(f"MAC table port lookup failed: {str(e)}")
            
        return None

    def verify_vlan_exists(self, task: Task, vlan_id: str) -> bool:
        """Check if VLAN exists with enhanced platform support"""
        platform = task.host.platform
        
        command_map = {
            "aruba_cx": f"show vlan {vlan_id}",
            "cisco_ios": f"show vlan id {vlan_id}",
            "cisco_xe": f"show vlan id {vlan_id}",
            "hp_comware": f"display vlan {vlan_id}",
            "juniper": f"show vlans {vlan_id}"
        }
        
        command = command_map.get(platform, f"show vlan id {vlan_id}")
        
        try:
            logger.debug(f"Running on {task.host}: {command}")
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if isinstance(result.result, str):
                # Check for common error messages
                error_indicators = ["invalid", "not found", "does not exist", "error"]
                return not any(indicator in result.result.lower() for indicator in error_indicators)
            
            return bool(result.result)
            
        except Exception as e:
            logger.error(f"Error checking VLAN on {task.host}: {str(e)}")
            return False

    def verify_access_vlan(self, task: Task, interface: str, vlan_id: str) -> bool:
        """Verify access port VLAN configuration with better error handling"""
        platform = task.host.platform
        
        try:
            # Method 1: Check VLAN membership
            if self._check_vlan_membership(task, interface, vlan_id, platform):
                return True
            
            # Method 2: Check interface configuration
            if self._check_interface_config(task, interface, vlan_id, platform):
                return True
            
            logger.debug(f"Access VLAN {vlan_id} not found on {interface}")
            return False
            
        except Exception as e:
            logger.error(f"Error checking access port on {task.host}: {str(e)}")
            return False

    def _check_vlan_membership(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check VLAN membership tables"""
        try:
            command_map = {
                "aruba_cx": f"show vlan {vlan_id}",
                "cisco_ios": f"show vlan id {vlan_id}",
                "cisco_xe": f"show vlan id {vlan_id}",
            }
            
            command = command_map.get(platform, f"show vlan id {vlan_id}")
            
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if result.result:
                for vlan in (result.result if isinstance(result.result, list) else [result.result]):
                    interfaces = vlan.get('interfaces', [])
                    if isinstance(interfaces, str):
                        interfaces = [interfaces]
                    
                    # Normalize interface names for comparison
                    normalized_interfaces = [self._normalize_interface_name(intf) for intf in interfaces]
                    normalized_target = self._normalize_interface_name(interface)
                    
                    if normalized_target in normalized_interfaces:
                        return True
                        
        except Exception as e:
            logger.debug(f"VLAN membership check failed: {str(e)}")
            
        return False

    def _check_interface_config(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check interface running configuration"""
        try:
            command = f"show running-config interface {interface}"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=False,
                enable=True
            )
            
            config = result.result.lower()
            
            # Platform-specific config patterns
            patterns = {
                "aruba_cx": [f"vlan access {vlan_id}"],
                "cisco_ios": [f"switchport access vlan {vlan_id}"],
                "cisco_xe": [f"switchport access vlan {vlan_id}"],
            }
            
            check_patterns = patterns.get(platform, [f"switchport access vlan {vlan_id}"])
            
            return any(pattern in config for pattern in check_patterns)
            
        except Exception as e:
            logger.debug(f"Interface config check failed: {str(e)}")
            
        return False

    def _normalize_interface_name(self, interface: str) -> str:
        """Normalize interface names for comparison"""
        # Handle common abbreviations
        interface = interface.replace("GigabitEthernet", "Gi")
        interface = interface.replace("FastEthernet", "Fa")
        interface = interface.replace("TenGigabitEthernet", "Te")
        
        # Remove spaces and convert to lowercase
        return interface.replace(" ", "").lower()

    def verify_trunk_vlan(self, task: Task, interface: str, vlan_id: str) -> bool:
        """Verify trunk allows the VLAN with comprehensive checking"""
        platform = task.host.platform
        
        try:
            # Method 1: Check switchport status
            if self._check_switchport_trunk(task, interface, vlan_id, platform):
                return True
            
            # Method 2: Check running configuration
            if self._check_trunk_config(task, interface, vlan_id, platform):
                return True
            
            return False
            
        except Exception as e:
            logger.error(f"Error checking trunk on {task.host}: {str(e)}")
            return False

    def _check_switchport_trunk(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check switchport trunk status"""
        try:
            command = f"show interfaces {interface} switchport"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if isinstance(result.result, str):
                # Parse raw output
                return self._parse_trunk_raw_output(result.result, vlan_id)
            
            if result.result and isinstance(result.result, list):
                sw_data = result.result[0]
                
                # Check if port is in trunk mode
                if sw_data.get('mode', '').lower() != 'trunk':
                    return False
                
                # Check allowed VLANs
                return self._check_allowed_vlans(sw_data, vlan_id)
                
        except Exception as e:
            logger.debug(f"Switchport trunk check failed: {str(e)}")
            
        return False

    def _parse_trunk_raw_output(self, output: str, vlan_id: str) -> bool:
        """Parse raw switchport output"""
        output_lower = output.lower()
        
        if "trunking" in output_lower:
            if "vlans allowed: all" in output_lower:
                return True
            if f"vlans allowed: {vlan_id}" in output_lower:
                return True
        
        return False

    def _check_allowed_vlans(self, switchport_data: Dict, vlan_id: str) -> bool:
        """Check if VLAN is in allowed VLAN list"""
        for field in ['trunking_vlans', 'vlans_allowed', 'allowed_vlans']:
            vlans = switchport_data.get(field, '')
            
            if vlans:
                if vlans.upper() == 'ALL':
                    return True
                if self._is_vlan_in_list(vlans, vlan_id):
                    return True
        
        return False

    def _check_trunk_config(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check trunk configuration in running config"""
        try:
            command = f"show running-config interface {interface}"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                enable=True
            )
            
            config = result.result.lower()
            
            # If trunk mode is configured but no allowed VLAN restrictions, assume all VLANs allowed
            if "switchport mode trunk" in config and "switchport trunk allowed vlan" not in config:
                return True
            
            # Check specific VLAN allowances
            if f"switchport trunk allowed vlan add {vlan_id}" in config:
                return True
            
            return False
            
        except Exception as e:
            logger.debug(f"Trunk config check failed: {str(e)}")
            
        return False

    def _is_vlan_in_list(self, vlan_str: str, target_vlan: str) -> bool:
        """Helper to safely parse VLAN lists (1,5,10-20,30)"""
        try:
            if not vlan_str:
                return False
                
            target_int = int(target_vlan)
            
            for part in str(vlan_str).split(','):
                part = part.strip()
                
                if '-' in part:
                    # Handle range (e.g., "10-20")
                    start, end = map(int, part.split('-'))
                    if start <= target_int <= end:
                        return True
                elif part.isdigit() and int(part) == target_int:
                    return True
                    
            return False
            
        except (ValueError, AttributeError) as e:
            logger.error(f"VLAN list parsing failed: {str(e)}")
            return False

    def trace_path_to_router(self, start_device: str) -> List[str]:
        """Trace path from edge switch to router using LLDP with improved logic"""
        logger.info("Starting path trace to router...")
        
        path = []
        current_device = start_device
        visited: Set[str] = set()
        
        # Get target router
        try:
            target_router = self.nr.inventory.hosts[start_device].data.get('router')
            if not target_router:
                logger.error(f"No router defined for {start_device}")
                return []
        except KeyError:
            logger.error(f"Device {start_device} not found in inventory")
            return []

        logger.info(f"Target router: {target_router}")

        while current_device and current_device not in visited and len(path) < self.max_hops:
            visited.add(current_device)
            path.append(current_device)
            
            logger.debug(f"Current device: {current_device}")
            logger.debug(f"Current path: {' -> '.join(path)}")
            
            # Check if we've reached the target router
            if current_device == target_router:
                logger.info(f"Reached target router: {current_device}")
                break
            
            # Get neighbors and find next hop
            next_hop = self._find_next_hop(current_device, target_router, visited)
            if not next_hop:
                logger.warning(f"No valid next hop found from {current_device}")
                break
                
            current_device = next_hop

        # Ensure router is in path
        if path and path[-1] != target_router:
            path.append(target_router)
            logger.debug(f"Added router {target_router} to path")

        logger.info(f"Final path: {' -> '.join(path)}")
        return path

    def _find_next_hop(self, current_device: str, target_router: str, visited: Set[str]) -> Optional[str]:
        """Find the next hop in the path"""
        try:
            neighbors_result = self.nr.filter(name=current_device).run(task=self.get_lldp_neighbors)
            neighbors = neighbors_result[current_device].result
            
            if not neighbors:
                logger.debug(f"No neighbors found for {current_device}")
                return None
            
            # Find unvisited neighbors
            possible_hops = []
            for neighbor in (neighbors if isinstance(neighbors, list) else [neighbors]):
                if isinstance(neighbor, dict):
                    neighbor_ip = self._extract_neighbor_ip(neighbor)
                    
                    if neighbor_ip and neighbor_ip not in visited:
                        # Try to resolve to inventory hostname
                        resolved_ip = self._resolve_neighbor_ip(neighbor_ip)
                        if resolved_ip:
                            possible_hops.append(resolved_ip)
            
            if not possible_hops:
                return None
            
            # Prioritize direct connection to router
            if target_router in possible_hops:
                return target_router
            
            # Prioritize devices that have the target router configured
            for hop in possible_hops:
                try:
                    if self.nr.inventory.hosts[hop].data.get('router') == target_router:
                        return hop
                except KeyError:
                    continue
            
            # Return first available hop
            return possible_hops[0]
            
        except Exception as e:
            logger.error(f"Error finding next hop from {current_device}: {str(e)}")
            return None

    def _extract_neighbor_ip(self, neighbor: Dict) -> Optional[str]:
        """Extract neighbor IP from LLDP data"""
        neighbor_ip = (neighbor.get('mgmt_address') or 
                      neighbor.get('neighbor') or 
                      neighbor.get('neighbor_name') or
                      neighbor.get('system_name'))
        
        if neighbor_ip and '.' not in neighbor_ip:
            # Handle hostname format
            neighbor_ip = neighbor_ip.split('.')[0]
        
        return neighbor_ip

    def _resolve_neighbor_ip(self, neighbor_ip: str) -> Optional[str]:
        """Resolve neighbor IP to inventory hostname"""
        # Direct match
        if neighbor_ip in self.nr.inventory.hosts:
            return neighbor_ip
        
        # Hostname match
        for hostname, host in self.nr.inventory.hosts.items():
            if (host.get('hostname', '') == neighbor_ip or 
                hostname.startswith(neighbor_ip)):
                return hostname
        
        return None

    def verify_vlan_path(self, initial_switch: str, target_port: str, vlan_id: str) -> Tuple[bool, str, List[str], Dict[str, DeviceResult]]:
        """Comprehensive VLAN path verification"""
        logger.info("Starting VLAN path verification")
        
        # Trace path
        path = self.trace_path_to_router(initial_switch)
        if not path:
            return False, "No path found to router", [], {}

        # Verify each device in path
        results = {}
        overall_success = True
        failure_reasons = []
        
        for i, device_ip in enumerate(path):
            logger.info(f"Verifying device {i+1}/{len(path)}: {device_ip}")
            
            result = DeviceResult(device_ip=device_ip, vlan_status="Unknown")
            
            # Check VLAN exists
            vlan_exists = self.nr.filter(name=device_ip).run(
                task=self.verify_vlan_exists,
                vlan_id=vlan_id
            )[device_ip].result
            
            if vlan_exists:
                result.vlan_status = "VLAN exists"
                logger.debug(f"VLAN {vlan_id} exists on {device_ip}")
            else:
                result.vlan_status = "VLAN missing"
                result.overall_status = VerificationStatus.FAIL
                overall_success = False
                failure_reasons.append(f"VLAN {vlan_id} missing on {device_ip}")
                logger.warning(f"VLAN {vlan_id} missing on {device_ip}")
            
            # First device: check access port
            if i == 0:
                access_ok = self.nr.filter(name=device_ip).run(
                    task=self.verify_access_vlan,
                    interface=target_port,
                    vlan_id=vlan_id
                )[device_ip].result
                
                if access_ok:
                    result.port_status = "Access port configured"
                    logger.debug(f"Access port {target_port} configured on {device_ip}")
                else:
                    result.port_status = f"Port {target_port} not in VLAN {vlan_id}"
                    result.overall_status = VerificationStatus.FAIL
                    overall_success = False
                    failure_reasons.append(f"Port {target_port} not in VLAN {vlan_id}")
                    logger.warning(f"Port {target_port} not in VLAN {vlan_id}")
            
            # Intermediate devices: check trunk ports
            elif i < len(path) - 1:
                next_device = path[i + 1]
                uplink_port = self.nr.filter(name=device_ip).run(
                    task=self.find_uplink_port,
                    neighbor_ip=next_device
                )[device_ip].result
                
                if uplink_port:
                    trunk_ok = self.nr.filter(name=device_ip).run(
                        task=self.verify_trunk_vlan,
                        interface=uplink_port,
                        vlan_id=vlan_id
                    )[device_ip].result
                    
                    if trunk_ok:
                        result.trunk_status = f"Trunk {uplink_port} allows VLAN"
                        logger.debug(f"Trunk {uplink_port} allows VLAN {vlan_id}")
                    else:
                        result.trunk_status = f"VLAN {vlan_id} blocked on {uplink_port}"
                        result.overall_status = VerificationStatus.FAIL
                        overall_success = False
                        failure_reasons.append(f"VLAN {vlan_id} blocked on {uplink_port}")
                        logger.warning(f"VLAN {vlan_id} blocked on {uplink_port}")
                else:
                    result.trunk_status = f"No uplink found to {next_device}"
                    result.overall_status = VerificationStatus.FAIL
                    overall_success = False
                    failure_reasons.append(f"No uplink found to {next_device}")
                    logger.warning(f"No uplink found to {next_device}")
            
            # Router endpoint
            else:
                result.role = "Router endpoint"
                logger.debug(f"Router endpoint: {device_ip}")
            
            # Set overall status if not already failed
            if result.overall_status == VerificationStatus.UNKNOWN:
                result.overall_status = VerificationStatus.PASS
            
            results[device_ip] = result

        # Generate summary message
        if overall_success:
            message = f"VLAN {vlan_id} path fully verified"
        else:
            message = f"VLAN path verification failed: {'; '.join(failure_reasons[:3])}"
        
        logger.info(f"Verification complete: {message}")
        return overall_success, message, path, results

    def visualize_path(self, path: List[str], verification_results: Dict[str, DeviceResult]):
        """Create enhanced visualization of the network path"""
        plt.ioff()
        fig, ax = plt.subplots(figsize=(18, 12))
        
        # Create graph
        G = nx.path_graph(path)
        
        # Position nodes
        pos = {node: (i * 3, 0) for i, node in enumerate(G.nodes())}
        
        # Prepare node colors and labels
        node_colors = []
        node_labels = {}
        status_labels = {}
        
        for node in G.nodes():
            result = verification_results.get(node)
            if not result:
                node_colors.append("gray")
                status_labels[node] = "No data"
                continue
            
            # Determine color based on status
            if result.overall_status == VerificationStatus.PASS:
                node_colors.append("lightgreen")
                status = "✓ PASS"
            elif result.overall_status == VerificationStatus.FAIL:
                node_colors.append("red")
                status = "✗ FAIL"
            else:
                node_colors.append("gray")
                status = "? UNKNOWN"
            
            # Create node label
            node_labels[node] = node
            
            # Create status label
            status_lines = [f"Status: {status}"]
            
            if result.vlan_status:
                status_lines.append(f"VLAN: {result.vlan_status}")
            
            if result.port_status:
                status_lines.append(f"Port: {result.port_status}")
            
            if result.trunk_status:
                status_lines.append(f"Trunk: {result.trunk_status}")
            
            if result.role:
                status_lines.append(f"Role: {result.role}")
            
            status_labels[node] = "\n".join(status_lines[:4])  # Limit to 4 lines
        
        # Draw network graph
        nx.draw_networkx_nodes(G, pos, node_color=node_colors, node_size=5000, 
                              edgecolors='black', linewidths=2)
        nx.draw_networkx_edges(G, pos, width=3, edge_color='steelblue', 
                              arrows=True, arrowstyle='-|>', arrowsize=30)
        
        # Add device labels (above nodes)
        name_pos = {k: (v[0], v[1] + 0.8) for k, v in pos.items()}
        nx.draw_networkx_labels(G, name_pos, labels=node_labels, font_size=10, 
                               font_weight="bold")
        
        # Add status labels (below nodes)
        status_pos = {k: (v[0], v[1] - 1.2) for k, v in pos.items()}
        nx.draw_networkx_labels(G, status_pos, labels=status_labels, font_size=8,
                               bbox=dict(facecolor='white', edgecolor='black',
                                       boxstyle='round,pad=0.5', alpha=0.9))
        
        # Add legend
        legend_elements = [
            plt.Line2D([0], [0], marker='o', color='w', label='Pass', 
                      markerfacecolor='lightgreen', markersize=15),
            plt.Line2D([0], [0], marker='o', color='w', label='Fail', 
                      markerfacecolor='red', markersize=15),
            plt.Line2D([0], [0], marker='o', color='w', label='Unknown', 
                      markerfacecolor='gray', markersize=15)
        ]
        
        plt.legend(handles=legend_elements, loc='upper right', fontsize=12, 
                  title="Verification Status", title_fontsize=14)
        
        plt.title("Network VLAN Path Verification Results", pad=40, fontsize=18, 
                 fontweight='bold')
        plt.axis('off')
        plt.tight_layout()
        plt.show(block=True)
        plt.ion()


def main():
    """Main function to run VLAN path verification"""
    # Configuration
    initial_switch = "172.17.57.243"
    target_port = "GigabitEthernet1/0/10"
    vlan_id = "5"
    
    # Create verifier instance
    verifier = NetworkVerifier(config_file="config.yaml")
    
    try:
        # Run verification
        success, message, path, results = verifier.verify_vlan_path(
            initial_switch, target_port, vlan_id
        )
        
        # Print results
        print("\n" + "="*60)
        print(f"VLAN PATH VERIFICATION {'SUCCEEDED' if success else 'FAILED'}")
        print("="*60)
        print(f"Initial Switch: {initial_switch}")
        print(f"Target Port: {target_port}")
        print(f"VLAN ID: {vlan_id}")
        print(f"Path: {' → '.join(path)}")
        print(f"Status: {message}")
        print("="*60)
        
        # Detailed results
        print("\nDETAILED RESULTS:")
        print("-" * 40)
        for device_ip, result in results.items():
            print(f"\nDevice: {device_ip}")
            print(f"  Overall Status: {result.overall_status.value.upper()}")
            print(f"  VLAN Status: {result.vlan_status}")
            if result.port_status:
                print(f"  Port Status: {result.port_status}")
            if result.trunk_status:
                print(f"  Trunk Status: {result.trunk_status}")
            if result.role:
                print(f"  Role: {result.role}")
        
        # Show visualization
        if path and results:
            print("\nGenerating network visualization...")
            verifier.visualize_path(path, results)
        
        return success
        
    except Exception as e:
        logger.error(f"Verification failed with error: {str(e)}")
        print(f"\nERROR: Verification failed - {str(e)}")
        return False
    
    finally:
        # Cleanup
        if hasattr(verifier, 'nr') and verifier.nr:
            verifier.nr.close_connections()


if __name__ == "__main__":
    import sys
    
    # Allow command line arguments
    if len(sys.argv) >= 4:
        initial_switch = sys.argv[1]
        target_port = sys.argv[2]
        vlan_id = sys.argv[3]
        
        verifier = NetworkVerifier()
        success, message, path, results = verifier.verify_vlan_path(
            initial_switch, target_port, vlan_id
        )
        
        if success:
            print(f"✓ VLAN {vlan_id} path verification successful")
            sys.exit(0)
        else:
            print(f"✗ VLAN {vlan_id} path verification failed: {message}")
            sys.exit(1)
    else:
        # Use default configuration
        success = main()
        sys.exit(0 if success else 1)
from nornir import InitNornir
from nornir_netmiko import netmiko_send_command
from nornir.core.task import Task, Result
from typing import Dict, List, Tuple, Optional, Set
import networkx as nx
import matplotlib.pyplot as plt
import re
import logging
from dataclasses import dataclass
from enum import Enum

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class VerificationStatus(Enum):
    PASS = "pass"
    FAIL = "fail"
    UNKNOWN = "unknown"

@dataclass
class DeviceResult:
    device_ip: str
    vlan_status: str
    port_status: Optional[str] = None
    trunk_status: Optional[str] = None
    role: Optional[str] = None
    overall_status: VerificationStatus = VerificationStatus.UNKNOWN

class NetworkVerifier:
    def __init__(self, config_file: str = "config.yaml"):
        self.nr = InitNornir(config_file=config_file)
        self.max_hops = 15
        
    def get_lldp_neighbors(self, task: Task) -> List[Dict]:
        """Collect LLDP neighbor information in a vendor-neutral way"""
        platform = task.host.platform
        
        # Enhanced command mapping for different platforms
        command_map = {
            "aruba_cx": "show lldp neighbors detail",
            "cisco_ios": "show lldp neighbors detail",
            "cisco_xe": "show lldp neighbors detail",
            "hp_comware": "display lldp neighbor-information",
            "juniper": "show lldp neighbors detail"
        }
        
        command = command_map.get(platform, "show lldp neighbors detail")
        
        logger.debug(f"Running on {task.host}: {command}")
        
        try:
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            # Handle different result types
            if isinstance(result.result, str):
                logger.warning(f"TextFSM parsing failed for {task.host}, attempting manual parsing")
                return self._parse_lldp_manually(result.result, platform)
            elif isinstance(result.result, dict):
                return [result.result]
            elif isinstance(result.result, list):
                return result.result
            else:
                logger.warning(f"No LLDP neighbors found on {task.host}")
                return []
                
        except Exception as e:
            logger.error(f"Error getting LLDP neighbors on {task.host}: {str(e)}")
            return []

    def _parse_lldp_manually(self, output: str, platform: str) -> List[Dict]:
        """Manual parsing fallback for when TextFSM fails"""
        neighbors = []
        
        try:
            # Basic regex patterns for common LLDP output formats
            if platform == "cisco_ios":
                # Cisco IOS LLDP format
                pattern = r'Device ID: (\S+).*?Local Intf: (\S+).*?Port id: (\S+)'
                matches = re.findall(pattern, output, re.DOTALL)
                
                for match in matches:
                    neighbors.append({
                        'neighbor': match[0],
                        'local_interface': match[1],
                        'neighbor_port': match[2]
                    })
            
            # Add more platform-specific parsing as needed
            
        except Exception as e:
            logger.error(f"Manual LLDP parsing failed: {str(e)}")
            
        return neighbors

    def find_uplink_port(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find the local interface connected to a neighbor with improved error handling"""
        platform = task.host.platform
        
        try:
            # Try LLDP first (most reliable)
            lldp_result = self._find_port_via_lldp(task, neighbor_ip, platform)
            if lldp_result:
                return lldp_result
            
            # Fall back to CDP for Cisco devices
            if platform.startswith("cisco"):
                cdp_result = self._find_port_via_cdp(task, neighbor_ip)
                if cdp_result:
                    return cdp_result
                    
            # Last resort: MAC address table lookup
            mac_result = self._find_port_via_mac(task, neighbor_ip)
            if mac_result:
                return mac_result
                
        except Exception as e:
            logger.error(f"Error finding uplink port on {task.host}: {str(e)}")
        
        return None

    def _find_port_via_lldp(self, task: Task, neighbor_ip: str, platform: str) -> Optional[str]:
        """Find port using LLDP"""
        try:
            neighbors = self.get_lldp_neighbors(task)
            
            for neighbor in neighbors:
                # Check multiple possible neighbor identifier fields
                neighbor_id = (neighbor.get('neighbor') or 
                             neighbor.get('mgmt_address') or 
                             neighbor.get('system_name'))
                
                if neighbor_id and (neighbor_id == neighbor_ip or 
                                  neighbor_id.startswith(neighbor_ip.split('.')[0])):
                    return neighbor.get('local_interface')
                    
        except Exception as e:
            logger.debug(f"LLDP port lookup failed: {str(e)}")
            
        return None

    def _find_port_via_cdp(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find port using CDP (Cisco devices)"""
        try:
            command = "show cdp neighbors detail"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if result.result:
                for neighbor in (result.result if isinstance(result.result, list) else [result.result]):
                    if neighbor.get('mgmt_address') == neighbor_ip:
                        return neighbor.get('local_port')
                        
        except Exception as e:
            logger.debug(f"CDP port lookup failed: {str(e)}")
            
        return None

    def _find_port_via_mac(self, task: Task, neighbor_ip: str) -> Optional[str]:
        """Find port using MAC address table (least reliable)"""
        try:
            # This would require ARP table lookup first, then MAC table
            # Implementation depends on specific requirements
            pass
        except Exception as e:
            logger.debug(f"MAC table port lookup failed: {str(e)}")
            
        return None

    def verify_vlan_exists(self, task: Task, vlan_id: str) -> bool:
        """Check if VLAN exists with enhanced platform support"""
        platform = task.host.platform
        
        command_map = {
            "aruba_cx": f"show vlan {vlan_id}",
            "cisco_ios": f"show vlan id {vlan_id}",
            "cisco_xe": f"show vlan id {vlan_id}",
            "hp_comware": f"display vlan {vlan_id}",
            "juniper": f"show vlans {vlan_id}"
        }
        
        command = command_map.get(platform, f"show vlan id {vlan_id}")
        
        try:
            logger.debug(f"Running on {task.host}: {command}")
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if isinstance(result.result, str):
                # Check for common error messages
                error_indicators = ["invalid", "not found", "does not exist", "error"]
                return not any(indicator in result.result.lower() for indicator in error_indicators)
            
            return bool(result.result)
            
        except Exception as e:
            logger.error(f"Error checking VLAN on {task.host}: {str(e)}")
            return False

    def verify_access_vlan(self, task: Task, interface: str, vlan_id: str) -> bool:
        """Verify access port VLAN configuration with better error handling"""
        platform = task.host.platform
        
        try:
            # Method 1: Check VLAN membership
            if self._check_vlan_membership(task, interface, vlan_id, platform):
                return True
            
            # Method 2: Check interface configuration
            if self._check_interface_config(task, interface, vlan_id, platform):
                return True
            
            logger.debug(f"Access VLAN {vlan_id} not found on {interface}")
            return False
            
        except Exception as e:
            logger.error(f"Error checking access port on {task.host}: {str(e)}")
            return False

    def _check_vlan_membership(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check VLAN membership tables"""
        try:
            command_map = {
                "aruba_cx": f"show vlan {vlan_id}",
                "cisco_ios": f"show vlan id {vlan_id}",
                "cisco_xe": f"show vlan id {vlan_id}",
            }
            
            command = command_map.get(platform, f"show vlan id {vlan_id}")
            
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if result.result:
                for vlan in (result.result if isinstance(result.result, list) else [result.result]):
                    interfaces = vlan.get('interfaces', [])
                    if isinstance(interfaces, str):
                        interfaces = [interfaces]
                    
                    # Normalize interface names for comparison
                    normalized_interfaces = [self._normalize_interface_name(intf) for intf in interfaces]
                    normalized_target = self._normalize_interface_name(interface)
                    
                    if normalized_target in normalized_interfaces:
                        return True
                        
        except Exception as e:
            logger.debug(f"VLAN membership check failed: {str(e)}")
            
        return False

    def _check_interface_config(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check interface running configuration"""
        try:
            command = f"show running-config interface {interface}"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=False,
                enable=True
            )
            
            config = result.result.lower()
            
            # Platform-specific config patterns
            patterns = {
                "aruba_cx": [f"vlan access {vlan_id}"],
                "cisco_ios": [f"switchport access vlan {vlan_id}"],
                "cisco_xe": [f"switchport access vlan {vlan_id}"],
            }
            
            check_patterns = patterns.get(platform, [f"switchport access vlan {vlan_id}"])
            
            return any(pattern in config for pattern in check_patterns)
            
        except Exception as e:
            logger.debug(f"Interface config check failed: {str(e)}")
            
        return False

    def _normalize_interface_name(self, interface: str) -> str:
        """Normalize interface names for comparison"""
        # Handle common abbreviations
        interface = interface.replace("GigabitEthernet", "Gi")
        interface = interface.replace("FastEthernet", "Fa")
        interface = interface.replace("TenGigabitEthernet", "Te")
        
        # Remove spaces and convert to lowercase
        return interface.replace(" ", "").lower()

    def verify_trunk_vlan(self, task: Task, interface: str, vlan_id: str) -> bool:
        """Verify trunk allows the VLAN with comprehensive checking"""
        platform = task.host.platform
        
        try:
            # Method 1: Check switchport status
            if self._check_switchport_trunk(task, interface, vlan_id, platform):
                return True
            
            # Method 2: Check running configuration
            if self._check_trunk_config(task, interface, vlan_id, platform):
                return True
            
            return False
            
        except Exception as e:
            logger.error(f"Error checking trunk on {task.host}: {str(e)}")
            return False

    def _check_switchport_trunk(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check switchport trunk status"""
        try:
            command = f"show interfaces {interface} switchport"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                use_textfsm=True,
                enable=True
            )
            
            if isinstance(result.result, str):
                # Parse raw output
                return self._parse_trunk_raw_output(result.result, vlan_id)
            
            if result.result and isinstance(result.result, list):
                sw_data = result.result[0]
                
                # Check if port is in trunk mode
                if sw_data.get('mode', '').lower() != 'trunk':
                    return False
                
                # Check allowed VLANs
                return self._check_allowed_vlans(sw_data, vlan_id)
                
        except Exception as e:
            logger.debug(f"Switchport trunk check failed: {str(e)}")
            
        return False

    def _parse_trunk_raw_output(self, output: str, vlan_id: str) -> bool:
        """Parse raw switchport output"""
        output_lower = output.lower()
        
        if "trunking" in output_lower:
            if "vlans allowed: all" in output_lower:
                return True
            if f"vlans allowed: {vlan_id}" in output_lower:
                return True
        
        return False

    def _check_allowed_vlans(self, switchport_data: Dict, vlan_id: str) -> bool:
        """Check if VLAN is in allowed VLAN list"""
        for field in ['trunking_vlans', 'vlans_allowed', 'allowed_vlans']:
            vlans = switchport_data.get(field, '')
            
            if vlans:
                if vlans.upper() == 'ALL':
                    return True
                if self._is_vlan_in_list(vlans, vlan_id):
                    return True
        
        return False

    def _check_trunk_config(self, task: Task, interface: str, vlan_id: str, platform: str) -> bool:
        """Check trunk configuration in running config"""
        try:
            command = f"show running-config interface {interface}"
            result = task.run(
                task=netmiko_send_command,
                command_string=command,
                enable=True
            )
            
            config = result.result.lower()
            
            # If trunk mode is configured but no allowed VLAN restrictions, assume all VLANs allowed
            if "switchport mode trunk" in config and "switchport trunk allowed vlan" not in config:
                return True
            
            # Check specific VLAN allowances
            if f"switchport trunk allowed vlan add {vlan_id}" in config:
                return True
            
            return False
            
        except Exception as e:
            logger.debug(f"Trunk config check failed: {str(e)}")
            
        return False

    def _is_vlan_in_list(self, vlan_str: str, target_vlan: str) -> bool:
        """Helper to safely parse VLAN lists (1,5,10-20,30)"""
        try:
            if not vlan_str:
                return False
                
            target_int = int(target_vlan)
            
            for part in str(vlan_str).split(','):
                part = part.strip()
                
                if '-' in part:
                    # Handle range (e.g., "10-20")
                    start, end = map(int, part.split('-'))
                    if start <= target_int <= end:
                        return True
                elif part.isdigit() and int(part) == target_int:
                    return True
                    
            return False
            
        except (ValueError, AttributeError) as e:
            logger.error(f"VLAN list parsing failed: {str(e)}")
            return False

    def trace_path_to_router(self, start_device: str) -> List[str]:
        """Trace path from edge switch to router using LLDP with improved logic"""
        logger.info("Starting path trace to router...")
        
        path = []
        current_device = start_device
        visited: Set[str] = set()
        
        # Get target router
        try:
            target_router = self.nr.inventory.hosts[start_device].data.get('router')
            if not target_router:
                logger.error(f"No router defined for {start_device}")
                return []
        except KeyError:
            logger.error(f"Device {start_device} not found in inventory")
            return []

        logger.info(f"Target router: {target_router}")

        while current_device and current_device not in visited and len(path) < self.max_hops:
            visited.add(current_device)
            path.append(current_device)
            
            logger.debug(f"Current device: {current_device}")
            logger.debug(f"Current path: {' -> '.join(path)}")
            
            # Check if we've reached the target router
            if current_device == target_router:
                logger.info(f"Reached target router: {current_device}")
                break
            
            # Get neighbors and find next hop
            next_hop = self._find_next_hop(current_device, target_router, visited)
            if not next_hop:
                logger.warning(f"No valid next hop found from {current_device}")
                break
                
            current_device = next_hop

        # Ensure router is in path
        if path and path[-1] != target_router:
            path.append(target_router)
            logger.debug(f"Added router {target_router} to path")

        logger.info(f"Final path: {' -> '.join(path)}")
        return path

    def _find_next_hop(self, current_device: str, target_router: str, visited: Set[str]) -> Optional[str]:
        """Find the next hop in the path"""
        try:
            neighbors_result = self.nr.filter(name=current_device).run(task=self.get_lldp_neighbors)
            neighbors = neighbors_result[current_device].result
            
            if not neighbors:
                logger.debug(f"No neighbors found for {current_device}")
                return None
            
            # Find unvisited neighbors
            possible_hops = []
            for neighbor in (neighbors if isinstance(neighbors, list) else [neighbors]):
                if isinstance(neighbor, dict):
                    neighbor_ip = self._extract_neighbor_ip(neighbor)
                    
                    if neighbor_ip and neighbor_ip not in visited:
                        # Try to resolve to inventory hostname
                        resolved_ip = self._resolve_neighbor_ip(neighbor_ip)
                        if resolved_ip:
                            possible_hops.append(resolved_ip)
            
            if not possible_hops:
                return None
            
            # Prioritize direct connection to router
            if target_router in possible_hops:
                return target_router
            
            # Prioritize devices that have the target router configured
            for hop in possible_hops:
                try:
                    if self.nr.inventory.hosts[hop].data.get('router') == target_router:
                        return hop
                except KeyError:
                    continue
            
            # Return first available hop
            return possible_hops[0]
            
        except Exception as e:
            logger.error(f"Error finding next hop from {current_device}: {str(e)}")
            return None

    def _extract_neighbor_ip(self, neighbor: Dict) -> Optional[str]:
        """Extract neighbor IP from LLDP data"""
        neighbor_ip = (neighbor.get('mgmt_address') or 
                      neighbor.get('neighbor') or 
                      neighbor.get('neighbor_name') or
                      neighbor.get('system_name'))
        
        if neighbor_ip and '.' not in neighbor_ip:
            # Handle hostname format
            neighbor_ip = neighbor_ip.split('.')[0]
        
        return neighbor_ip

    def _resolve_neighbor_ip(self, neighbor_ip: str) -> Optional[str]:
        """Resolve neighbor IP to inventory hostname"""
        # Direct match
        if neighbor_ip in self.nr.inventory.hosts:
            return neighbor_ip
        
        # Hostname match
        for hostname, host in self.nr.inventory.hosts.items():
            if (host.get('hostname', '') == neighbor_ip or 
                hostname.startswith(neighbor_ip)):
                return hostname
        
        return None

    def verify_vlan_path(self, initial_switch: str, target_port: str, vlan_id: str) -> Tuple[bool, str, List[str], Dict[str, DeviceResult]]:
        """Comprehensive VLAN path verification"""
        logger.info("Starting VLAN path verification")
        
        # Trace path
        path = self.trace_path_to_router(initial_switch)
        if not path:
            return False, "No path found to router", [], {}

        # Verify each device in path
        results = {}
        overall_success = True
        failure_reasons = []
        
        for i, device_ip in enumerate(path):
            logger.info(f"Verifying device {i+1}/{len(path)}: {device_ip}")
            
            result = DeviceResult(device_ip=device_ip, vlan_status="Unknown")
            
            # Check VLAN exists
            vlan_exists = self.nr.filter(name=device_ip).run(
                task=self.verify_vlan_exists,
                vlan_id=vlan_id
            )[device_ip].result
            
            if vlan_exists:
                result.vlan_status = "VLAN exists"
                logger.debug(f"VLAN {vlan_id} exists on {device_ip}")
            else:
                result.vlan_status = "VLAN missing"
                result.overall_status = VerificationStatus.FAIL
                overall_success = False
                failure_reasons.append(f"VLAN {vlan_id} missing on {device_ip}")
                logger.warning(f"VLAN {vlan_id} missing on {device_ip}")
            
            # First device: check access port
            if i == 0:
                access_ok = self.nr.filter(name=device_ip).run(
                    task=self.verify_access_vlan,
                    interface=target_port,
                    vlan_id=vlan_id
                )[device_ip].result
                
                if access_ok:
                    result.port_status = "Access port configured"
                    logger.debug(f"Access port {target_port} configured on {device_ip}")
                else:
                    result.port_status = f"Port {target_port} not in VLAN {vlan_id}"
                    result.overall_status = VerificationStatus.FAIL
                    overall_success = False
                    failure_reasons.append(f"Port {target_port} not in VLAN {vlan_id}")
                    logger.warning(f"Port {target_port} not in VLAN {vlan_id}")
            
            # Intermediate devices: check trunk ports
            elif i < len(path) - 1:
                next_device = path[i + 1]
                uplink_port = self.nr.filter(name=device_ip).run(
                    task=self.find_uplink_port,
                    neighbor_ip=next_device
                )[device_ip].result
                
                if uplink_port:
                    trunk_ok = self.nr.filter(name=device_ip).run(
                        task=self.verify_trunk_vlan,
                        interface=uplink_port,
                        vlan_id=vlan_id
                    )[device_ip].result
                    
                    if trunk_ok:
                        result.trunk_status = f"Trunk {uplink_port} allows VLAN"
                        logger.debug(f"Trunk {uplink_port} allows VLAN {vlan_id}")
                    else:
                        result.trunk_status = f"VLAN {vlan_id} blocked on {uplink_port}"
                        result.overall_status = VerificationStatus.FAIL
                        overall_success = False
                        failure_reasons.append(f"VLAN {vlan_id} blocked on {uplink_port}")
                        logger.warning(f"VLAN {vlan_id} blocked on {uplink_port}")
                else:
                    result.trunk_status = f"No uplink found to {next_device}"
                    result.overall_status = VerificationStatus.FAIL
                    overall_success = False
                    failure_reasons.append(f"No uplink found to {next_device}")
                    logger.warning(f"No uplink found to {next_device}")
            
            # Router endpoint
            else:
                result.role = "Router endpoint"
                logger.debug(f"Router endpoint: {device_ip}")
            
            # Set overall status if not already failed
            if result.overall_status == VerificationStatus.UNKNOWN:
                result.overall_status = VerificationStatus.PASS
            
            results[device_ip] = result

        # Generate summary message
        if overall_success:
            message = f"VLAN {vlan_id} path fully verified"
        else:
            message = f"VLAN path verification failed: {'; '.join(failure_reasons[:3])}"
        
        logger.info(f"Verification complete: {message}")
        return overall_success, message, path, results

    def visualize_path(self, path: List[str], verification_results: Dict[str, DeviceResult]):
        """Create enhanced visualization of the network path"""
        plt.ioff()
        fig, ax = plt.subplots(figsize=(18, 12))
        
        # Create graph
        G = nx.path_graph(path)
        
        # Position nodes
        pos = {node: (i * 3, 0) for i, node in enumerate(G.nodes())}
        
        # Prepare node colors and labels
        node_colors = []
        node_labels = {}
        status_labels = {}
        
        for node in G.nodes():
            result = verification_results.get(node)
            if not result:
                node_colors.append("gray")
                status_labels[node] = "No data"
                continue
            
            # Determine color based on status
            if result.overall_status == VerificationStatus.PASS:
                node_colors.append("lightgreen")
                status = "✓ PASS"
            elif result.overall_status == VerificationStatus.FAIL:
                node_colors.append("red")
                status = "✗ FAIL"
            else:
                node_colors.append("gray")
                status = "? UNKNOWN"
            
            # Create node label
            node_labels[node] = node
            
            # Create status label
            status_lines = [f"Status: {status}"]
            
            if result.vlan_status:
                status_lines.append(f"VLAN: {result.vlan_status}")
            
            if result.port_status:
                status_lines.append(f"Port: {result.port_status}")
            
            if result.trunk_status:
                status_lines.append(f"Trunk: {result.trunk_status}")
            
            if result.role:
                status_lines.append(f"Role: {result.role}")
            
            status_labels[node] = "\n".join(status_lines[:4])  # Limit to 4 lines
        
        # Draw network graph
        nx.draw_networkx_nodes(G, pos, node_color=node_colors, node_size=5000, 
                              edgecolors='black', linewidths=2)
        nx.draw_networkx_edges(G, pos, width=3, edge_color='steelblue', 
                              arrows=True, arrowstyle='-|>', arrowsize=30)
        
        # Add device labels (above nodes)
        name_pos = {k: (v[0], v[1] + 0.8) for k, v in pos.items()}
        nx.draw_networkx_labels(G, name_pos, labels=node_labels, font_size=10, 
                               font_weight="bold")
        
        # Add status labels (below nodes)
        status_pos = {k: (v[0], v[1] - 1.2) for k, v in pos.items()}
        nx.draw_networkx_labels(G, status_pos, labels=status_labels, font_size=8,
                               bbox=dict(facecolor='white', edgecolor='black',
                                       boxstyle='round,pad=0.5', alpha=0.9))
        
        # Add legend
        legend_elements = [
            plt.Line2D([0], [0], marker='o', color='w', label='Pass', 
                      markerfacecolor='lightgreen', markersize=15),
            plt.Line2D([0], [0], marker='o', color='w', label='Fail', 
                      markerfacecolor='red', markersize=15),
            plt.Line2D([0], [0], marker='o', color='w', label='Unknown', 
                      markerfacecolor='gray', markersize=15)
        ]
        
        plt.legend(handles=legend_elements, loc='upper right', fontsize=12, 
                  title="Verification Status", title_fontsize=14)
        
        plt.title("Network VLAN Path Verification Results", pad=40, fontsize=18, 
                 fontweight='bold')
        plt.axis('off')
        plt.tight_layout()
        plt.show(block=True)
        plt.ion()


def main():
    """Main function to run VLAN path verification"""
    # Configuration
    initial_switch = "172.17.57.243"
    target_port = "GigabitEthernet1/0/10"
    vlan_id = "5"
    
    # Create verifier instance
    verifier = NetworkVerifier(config_file="config.yaml")
    
    try:
        # Run verification
        success, message, path, results = verifier.verify_vlan_path(
            initial_switch, target_port, vlan_id
        )
        
        # Print results
        print("\n" + "="*60)
        print(f"VLAN PATH VERIFICATION {'SUCCEEDED' if success else 'FAILED'}")
        print("="*60)
        print(f"Initial Switch: {initial_switch}")
        print(f"Target Port: {target_port}")
        print(f"VLAN ID: {vlan_id}")
        print(f"Path: {' → '.join(path)}")
        print(f"Status: {message}")
        print("="*60)
        
        # Detailed results
        print("\nDETAILED RESULTS:")
        print("-" * 40)
        for device_ip, result in results.items():
            print(f"\nDevice: {device_ip}")
            print(f"  Overall Status: {result.overall_status.value.upper()}")
            print(f"  VLAN Status: {result.vlan_status}")
            if result.port_status:
                print(f"  Port Status: {result.port_status}")
            if result.trunk_status:
                print(f"  Trunk Status: {result.trunk_status}")
            if result.role:
                print(f"  Role: {result.role}")
        
        # Show visualization
        if path and results:
            print("\nGenerating network visualization...")
            verifier.visualize_path(path, results)
        
        return success
        
    except Exception as e:
        logger.error(f"Verification failed with error: {str(e)}")
        print(f"\nERROR: Verification failed - {str(e)}")
        return False
    
    finally:
        # Cleanup
        if hasattr(verifier, 'nr') and verifier.nr:
            verifier.nr.close_connections()


if __name__ == "__main__":
    import sys
    
    # Allow command line arguments
    if len(sys.argv) >= 4:
        initial_switch = sys.argv[1]
        target_port = sys.argv[2]
        vlan_id = sys.argv[3]
        
        verifier = NetworkVerifier()
        success, message, path, results = verifier.verify_vlan_path(
            initial_switch, target_port, vlan_id
        )
        
        if success:
            print(f"✓ VLAN {vlan_id} path verification successful")
            sys.exit(0)
        else:
            print(f"✗ VLAN {vlan_id} path verification failed: {message}")
            sys.exit(1)
    else:
        # Use default configuration
        success = main()
        sys.exit(0 if success else 1)